Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype paths finfun ssralg bigops finset prime.
Require Import groups morphisms perm action automorphism normal. 
Require Import cyclic abelian gfunc.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GroupScope.

(*****************************************************************************)
(* Standard group notions and constructions based on the prime decomposition *)
(* of the order of the group or its elements.                                *)
(*   pi.-group G      <=> G is a pi-group                                    *)
(*                    <-> pi.-nat #|G|                                       *)
(*     + Recall that here and in the sequel pi can be a prime p              *)
(*   pi.-subgroup(H) G   <=> H is a pi-subgroup of G                         *)
(*                    <-> (H \subset G) && pi.-group H                       *)
(*     + This is provided mostly as a shorhand, with few associated lemmas.  *)
(*     + However, we do establish some results on maximal pi-subgroups.      *)
(*   pi.-elt x        <=> x is a pi-element                                  *)
(*                    <-> pi.-nat #[x] (<-> pi.-group <[x]>)                 *)
(*   x.`_pi           == the pi-constituent of x: the only pi-element        *)
(*                       y \in <[x]> s.t. x * y^-1 is a pi'-element          *)
(*   pi.-Hall(G) H    <=> H is a Hall pi-subgroup of G                       *)
(*                    <-> [&& H \subset G, pi.-group H & pi^'.-nat #|G : H|] *)
(*                     -> #|H| = #|G|`_pi                                    *)
(*   p.-Sylow(G) P    <=> P is a Sylow p-subgroup of G                       *)
(*                    <-> p.-Hall(G) P                                       *)
(*     + This is only a display notation; note that due to an ugly display   *)
(*       engine bug, Coq will fail to use the notation under a coercion such *)
(*       as is_true, and will display p.-Hall(G) P instead.                  *)
(*   'Syl_p(G)        == the set of the p-Sylow subgroups of G               *)
(*                    := [set P : {group _} | p.-Sylow(G) P]                 *)
(*   p_group P        <=> P is a p-group for some prime p                    *)
(*                    <-> (pdiv #|P|).-group P                               *)
(*   Hall G H         <=> G is a Hall pi-subgroup of G for some pi           *)
(*                    <-> coprime #|H| #|G : H| && (H \subset G)             *)
(*   Sylow G P        <=> P is a Sylow p-subgroup of G for some p            *)
(*                    <-> p_group P && Hall G P                              *)
(*   'O_pi(G)         == the pi-core of G                                    *)
(*                    := the largest normal pi-subgroup of G                 *)
(*   'O_{pi2, pi1}(G) == the pi1,pi2-core of G                               *)
(*                    := the pi1-core of G mod 'O_pi2(G)                     *)
(*     + We have 'O_{pi2, pi1}(G) / 'O_pi2(G) = 'O_pi1(G / 'O_pi2(G))        *)
(*          with 'O_pi2(G) <| 'O_{pi2, pi1}(G) <| G                          *)
(*   'O_{pn, ..., p1}(G) == the p1, ..., pn-core of G, more generally        *)
(*                    := the p1-core of G mod 'O_{pn, ..., p2}(G)            *)
(*   p.-length_1 G    <=> G has p-length 1, as per B&G p.2                   *)
(*                    <-> 'O_{p^', p, p^'}(G) == G                           *)
(*   'Ohm_n(P)        == if P is a p-group, the group generated by the x of  *)
(*                       order at most p ^ n in P; more generally, the group *)
(*                       generated by {x in P | logn q x <= n for all q}     *)
(*   'Mho^n(P)        == if P is a p-group, the group generated by all the   *)
(*                       x ^+ (p ^ n) for x in P; more generally, the group  *)
(*                       generated by {\prod_q (x.`_q ^+ (q ^ n) | x in P}   *)
(*   exponent G       == the exponent of G                                   *)
(*                    := \big[lcmn/1]_(x \in G) #[x]                         *)
(*   abelem E         <=> E is elementary abelian                            *)
(*                    <-> abelian E && (exponent E).-group E                 *)
(*                    <-> p.-abelem E for some prime p (see below)           *)
(*   p.-abelem E      <=> E is an elementary abelian p-group                 *)
(*                    <-> abelem E && p.-group E                             *)
(*                    <-> abelian E && (exponent E %| p) if p is a prime     *)
(*   'E_p(G)          == the set of p-abelem subgroups of G                  *)
(*                    := [set E : {group _} | p.-abelem E && (E \subset G)]  *)
(*   'm_p(G)          == the p-rank of G                                     *)
(*                    := \max_(E \in 'E_p(G)) logn p #|E|                    *)
(*   'm(G)            == the rank of G                                       *)
(*                    := \max_(0 <= p < #|G|.+1) 'm_p(G)                     *)
(*   'E_p^n(G)        == the set of rank n p-abelem subgroups of G           *)
(*                    := [set E \in 'E_p(G) | logn p #|E| == n]              *)
(*                    := [set E \in 'E_p(G) | #|E| == p ^ n]%N if prime p    *)
(*   'E_p^*(G)        == the set of maximal p-abelem subgroups of G          *)
(*                    := [set E | [max E | E \in 'E_p(G)]]                   *)
(*   'E^n(G)          == the set of rank n abelem subgroups of G             *)
(*                    := \bigcup_(0 <= p < #|G|.+1) 'E_p^n(G)                *)
(* NOT YET SUPPORTED/TESTED, MAY BE DEFERRED TO ABELIAN:                     *)
(*   basis A X        <=> X is a basis for the abelian group A               *)
(*                    <-> [/\ <<X>> = A, 1 \notin X                          *)
(*                          & forall x \in X, <[x]> :&: <<X :\ x>> = 1]      *)
(*   abel_type P      == the abelian type of an abelian p-group P            *)
(*                    := the sorted seq of #[x], x in some basis X of P      *)
(*   homocyclic P     <=> P is a homocyclic abelian p-group                  *)
(*                    <-> constant (abel_type P)                             *)
(* Note that notions are always defined on sets even though their name       *)
(* indicates "group" properties; the actual definition of the notion never   *)
(* tests for the group property, since this property will always be          *)
(* provided by a (canonical) group structure. Similarly, p-group properties  *)
(* assume without test that p is a prime.                                    *)
(*****************************************************************************)

Section PgroupDefs.

(* We defer the definition of the functors ('0_p(G), etc) because they need *)
(* to quantify over the finGroupType explicitly.                            *)

Variable gT : finGroupType.
Implicit Type x : gT.
Implicit Types A B : {set gT}.
Implicit Type pi : nat_pred.
Implicit Types p n : nat.

Definition pgroup pi A := pi.-nat #|A|.

Definition psubgroup pi A B := (B \subset A) && pgroup pi B.

Definition p_group A := pgroup (pdiv #|A|) A.

Definition p_elt pi x := pi.-nat #[x].

Definition constt x pi := x ^+ (chinese #[x]`_pi #[x]`_pi^' 1 0).

Definition Hall A B := (B \subset A) && coprime #|B| #|A : B|.

Definition pHall pi A B := [&& B \subset A, pgroup pi B & pi^'.-nat #|A : B|].

Definition Syl p A := [set P : {group gT} | pHall p A P].

Definition Sylow A B := p_group B && Hall A B.

Definition exponent A := \big[lcmn/1%N]_(x \in A) #[x].

Definition abelem A := abelian A && pgroup (exponent A) A.

Definition p_abelem p A := abelem A && pgroup p A.

Definition pElem p A := [set E : {group gT} | (E \subset A) && p_abelem p E].

Definition pnElem p n A := [set E \in pElem p A | logn p #|E| == n].

Definition nElem n A :=  \bigcup_(0 <= p < #|A|.+1) pnElem p n A.

Definition pmaxElem p A := [set E | [max E | (E \subset A) && p_abelem p E]].

Definition p_rank p A := \max_(E \in pElem p A) logn p #|E|.

Definition rank A := \max_(0 <= p < #|A|.+1) p_rank p A.

Definition basis A X :=
  [&& <<X>> == A, 1 \notin X
    & forallb x, (x \in X) ==> (<[x]> :&: <<X :\ x>> == 1)].

Definition abel_type A :=
  if pick (basis A) is Some X then
    sort leq (map order (enum (mem X)))
  else [::].

Definition homocyclic A := [&& abelian A, p_group A & constant (abel_type A)].

End PgroupDefs.

Prenex Implicits p_group Hall Sylow exponent abelem rank.
Prenex Implicits basis abel_type homocyclic.

Notation "pi .-group" := (pgroup pi)
  (at level 2, format "pi .-group") : group_scope.

Notation "pi .-subgroup ( A )" := (psubgroup pi A)
  (at level 8, format "pi .-subgroup ( A )") : group_scope.

Notation "pi .-elt" := (p_elt pi)
  (at level 2, format "pi .-elt") : group_scope.

Notation "x .`_ pi" := (constt x pi)
  (at level 3, format "x .`_ pi") : group_scope.

Notation "pi .-Hall ( G )" := (pHall pi G)
  (at level 8, format "pi .-Hall ( G )") : group_scope.

Notation "p .-Sylow ( G )" := (nat_pred_of_nat p).-Hall(G)
  (at level 8, format "p .-Sylow ( G )") : group_scope.

Notation "''Syl_' p ( G )" := (Syl p G)
  (at level 8, p at level 2, format "''Syl_' p ( G )") : group_scope.

Notation "p .-abelem" := (p_abelem p)
  (at level 2, format "p .-abelem") : group_scope.

Notation "''E_' p ( G )" := (pElem p G)
  (at level 8, p at level 2, format "''E_' p ( G )") : group_scope.

Notation "''E_' p ^ n ( G )" := (pnElem p n G)
  (at level 8, p, n at level 2, format "''E_' p ^ n ( G )") : group_scope.

Notation "''E' ^ n ( G )" := (nElem n G)
  (at level 8, n at level 2, format "''E' ^ n ( G )") : group_scope.

Notation "''E_' p ^* ( G )" := (pmaxElem p G)
  (at level 8, p at level 2, format "''E_' p ^* ( G )") : group_scope.

Notation "''m' ( A )" := (rank A)
  (at level 8, format "''m' ( A )") : group_scope.

Notation "''m_' p ( A )" := (p_rank p A)
  (at level 8, p at level 2, format "''m_' p ( A )") : group_scope.

Section PgroupProps.

Variable gT : finGroupType.
Implicit Type pi : nat_pred.
Implicit Type p : nat.
Implicit Types x y z : gT.
Implicit Types A B C D : {set gT}.
Implicit Types G H K P Q : {group gT}.

Lemma trivgVpdiv : forall G, G :=: 1 \/ (exists2 p, prime p & p %| #|G|).
Proof.
move=> G; case: (leqP #|G| 1) => [leG1|lt1G]; [left | right].
  exact: card_le1_trivg.
by exists (pdiv #|G|); rewrite ?dvdn_pdiv ?prime_pdiv.
Qed.

Lemma pgroupP : forall pi G,
  reflect (forall p, prime p -> p %| #|G| -> p \in pi) (pi.-group G).
Proof. move=> pi G; exact: pnatP. Qed.

Lemma pgroup1 : forall pi, pi.-group (1 : {set gT}).
Proof. by move=> pi; rewrite /pgroup cards1. Qed.

Lemma pgroupS : forall pi G H, H \subset G -> pi.-group G -> pi.-group H.
Proof. move=> pi G H sHG; exact: pnat_dvd (cardSg sHG). Qed.

Lemma pgroupM : forall pi G H, pi.-group (G * H) = pi.-group G && pi.-group H.
Proof.
move=> pi G H; have GH_gt0: 0 < #|G :&: H| := cardG_gt0 _.
rewrite /pgroup -(mulnK #|_| GH_gt0) -mul_cardG -(LaGrangeI G H) -mulnA.
by rewrite mulKn // -(LaGrangeI H G) setIC !pnat_mul andbCA; case: (pnat _).
Qed.

Lemma pgroupJ : forall pi G x, pi.-group (G :^ x) = pi.-group G.
Proof. by move=> pi G x; rewrite /pgroup cardJg. Qed.

Lemma pgroup_p : forall p P, p.-group P -> p_group P.
Proof.
move=> p P pgP; case: (leqP #|P| 1).
  by move/card_le1_trivg->; exact: pgroup1.
move/prime_pdiv=> pr_q; have:= pgroupP _ _ pgP _ pr_q (dvdn_pdiv _).
by rewrite /p_group; move/eqnP->.
Qed.

Lemma p_groupP : forall P, p_group P -> exists2 p, prime p & p.-group P.
Proof.
move=> P; case: (ltnP 1 #|P|); first by move/prime_pdiv; exists (pdiv #|P|).
move/card_le1_trivg=> -> _; exists 2 => //; exact: pgroup1.
Qed.

Lemma pgroup_1Vpr : forall p G, p.-group G -> 
  G :=: 1 \/ [/\ prime p, p <= #|G| & exists m, #|G| = p ^ m.+1]%N.
Proof.
move=> p G pG; case/p_groupP: (pgroup_p pG) => q pr_q.
case/p_natP=> // [[|m] defG]; [left; exact: card1_trivg | right].
have qG: q %| #|G| by rewrite defG expnS dvdn_mulr.
have <-: q = p by apply/eqP; move/pgroupP: pG; exact.
by split; [|exact: dvdn_leq | exists m].
Qed.

Lemma card_Hall : forall pi G H, pi.-Hall(G) H -> #|H| = #|G|`_pi.
Proof.
move=> pi G H; case/and3P=> sHG piH pi'H.
by rewrite -(LaGrange sHG) partn_mul ?LaGrange // part_pnat ?part_p'nat ?muln1.
Qed.

Lemma pHall_sub : forall pi A B, pi.-Hall(A) B -> B \subset A.
Proof. by move=> pi A B; case/andP. Qed.

Lemma pHall_pgroup : forall pi A B, pi.-Hall(A) B -> pi.-group B.
Proof. by move=> pi A B; case/and3P. Qed.

Lemma pHallP : forall pi G H,
  reflect (H \subset G /\ #|H| = #|G|`_pi) (pi.-Hall(G) H). 
Proof.
move=> pi G H; apply: (iffP idP) => [piH | [sHG oH]].
  split; [exact: pHall_sub piH | exact: card_Hall].
rewrite /pHall sHG -divgS // /pgroup oH.
by rewrite -{2}(@partnC pi #|G|) ?mulKn ?pnat_part.
Qed.

Lemma pHallE : forall pi G H,
  pi.-Hall(G) H = (H \subset G) && (#|H| == #|G|`_pi).
Proof. by move=> pi G H; apply/pHallP/andP=> [] [->]; move/eqP. Qed.

Lemma pHall_Hall : forall pi A B, pi.-Hall(A) B -> Hall A B.
Proof.
move=> pi A B; case/and3P=> sBA piB pi'B.
by rewrite /Hall sBA (pnat_coprime piB).
Qed.

Lemma Hall_pi : forall G H, Hall G H -> \pi(#|H|).-Hall(G) H.
Proof.
move=> G H; case/andP=> sHG coHG.
by rewrite /pHall sHG /pgroup pnat_pi -?coprime_pi'.
Qed.

Lemma HallP : forall G H, Hall G H -> exists pi, pi.-Hall(G) H.
Proof. move=> G H HallH; exists \pi(#|H|); exact: Hall_pi. Qed.

Lemma pHallJ2 : forall pi G H x,
   pi.-Hall(G :^ x) (H :^ x) = pi.-Hall(G) H.
Proof. by move=> pi G H x; rewrite !pHallE conjSg !cardJg. Qed.

Lemma pHallJ : forall pi G H x,
  x \in G -> pi.-Hall(G) (H :^ x) = pi.-Hall(G) H.
Proof. by move=> pi G H x Gx; rewrite -{1}(conjGid Gx) pHallJ2. Qed.

Lemma HallJ : forall G H x, x \in G -> Hall G (H :^ x) = Hall G H.
Proof.
move=> G H x Gx; rewrite /Hall -!divgI.
by rewrite -{1 3}(conjGid Gx) conjSg -conjIg !cardJg.
Qed.

Lemma psubgroupJ : forall pi G H x,
  x \in G -> pi.-subgroup(G) (H :^ x) = pi.-subgroup(G) H.
Proof.
by move=> pi G H x Gx; rewrite /psubgroup pgroupJ -{1}(conjGid Gx) conjSg.
Qed.

Lemma p_groupJ : forall P x, p_group (P :^ x) = p_group P.
Proof. by move=> P x; rewrite /p_group cardJg pgroupJ. Qed.

Lemma SylowJ : forall G P x, x \in G -> Sylow G (P :^ x) = Sylow G P.
Proof. by move=> G P x Gx; rewrite /Sylow p_groupJ HallJ. Qed.

Lemma p_Sylow : forall p G P, p.-Sylow(G) P -> Sylow G P.
Proof.
move=> p G P pP.
by rewrite /Sylow (pgroup_p (pHall_pgroup pP)) (pHall_Hall pP).
Qed.

Lemma pHall_subl : forall pi G K H,
  H \subset K -> K \subset G -> pi.-Hall(G) H -> pi.-Hall(K) H.
Proof.
move=> pi G K H sHK sKG; rewrite /pHall sHK; case/and3P=> _ ->.
apply: pnat_dvd; exact: indexSg.
Qed.

Lemma Hall1 : forall G, Hall G 1.
Proof. by move=> G; rewrite /Hall sub1G cards1 coprime1n. Qed.

Lemma p_group1 : @p_group gT 1.
Proof. by rewrite (@pgroup_p 2) ?pgroup1. Qed.

Lemma Sylow1 : forall G, Sylow G 1.
Proof. by move=> G; rewrite /Sylow p_group1 Hall1. Qed.

Lemma eq_pHall : forall pi1 pi2 A B,
  pi1 =i pi2 -> pi1.-Hall(A) B = pi2.-Hall(A) B.
Proof.
move=> pi1 pi2 A B eq_pi; congr [&& _, _ & _]; apply: eq_pnat => // q.
congr (~~ _); exact: eq_pi.
Qed.

Lemma SylowP : forall G P,
  reflect (exists2 p, prime p & p.-Sylow(G) P) (Sylow G P).
Proof.
move=> G P; apply: (iffP idP) => [| [p _]]; last exact: p_Sylow.
case/andP; case/p_groupP=> p p_pr; case/p_natP=> // [[P1 _ | n oP]].
  have{p p_pr P1} ->: P :=: 1 by apply: card1_trivg; rewrite P1.
  pose p := pdiv #|G|.+1; have pr_p: prime p by rewrite prime_pdiv ?ltnS.
  exists p; rewrite // pHallE sub1G cards1 part_p'nat //.
  apply/pgroupP=> q pr_q qG; apply/eqnP=> def_q.
  have: p %| #|G| + 1 by rewrite addn1 dvdn_pdiv.
  by rewrite dvdn_addr -def_q // euclid1.
move/Hall_pi; rewrite oP pi_of_exp // (eq_pHall _ _ (pi_of_prime _)) //.
by exists p.
Qed.

Lemma p_elt_exp : forall pi x m, pi.-elt (x ^+ m) = (#[x]`_pi^' %| m).
Proof.
move=> pi x m; apply/idP/idP=> [pi_xm|].
  rewrite -(@gauss _ #[x ^+ m]); last first.
    by rewrite coprime_sym (pnat_coprime pi_xm) ?pnat_part.
  apply: (@dvdn_trans #[x]); first by rewrite -{2}[#[x]](partnC pi) ?dvdn_mull.
  by rewrite order_dvdn mulnC expgn_mul expg_order.
case/dvdnP=> q ->{m}; rewrite mulnC; apply: pnat_dvd (pnat_part pi #[x]).
by rewrite order_dvdn -expgn_mul mulnC mulnA partnC // -order_dvdn dvdn_mulr.
Qed.

Lemma mem_p_elt : forall pi x G, pi.-group G -> x \in G -> pi.-elt x.
Proof. by move=>pi x G piG Gx; apply: pgroupS piG; rewrite cycle_subG. Qed.

Lemma p_eltM_norm : forall pi x y, x \in 'N(<[y]>) ->
  pi.-elt x -> pi.-elt y -> pi.-elt (x * y).
Proof.
move=> pi x y nyx pi_x pi_y; apply: (@mem_p_elt pi _ (<[x]> <*> <[y]>)%G).
  rewrite /= norm_mulgenEl ?cycle_subG // pgroupM; exact/andP.
by rewrite groupM // mem_gen // inE cycle_id ?orbT.
Qed.

Lemma p_eltM :  forall pi x y, commute x y ->
  pi.-elt x -> pi.-elt y -> pi.-elt (x * y).
Proof.
move=> pi x y cxy; apply: p_eltM_norm; apply: (subsetP (cent_sub _)).
rewrite cent_gen cent_set1; exact/cent1P.
Qed.

Lemma p_elt1 : forall pi, pi.-elt (1 : gT).
Proof. by move=> pi; rewrite /p_elt order1. Qed.

Lemma p_eltV : forall pi x, pi.-elt x^-1 = pi.-elt x.
Proof. by move=> pi x; rewrite /p_elt orderV. Qed.

Lemma p_eltX : forall pi x n, pi.-elt x -> pi.-elt (x ^+ n).
Proof.
by move=> pi x n; rewrite -{1}[x]expg1 !p_elt_exp dvdn1; move/eqnP->.
Qed.

Lemma p_eltJ : forall pi x y, pi.-elt (x ^ y) = pi.-elt x.
Proof. by move=> pi x y; congr pnat; rewrite orderJ. Qed.

Lemma sub_p_elt : forall pi1 pi2 x,
  {subset pi1 <= pi2} -> pi1.-elt x -> pi2.-elt x.
Proof. move=> pi1 pi2 x pi12; apply: sub_in_pnat => q _; exact: pi12. Qed.

Lemma eq_p_elt : forall pi1 pi2 x, pi1 =i pi2 -> pi1.-elt x = pi2.-elt x.
Proof. move=> pi1 pi2 x pi12; exact: eq_pnat. Qed.

Lemma p_eltNK : forall pi x, pi^'^'.-elt x = pi.-elt x.
Proof. move=> pi x; exact: pnatNK. Qed.

Lemma eq_constt : forall pi1 pi2 x, pi1 =i pi2 -> x.`_pi1 = x.`_pi2.
Proof.
move=> pi1 pi2 x pi12; congr (x ^+ (chinese _ _ 1 0)); apply: eq_partn => //.
move=> q; congr (~~ _); exact: pi12.
Qed.

Lemma consttNK : forall pi x, x.`_pi^'^' = x.`_pi.
Proof. by move=> pi x; rewrite /constt !partnNK. Qed.

Lemma cycle_constt : forall pi (x : gT), x.`_pi \in <[x]>.
Proof. move=> pi x; exact: mem_cycle. Qed.

Lemma consttV : forall pi x, (x^-1).`_pi = (x.`_pi)^-1.
Proof. by move=> pi x; rewrite /constt expVgn orderV. Qed.

Lemma constt1 : forall pi, 1.`_pi = 1 :> gT.
Proof. move=> pi; exact: exp1gn. Qed.

Lemma consttJ : forall pi x y, (x ^ y).`_pi = x.`_pi ^ y.
Proof. by move=> pi x y; rewrite /constt orderJ conjXg. Qed.

Lemma p_elt_constt : forall pi x, pi.-elt x.`_pi.
Proof. by move=> pi x; rewrite p_elt_exp /chinese addn0 mul1n dvdn_mulr. Qed.

Lemma consttC : forall pi x, x.`_pi * x.`_pi^' = x.
Proof.
move=> pi x; apply/eqP; rewrite -{3}[x]expg1 -expgn_add eq_expg_mod_order.
rewrite partnNK -{5 6}(@partnC pi #[x]) // /chinese !addn0.
by rewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC ?eqxx.
Qed.

Lemma p'_elt_constt : forall pi x, pi^'.-elt (x * (x.`_pi)^-1).
Proof.
by move=> pi x; rewrite -{1}(consttC pi^' x) consttNK mulgK p_elt_constt.
Qed.

Lemma order_constt : forall pi (x : gT), #[x.`_pi] = #[x]`_pi.
Proof.
move=> pi x; rewrite -{2}(consttC pi x) orderM; [|exact: commuteX2|].
  rewrite partn_mul // part_pnat ?part_p'nat ?muln1 //; exact: p_elt_constt.
apply: (@pnat_coprime pi); exact: p_elt_constt.
Qed.

Lemma consttM : forall pi x y, commute x y -> (x * y).`_pi = x.`_pi * y.`_pi.
Proof.
move=> pi x y cxy; pose m := #|<<[set x; y]>>|.
pose k := chinese m`_pi m`_pi^' 1 0; have m_gt0: 0 < m := cardG_gt0 _.
suffices kXpi: forall z, z \in <<[set x; y]>> -> z.`_pi = z ^+ k.
  by rewrite !kXpi ?expMgn // ?groupM ?mem_gen // !inE eqxx ?orbT.
move=> z xyz; have{xyz} zm: #[z] %| m by rewrite cardSg ?cycle_subG.
apply/eqP; rewrite eq_expg_mod_order -{3 4}[#[z]](partnC pi) //.
rewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC //.
rewrite -!(modn_dvdm k (partn_dvd _ m_gt0 zm)).
rewrite chinese_modl ?chinese_modr ?coprime_partC //.
by rewrite !modn_dvdm ?partn_dvd ?eqxx.
Qed.

Lemma consttX : forall pi x n, (x ^+ n).`_pi = x.`_pi ^+ n.
Proof.
move=> pi x; elim=> [|n IHn]; first exact: constt1.
rewrite !expgS consttM ?IHn //; exact: commuteX.
Qed.

Lemma constt1P: forall pi x, reflect (x.`_pi = 1) (pi^'.-elt x).
Proof.
move=> pi x; rewrite -{2}[x]expg1 p_elt_exp -order_constt consttNK.
rewrite order_dvdn expg1; exact: eqP.
Qed.

Lemma constt_p_elt : forall pi x, pi.-elt x -> x.`_pi = x.
Proof.
move=> pi x; rewrite -p_eltNK -{3}(consttC pi x); move/constt1P->.
by rewrite mulg1.
Qed.

Lemma sub_in_constt : forall pi1 pi2 x,
  {in \pi(#[x]), {subset pi1 <= pi2}} -> x.`_pi2.`_pi1 = x.`_pi1.
Proof.
move=> pi1 pi2 x pi12; rewrite -{2}(consttC pi2 x).
rewrite consttM; last exact: commuteX2.
rewrite (constt1P _ x.`_pi2^' _) ?mulg1 //.
apply: sub_in_pnat (p_elt_constt _ x) => p; rewrite order_constt => pi_p.
apply: contra; apply: pi12.
by rewrite -[#[x]](partnC pi2^') // primes_mul // pi_p.
Qed.

Lemma prod_constt : forall x, \prod_(0 <= p < #[x].+1) x.`_p = x.
Proof.
move=> x; pose lp n := [pred p | p < n].
have: (lp #[x].+1).-elt x by apply/pnatP=> // p _; exact: dvdn_leq.
move/constt_p_elt=> def_x; symmetry; rewrite -{1}def_x {def_x}.
elim: _.+1 => [|p IHp].
  by rewrite big_nil; apply/constt1P; exact/pgroupP.
rewrite big_nat_recr /= -{}IHp -(consttC (lp p) x.`__); congr (_ * _).
  rewrite sub_in_constt // => q _; exact: leqW.
set y := _.`__; rewrite -(consttC p y) (constt1P p^' _ _) ?mulg1.
  by rewrite 2?sub_in_constt // => q _; move/eqnP->; rewrite !inE ?ltnn.
rewrite /p_elt pnatNK !order_constt -partnI.
apply: sub_in_pnat (pnat_part _ _) => q _.
by rewrite !inE ltnS -leqNgt -eqn_leq.
Qed.

Lemma max_pgroupJ : forall pi M G x,
  x \in G -> [max M | pi.-subgroup(G) M] -> 
   [max M :^ x of M | pi.-subgroup(G) M].
Proof.
move=> pi M G x Gx; case/maxgroupP=> piM maxM; apply/maxgroupP.
split=> [|H piH]; first by rewrite psubgroupJ.
rewrite -(conjsgKV x H) conjSg; move/maxM=> /= -> //.
by rewrite psubgroupJ ?groupV.
Qed.

Lemma comm_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H \subset G ->
  commute H M -> H \subset M.
Proof.
move=> pi H M G; case/maxgroupP; case/andP=> sMG piM maxM piH sHG cHM.
rewrite -(maxM (H <*> M)%G) /= comm_mulgenE ?(mulG_subl, mulG_subr) //.
by rewrite /psubgroup pgroupM piM piH mul_subG.
Qed.

Lemma normal_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H <| G -> H \subset M.
Proof.
move=> pi H M G maxM piH; case/andP=> sHG nHG.
apply: comm_sub_max_pgroup piH sHG _ => //; apply: commute_sym; apply: normC.
by apply: subset_trans nHG; case/andP: (maxgroupp maxM).
Qed.

Lemma norm_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H \subset G ->
  H \subset 'N(M) -> H \subset M.
Proof.
move=> pi H M G maxM piH sHG; move/normC; exact: comm_sub_max_pgroup piH sHG.
Qed.

Lemma Hall_max : forall pi H G, pi.-Hall(G) H -> [max H | pi.-subgroup(G) H].
Proof.
move=> pi H G hallH; apply/maxgroupP; split=> [|K].
  by rewrite /psubgroup; case/and3P: hallH => ->.
case/andP=> sKG piK sHK; apply/eqP; rewrite eq_sym eqEcard sHK.
by rewrite (card_Hall hallH) -(part_pnat piK) dvdn_leq ?partn_dvd ?cardSg.
Qed.

Lemma psubgroup1 : forall pi G, pi.-subgroup(G) 1.
Proof. by move=> pi G; rewrite /psubgroup sub1G pgroup1. Qed.

Lemma Cauchy : forall p G, prime p -> p %| #|G| -> {x | x \in G & #[x] = p}.
Proof.
move=> p G pr_p; elim: {G}_.+1 {-2}G (ltnSn #|G|) => // n IHn G.
rewrite ltnS => leGn pG; pose xpG := [pred x \in G | #[x] == p].
case: (pickP xpG) => [x|no_x]; first by case/andP=> Gx; move/eqP; exists x.
have{pG n leGn IHn} pZ: p %| #|'C_G(G)|.
  have:= pG; rewrite -(cardsID 'C(G)) dvdn_addl //.
  have: [acts (G | 'J) on G :\: 'C(G)]; last move/acts_sum_card_orbit <-.
    by apply/actsP=> x Gx y; rewrite !inE -!mem_conjgV -centJ conjGid ?groupV.
  apply big_prop => // [|C]; first exact: dvdn_add.
  case/imsetP=> x; case/setDP=> Gx nCx ->{C}; rewrite card_orbit conjg_astab1.
  move: pG; rewrite -(LaGrange (subsetIl G 'C[x]%G)) euclid //; case/orP => //.
  case/IHn=> [|y]; last first.
    by case/setIP=> Gy _; move/eqP=> oyp; case/andP: (no_x y).
  apply: leq_trans leGn; apply: proper_card; rewrite properE subsetIl.
  by rewrite subsetI subxx /= -cent_set1 centsC sub1set.
have [Q maxQ _]: {Q | [max Q | p^'.-subgroup('C_G(G)) Q] & 1%G \subset Q}.
  apply: maxgroup_exists; exact: psubgroup1.
case/andP: (maxgroupp maxQ) => sQC; rewrite /pgroup p'natE //; case/negP.
apply: dvdn_trans pZ (cardSg _); apply/subsetP=> x; case/setIP=> Gx Cx.
rewrite -sub1set -gen_subG (normal_sub_max_pgroup maxQ) //; last first.
  rewrite /normal subsetI !cycle_subG ?Gx ?cents_norm ?subIset ?andbT //=.
  by rewrite centsC cycle_subG Cx.
rewrite /pgroup p'natE //= -[#|_|]/#[x]; apply/dvdnP=> [[m oxm]].
have m_gt0: 0 < m by apply: dvdn_gt0 (order_gt0 x) _; rewrite oxm dvdn_mulr.
case/idP: (no_x (x ^+ m)); rewrite /= groupX //= orderXgcd //= oxm.
by rewrite gcdnC gcdn_mulr mulKn.
Qed.

(* These lemmas actually hold for maximal pi-groups, but below we'll *)
(* derive from the Cauchy lemma that a normal max pi-group is Hall.  *)

Lemma subset_normal_Hall : forall pi H G K,
  pi.-Hall(G) H -> H <| G -> (K \subset H) = pi.-subgroup(G) K.
Proof.
move=> pi H G K hallH nHG; apply/idP/andP=> [sKH | [sKG piK]].
  by case/and3P: hallH => sHG piH _; rewrite (pgroupS sKH) ?(subset_trans sKH).
apply: norm_sub_max_pgroup (Hall_max hallH) piK _ _ => //.
case/andP: nHG => _; exact: subset_trans.
Qed.

Lemma mem_normal_Hall : forall pi H G x,
  pi.-Hall(G) H -> H <| G -> x \in G -> (x \in H) = pi.-elt x.
Proof.
move=> pi H G x hallH nHG Gx; have:= subset_normal_Hall <[x]> hallH nHG.
by rewrite /psubgroup !gen_subG !sub1set Gx.
Qed.

Lemma uniq_normal_Hall : forall pi H G K,
  pi.-Hall(G) H -> H <| G -> [max K | pi.-subgroup(G) K] -> K :=: H.
Proof.
move=> pi H G K hallH nHG; case/maxgroupP.
rewrite -(subset_normal_Hall _ hallH) /psubgroup // => sKH maxK.
rewrite (maxK H) //; exact: maxgroupp (Hall_max hallH).
Qed.

End PgroupProps.

Implicit Arguments constt1P [gT pi x].
Prenex Implicits constt1P.

Lemma normal_max_pgroup_Hall :
  forall pi (gT : finGroupType) (G H : {group gT}),
  [max H | pi.-subgroup(G) H] -> H <| G -> pi.-Hall(G) H.
Proof.
move=> pi gT G H; case/maxgroupP; case/andP=> sHG piH maxH nHG.
have [_ nnHG] := andP nHG; rewrite /pHall sHG piH; apply/pnatP=> // p pr_p.
rewrite inE /= -pnatE // -card_quotient //.
case/Cauchy=> //= Hx; rewrite -sub1set -gen_subG -/<[Hx]> /order.
case/inv_quotientS=> //= K -> sHK sKG {Hx}.
rewrite card_quotient ?(subset_trans sKG) // => iKH; apply/negP=> pi_p.
rewrite -iKH -divgS // (maxH K) ?divnn ?cardG_gt0 // in pr_p.
by rewrite /psubgroup sKG /pgroup -(LaGrange sHK) mulnC pnat_mul iKH pi_p.
Qed.

Section Morphim.

Variables (aT rT : finGroupType) (D : {group aT}) (f : {morphism D >-> rT}).
Implicit Type pi : nat_pred.
Implicit Types G H P : {group aT}.

Lemma morphim_pgroup : forall pi G, pi.-group G -> pi.-group (f @* G).
Proof. move=> pi G; apply: pnat_dvd; exact: dvdn_morphim. Qed.

Lemma pmorphim_pgroup : forall pi G,
   pi.-group ('ker f) -> G \subset D -> pi.-group (f @* G) = pi.-group G.
Proof.
move=> pi G piker sGD; apply/idP/idP=> [pifG|]; last exact: morphim_pgroup.
apply: (@pgroupS _ _ (f @*^-1 (f @* G))); first by rewrite -sub_morphim_pre.
by rewrite /pgroup card_morphpre ?morphimS // pnat_mul; exact/andP.
Qed.

Lemma morphim_p_index : forall pi G H,
  H \subset D -> pi.-nat #|G : H| -> pi.-nat #|f @* G : f @* H|.
Proof.
move=> pi G H dH; apply: pnat_dvd; apply: index_morphim.
by rewrite subIset // orbC dH.
Qed.

Lemma morphim_pHall : forall pi G H,
  H \subset D -> pi.-Hall(G) H -> pi.-Hall(f @* G) (f @* H).
Proof.
move=> pi G H dH; case/and3P=> sHG piH pi'GH.
by rewrite /pHall morphimS // morphim_pgroup // morphim_p_index.
Qed.

Lemma morphim_Hall : forall G H,
   H \subset D -> Hall G H -> Hall (f @* G) (f @* H).
Proof.
move=> G H dH; case/HallP=> pi piH; apply: (@pHall_Hall _ pi).
exact: morphim_pHall.
Qed.

Lemma morphim_pSylow : forall p G P,
  P \subset D -> p.-Sylow(G) P -> p.-Sylow(f @* G) (f @* P).
Proof. move=> p; exact: morphim_pHall. Qed.

Lemma morphim_p_group : forall P, p_group P -> p_group (f @* P).
Proof. move=> P; move/morphim_pgroup; exact: pgroup_p. Qed.

Lemma morphim_Sylow : forall G P,
  P \subset D -> Sylow G P -> Sylow (f @* G) (f @* P).
Proof.
move=> G P dP; case/andP=> pP hallP.
by rewrite /Sylow morphim_p_group // morphim_Hall.
Qed.

Lemma morph_p_elt : forall pi x, x \in D -> pi.-elt x -> pi.-elt (f x).
Proof. move=> pi x Dx; apply: pnat_dvd; exact: morph_order. Qed.

Lemma morph_constt : forall pi x, x \in D -> f x.`_pi = (f x).`_pi.
Proof.
move=> pi x Dx; rewrite -{2}(consttC pi x) morphM ?groupX //.
rewrite consttM; last by rewrite !morphX //; exact: commuteX2.
have: pi.-elt (f x.`_pi) by rewrite morph_p_elt ?groupX ?p_elt_constt //.
have: pi^'.-elt (f x.`_pi^') by rewrite morph_p_elt ?groupX ?p_elt_constt //.
by move/constt1P->; move/constt_p_elt->; rewrite mulg1.
Qed.

End Morphim.

Lemma pquotient_pgroup : forall pi (gT : finGroupType) (G H : {group gT}),
   pi.-group H -> G \subset 'N(H) -> pi.-group (G / H) = pi.-group G.
Proof.
move=> pi gT G H; rewrite -{1}(ker_coset H); exact: pmorphim_pgroup.
Qed.

Section Pfunctors.

(* A functor needs to quantify over the finGroupType just beore the set. *)

Variables (n p : nat) (pi : nat_pred) (gT : finGroupType) (A : {set gT}).

Definition pcore := \bigcap_(G | [max G | pi.-subgroup(A) G]) G.

Definition OhmPred (x : gT) := \max_(0 <= p < #[x].+1) logn p #[x] <= n.

Definition Ohm := <<[set x \in A | OhmPred x]>>.

Definition MhoFun (x : gT) := \prod_(0 <= p < #[x].+1) x.`_p ^+ (p ^ n).

Definition Mho := <<MhoFun @: A>>.

Canonical Structure pcore_group : {group gT} := Eval hnf in [group of pcore].
Canonical Structure Ohm_group : {group gT} := Eval hnf in [group of Ohm].
Canonical Structure Mho_group : {group gT} := Eval hnf in [group of Mho].

End Pfunctors.

Notation "''O_' pi ( G )" := (pcore pi G)
  (at level 8, pi at level 2, format "''O_' pi ( G )") : group_scope.
Notation "''O_' pi ( G )" := (pcore_group pi G) : subgroup_scope.

Notation "''Ohm_' n ( G )" := (Ohm n G)
  (at level 8, n at level 2, format "''Ohm_' n ( G )") : group_scope.
Notation "''Ohm_' n ( G )" := (Ohm_group n G) : subgroup_scope.

Notation "''Mho^' n ( G )" := (Mho n G)
  (at level 8, n at level 2, format "''Mho^' n ( G )") : group_scope.
Notation "''Mho^' n ( G )" := (Mho_group n G) : subgroup_scope.

Section PseriesDefs.

Variables (pis : seq nat_pred) (gT : finGroupType) (A : {set gT}).

Definition pcore_mod pi B := coset B @*^-1 'O_pi(A / B).
Canonical Structure pcore_mod_group pi B : {group gT} :=
  Eval hnf in [group of pcore_mod pi B].

Definition pseries := foldr pcore_mod 1 (rev pis).

Lemma pseries_group_set : group_set pseries.
Proof. rewrite /pseries; case: rev => [|pi1 pi1']; exact: groupP. Qed.

Canonical Structure pseries_group : {group gT} := group pseries_group_set.

End PseriesDefs.

Notation Local ConsPred := (@Cons nat_pred) (only parsing).
Notation "''O_{' p1 , .. , pn } ( A )" :=
  (pseries (ConsPred p1 .. (ConsPred pn [::]) ..) A)
  (at level 8, format "''O_{' p1 , .. , pn } ( A )") : group_scope.
Notation "''O_{' p1 , .. , pn } ( A )" :=
  (pseries_group (ConsPred p1 .. (ConsPred pn [::]) ..) A) : subgroup_scope.

Definition plength_1 (p : nat) (gT : finGroupType) (A : {set gT}) :=
  'O_{p^', p, p^'}(A) == A.

Notation "p .-length_1" := (@plength_1 p _)
  (at level 2, format "p .-length_1") : group_scope.

Section PCoreProps.

Variables (pi : nat_pred) (gT : finGroupType).
Implicit Type A : {set gT}.
Implicit Types G H M K : {group gT}.

Lemma pcore_psubgroup : forall G, pi.-subgroup(G) 'O_pi(G).
Proof.
move=> G; have [M maxM _]: {M | [max M | pi.-subgroup(G) M] & 1%G \subset M}.
  by apply: maxgroup_exists; rewrite /psubgroup sub1G pgroup1.
have sOM: 'O_pi(G) \subset M by exact: bigcap_inf.
case/andP: (maxgroupp maxM) => piM sMG.
by rewrite /psubgroup (pgroupS sOM) // (subset_trans sOM).
Qed.

Lemma pcore_pgroup : forall G, pi.-group 'O_pi(G).
Proof. by move=> G; case/andP: (pcore_psubgroup G). Qed.

Lemma pcore_sub : forall G, 'O_pi(G) \subset G.
Proof. by move=> G; case/andP: (pcore_psubgroup G). Qed.

Lemma pcore_sub_Hall : forall G H, pi.-Hall(G) H -> 'O_pi(G) \subset H.
Proof. move=> G H; move/Hall_max=> maxH; exact: bigcap_inf. Qed.

Lemma pcore_max : forall G H, pi.-group H -> H <| G -> H \subset 'O_pi(G).
Proof.
move=> G H piH nHG; apply/bigcapsP=> M maxM.
exact: normal_sub_max_pgroup piH nHG.
Qed.

Lemma pcore_normal : forall G, 'O_pi(G) <| G.
Proof.
move=> G; rewrite /(_ <| G) pcore_sub; apply/subsetP=> x Gx.
rewrite inE; apply/bigcapsP=> M maxM; rewrite sub_conjg.
by apply: bigcap_inf; apply: max_pgroupJ; rewrite ?groupV.
Qed.

Lemma normal_Hall_pcore : forall H G, pi.-Hall(G) H -> H <| G -> 'O_pi(G) = H.
Proof.
move=> H G hallH nHG; apply/eqP.
rewrite eqEsubset (subset_normal_Hall _ hallH) //= pcore_psubgroup.
by rewrite pcore_max //= (pHall_pgroup hallH).
Qed.

End PCoreProps.

Section MorphPcore.

Implicit Type pi : nat_pred.
Implicit Types gT rT : finGroupType.

Lemma morphim_pcore : forall pi gT rT (D G : {group gT})
                                      (f : {morphism D >-> rT}),
  f @* 'O_pi(G) \subset 'O_pi(f @* G).
Proof.
move=> pi gT rT D G f; apply/bigcapsP=> M; move/normal_sub_max_pgroup; apply.
  by rewrite morphim_pgroup ?pcore_pgroup.
apply: morphim_normal; exact: pcore_normal.
Qed.

Lemma pcoreS : forall pi gT (G H : {group gT}),
  H \subset G -> H :&: 'O_pi(G) \subset 'O_pi(H).
Proof.
move=> pi gT G H sHG; rewrite -{2}(setIidPl sHG).
do 2!rewrite -(morphim_idm (subsetIl H _)) morphimIdom; exact: morphim_pcore.
Qed.

Lemma pcore_resp : forall pi gT rT (D : {group gT}) (f : {morphism D >-> rT}),
  f @* 'O_pi(D) \subset 'O_pi(f @* D).
Proof. move=> pi gT rT D; exact: morphim_pcore. Qed.

Lemma pcore_hereditary : forall pi, hereditary (pcore pi).
Proof. by move=> pi gT H G; move/pcoreS; rewrite setIC. Qed.

Canonical Structure bgFunc_pcore pi :=
  [bgFunc by pcore_sub pi & pcore_resp pi].

Canonical Structure gFunc_pcore pi := GFunc (pcore_resp pi).

Canonical Structure hgFunc_pcore pi := HGFunc (pcore_hereditary pi).

Lemma pcore_char : forall pi gT (G : {group gT}), 'O_pi(G) \char G.
Proof. move=> pi; exact: bgFunc_char. Qed.

Section PcoreMod.

Variable F : hgFunc.

Lemma pcore_mod_sub : forall pi gT (G : {group gT}),
  pcore_mod G pi (F _ G) \subset G.
Proof.
move=> pi gT G; have nFD := bgFunc_norm F G.
rewrite sub_morphpre_im ?pcore_sub //=.
  by rewrite ker_coset_prim subIset // gen_subG bgFunc_clos.
by apply: subset_trans (pcore_sub _ _) _; apply: morphimS.
Qed.

Lemma quotient_pcore_mod : forall pi gT (G : {group gT}) (B : {set gT}),
  pcore_mod G pi B / B = 'O_pi(G / B).
Proof.
move=> pi gT A B; apply: morphpreK; apply: subset_trans (pcore_sub _ _) _.
by rewrite /= /quotient -morphimIdom  morphimS ?subsetIl.
Qed.

Lemma morphim_pcore_mod : forall pi gT rT (D G : {group gT}),
  forall f : {morphism D >-> rT},
  f @* pcore_mod G pi (F _ G) \subset pcore_mod (f @* G) pi (F _ (f @* G)).
Proof.
move=> pi gT rT D G f.
have sDF: D :&: G \subset 'dom (coset (F _ G)).
  by rewrite setIC subIset ?bgFunc_norm.
have sDFf: D :&: G \subset 'dom (coset (F _ (f @* G)) \o f).
  by rewrite -sub_morphim_pre ?subsetIl // morphimIdom bgFunc_norm.
pose K := 'ker (restrm sDFf (coset (F _ (f @* G)) \o f)).
have sFK: 'ker (restrm sDF (coset (F _ G))) \subset K.
  rewrite /K !ker_restrm ker_comp /= subsetI subsetIl /= -setIA.
  rewrite -sub_morphim_pre ?subsetIl //.
  by rewrite morphimIdom !ker_coset (setIidPr _) ?hgFunc_morphim ?bgFunc_clos.
have sOF := pcore_sub pi (G / F _ G); have sDD: D :&: G \subset D :&: G by [].
rewrite -sub_morphim_pre -?quotientE; last first.
  by apply: subset_trans (bgFunc_norm F _); rewrite morphimS ?pcore_mod_sub.
suffices im_fact: forall H : {group gT}, F _ G \subset H -> H \subset G ->
  factm sDD sFK @* (H / F _ G) = f @* H / F _ (f @* G).
- rewrite -2?im_fact ?pcore_mod_sub ?bgFunc_clos //;
    try by rewrite -{1}[F _ G]ker_coset morphpreS ?sub1G.
  by rewrite quotient_pcore_mod morphim_pcore.
move=> H sFH sHG; rewrite -(morphimIdom _ (H / _)) /= {2}morphim_restrm setIid.
rewrite -morphimIG ?ker_coset //.
rewrite -(morphim_restrm sDF) morphim_factm morphim_restrm.
by rewrite morphim_comp -quotientE -setIA morphimIdom (setIidPr _).
Qed.

Lemma pcore_mod_res : forall pi gT rT (D : {group gT}),
  forall f : {morphism D >-> rT},
  f @* pcore_mod D pi (F _ D) \subset pcore_mod (f @* D) pi (F _ (f @* D)).
Proof. move=> pi gT rT D; exact: morphim_pcore_mod. Qed.

Lemma pcore_mod1 : forall pi gT (G : {group gT}), pcore_mod G pi 1 = 'O_pi(G).
Proof.
rewrite /pcore_mod => pi gT G; have inj1 := coset1_injm gT.
rewrite -bgFunc_asresp ?norms1 //.
by rewrite -(morphim_invmE inj1) morphim_invm ?norms1.
Qed.

End PcoreMod.

Lemma pseries_rcons : forall pi pis gT (A : {set gT}),
  pseries (rcons pis pi) A = pcore_mod A pi (pseries pis A).
Proof. by move=> pi pis gT A; rewrite /pseries rev_rcons. Qed.

Lemma pseries_subfun : forall pis,
   [/\ forall gT (G : {group gT}), pseries pis G \subset G
    & forall gT rT (G D : {group gT}) (f : {morphism D >-> rT}),
      f @* (pseries pis G) \subset pseries pis (f @* G)].
Proof.
elim/last_ind=> [|pis pi [sFpi fFpi]].
  by split=> [gT G | gT rT D G f]; rewrite (sub1G, morphim1).
have [rF hF] := (resp_of_dresp fFpi, hereditary_of_dresp fFpi).
pose F := @HGFunc [gFunc by sFpi & rF] hF.
split=> [gT G | gT rT D G f]; rewrite !pseries_rcons ?(pcore_mod_sub F) //.
exact: (morphim_pcore_mod F).
Qed.

Lemma pseries_sub : forall pis gT (G : {group gT}), pseries pis G \subset G.
Proof. by move=> pis; case: (pseries_subfun pis). Qed.

Lemma morphim_pseries : forall pis gT rT (D G : {group gT}),
  forall f : {morphism D >-> rT},
  f @* (pseries pis G) \subset pseries pis (f @* G).
Proof. by move=> pis; case: (pseries_subfun pis). Qed.

Lemma pseries_resp : forall pis gT rT (G : {group gT}),
  forall f : {morphism G >-> rT},
  f @* (pseries pis G) \subset pseries pis (f @* G).
Proof. by move=> pis gT rT G; exact: morphim_pseries. Qed.

Lemma pseriesS : forall pis, hereditary (pseries pis).
Proof.
move=> pis gT H G sHG; rewrite -{2}(setIidPl sHG) {1}setIC.
do 2!rewrite -(morphim_idm (subsetIl H _)) morphimIdom; exact: morphim_pseries.
Qed.

Canonical Structure bgFunc_pseries pis :=
  [bgFunc by pseries_sub pis & pseries_resp pis].

Canonical Structure gFunc_pseries pis := GFunc (pseries_resp pis).

Canonical Structure hgFunc_pseries pis := HGFunc (pseriesS pis).

Lemma pseries_char : forall pis gT (G : {group gT}), pseries pis G \char G.
Proof. move=> pis; exact: bgFunc_char. Qed.

Lemma pseries_normal : forall pis gT (G : {group gT}), pseries pis G <| G.
Proof. move=> pis; exact: bgFunc_normal. Qed.

Lemma pseries1 : forall pi gT (G : {group gT}), 'O_{pi}(G) = 'O_pi(G).
Proof. exact: pcore_mod1. Qed.

Lemma pseries_pop : forall pi pis gT (G : {group gT}),
  'O_pi(G) = 1 -> pseries (pi :: pis) G = pseries pis G.
Proof.
move=> pi pis gT G OG1.
by rewrite /pseries rev_cons -cats1 foldr_cat /= pcore_mod1 OG1.
Qed.

Lemma pseries_pop2 : forall pi1 pi2 gT (G : {group gT}),
  'O_pi1(G) = 1 -> 'O_{pi1, pi2}(G) = 'O_pi2(G).
Proof. move=> pi1 pi2 gT G; move/pseries_pop->; exact: pseries1. Qed.

Lemma pseries_sub_catl : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s G \subset pseries (pi1s ++ pi2s) G.
Proof.
move=> pi1s pis gT G; elim/last_ind: pis => [|pi pis IHpi]; rewrite ?cats0 //.
rewrite -rcons_cat pseries_rcons; apply: subset_trans IHpi _.
by rewrite sub_cosetpre.
Qed.

Lemma quotient_pseries : forall pis pi gT (G : {group gT}),
  pseries (rcons pis pi) G / pseries pis G = 'O_pi(G / pseries pis G).
Proof. by move=> pis pi gT G; rewrite pseries_rcons quotient_pcore_mod. Qed.

Lemma pseries_norm2 : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \subset 'N(pseries pi1s G).
Proof.
move=> pi1s pi2s gt G.
apply: subset_trans (normal_norm (pseries_normal pi1s G)); exact: pseries_sub.
Qed.

Lemma pseries_sub_catr : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \subset pseries (pi1s ++ pi2s) G.
Proof.
elim=> //= pi1 pi1s IH pi2s gT G; apply: subset_trans (IH _ _ _) _ => {IH}.
elim/last_ind: {pi1s pi2s}(_ ++ _) => [|pis pi IHpi]; first exact: sub1G.
rewrite -rcons_cons (pseries_rcons _ (pi1 :: pis)).
rewrite -sub_morphim_pre ?pseries_norm2 //.
apply: pcore_max; last by rewrite morphim_normal ?pseries_normal.
have: pi.-group (pseries (rcons pis pi) G / pseries pis G).
  by rewrite quotient_pseries pcore_pgroup.
by apply: pnat_dvd; rewrite !card_quotient ?pseries_norm2 // indexgS.
Qed.

Lemma quotient_pseries2 : forall pi1 pi2 gT (G : {group gT}),
  'O_{pi1, pi2}(G) / 'O_pi1(G) = 'O_pi2(G / 'O_pi1(G)).
Proof. by move=> pi1 pi2 gT G; rewrite -pseries1 -quotient_pseries. Qed.

Lemma quotient_pseries_cat : forall pi1s pi2s gT (G : {group gT}),
  pseries (pi1s ++ pi2s) G / pseries pi1s G
    = pseries pi2s (G / pseries pi1s G).
Proof.
move=> pi1s pis gT G; elim/last_ind: pis => [|pis pi IHpi].
  by rewrite cats0 trivg_quotient.
have psN := pseries_normal _ G; set K := pseries _ G.
case: (third_isom (pseries_sub_catl pi1s pis G) (psN _)) => //= f inj_f im_f.
have nH2H: pseries pis (G / K) <| pseries (pi1s ++ rcons pis pi) G / K.
  rewrite -IHpi morphim_normal // -cats1 catA.
  by apply/andP; rewrite pseries_sub_catl pseries_norm2.
apply: (quotient_inj nH2H).
  by apply/andP; rewrite /= -cats1 pseries_sub_catl pseries_norm2. 
rewrite /= quotient_pseries /= -IHpi -rcons_cat.
rewrite -[G / _ / _](morphim_invm inj_f) //= {2}im_f //.
have:= @bgFunc_asresp (bgFunc_pcore pi).
move <-; rewrite /= ?injm_invm ?im_f // -quotient_pseries.
by rewrite -im_f ?morphim_invm ?morphimS ?normal_sub. 
Qed.

Lemma pseries_catl_id : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s (pseries (pi1s ++ pi2s) G) = pseries pi1s G.
Proof.
elim/last_ind=> [|pis pi IHpi] pi2s gT G; first by [].
apply: (@quotient_inj _ (pseries_group pis G)).
- rewrite /= -(IHpi (pi :: pi2s)) cat_rcons /(_ <| _) pseries_norm2.
  by rewrite -cats1 pseries_sub_catl.
- by rewrite /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
rewrite /= cat_rcons -(IHpi (pi :: pi2s)) {1}quotient_pseries IHpi.
apply/eqP; rewrite quotient_pseries eqEsubset !pcore_max ?pcore_pgroup //=.
  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.
  by rewrite -cat_rcons pseries_sub_catl.
apply: char_normal_trans (pcore_char pi _) (morphim_normal _ _).
exact: pseries_normal.
Qed.

Lemma pseries_char_catl : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s G \char pseries (pi1s ++ pi2s) G.
Proof.
by move=> pi1s pi2s gT G; rewrite -(pseries_catl_id pi1s pi2s G) pseries_char.
Qed.

Lemma pseries_catr_id : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s (pseries (pi1s ++ pi2s) G) = pseries pi2s G.
Proof.
move=> pi1s pis gT; elim/last_ind: pis => [|pis pi IHpi] G; first by [].
have Epis: pseries pis (pseries (pi1s ++ rcons pis pi) G) = pseries pis G.
  by rewrite -cats1 catA -2!IHpi pseries_catl_id.
apply: (@quotient_inj _ (pseries_group pis G)).
- by rewrite /= -Epis /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
- by rewrite /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
rewrite /= -Epis {1}quotient_pseries Epis quotient_pseries.
apply/eqP; rewrite eqEsubset !pcore_max ?pcore_pgroup //=.
  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.
  by rewrite pseries_sub_catr.
apply: char_normal_trans (pcore_char pi _) (morphim_normal _ _).
exact: pseries_normal.
Qed.

Lemma pseries_char_catr : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \char pseries (pi1s ++ pi2s) G.
Proof.
by move=> pi1s pi2s gT G; rewrite -(pseries_catr_id pi1s pi2s G) pseries_char.
Qed.

Lemma pcore_modp : forall pi gT (G H : {group gT}),
  H <| G -> pi.-group H -> pcore_mod G pi H = 'O_pi(G).
Proof.
move=> pi gT G H nHG piH; apply/eqP; rewrite eqEsubset andbC.
have nnHG := normal_norm nHG; have sOG := subset_trans (pcore_sub pi _).
rewrite -sub_morphim_pre ?(sOG, morphim_pcore) // pcore_max //.
  rewrite -(pquotient_pgroup piH) ?subsetIl //.
  by rewrite quotient_pcore_mod pcore_pgroup.
by rewrite -{2}(quotientGK nHG) morphpre_normal ?pcore_normal ?sOG ?morphimS.
Qed.

Lemma pquotient_pcore : forall pi gT (G H : {group gT}),
  H <| G -> pi.-group H -> 'O_pi(G / H) = 'O_pi(G) / H.
Proof. by move=> *; rewrite -quotient_pcore_mod pcore_modp. Qed.

Lemma trivg_pcore_quotient : forall pi gT (G : {group gT}),
  'O_pi(G / 'O_pi(G)) = 1.
Proof.
move=> pi gT G; rewrite pquotient_pcore ?pcore_normal ?pcore_pgroup //.
exact: trivg_quotient.
Qed.

End MorphPcore.

Section SubPcore.

Variable gT : finGroupType.
Implicit Types pi : nat_pred.
Implicit Type G : {group gT}.

Lemma sub_pcore : forall pi1 pi2 G,
  {subset pi1 <= pi2} -> 'O_pi1(G) \subset 'O_pi2(G).
Proof.
move=> pi1 pi2 G sub_pi; rewrite pcore_max ?pcore_normal //.
apply: sub_in_pnat (pcore_pgroup _ _) => p _; exact: sub_pi.
Qed.

Lemma eq_pcore : forall pi1 pi2 G, pi1 =i pi2 -> 'O_pi1(G) = 'O_pi2(G).
Proof.
move=> pi1 pi2 G eq_pi; apply/eqP; rewrite eqEsubset.
by rewrite !sub_pcore // => p; rewrite eq_pi.
Qed.

Lemma pcoreI : forall pi1 pi2 G, 'O_[predI pi1 & pi2](G) = 'O_pi1('O_pi2(G)).
Proof.
move=> pi1 pi2 G; apply/eqP; rewrite eqEsubset !pcore_max //.
- rewrite /pgroup pnatI [pnat _ _]pcore_pgroup.
  exact: pgroupS (pcore_sub _ _) (pcore_pgroup _ _).
- exact: char_normal_trans (pcore_char _ _) (pcore_normal _ _).
- by apply: sub_in_pnat (pcore_pgroup _ _) => p _; case/andP.
apply/andP; split; first by apply: sub_pcore => p; case/andP.
apply: subset_trans (pcore_sub _ _) (normal_norm _); exact: pcore_normal.
Qed.

End SubPcore.

Section Plength1.

(* This is B&G Lemma 1.21 *)

Variables (p : nat) (gT : finGroupType).
Implicit Types G H : {group gT}.

Lemma plenght1S : forall G H, H \subset G -> p.-length_1 G -> p.-length_1 H.
Proof.
rewrite /plength_1 => G H sHG pG1; rewrite eqEsubset pseries_sub.
by apply: subset_trans (pseriesS _ sHG); rewrite (eqP pG1) (setIidPr _).
Qed.

Lemma plength1_quo : forall G H, p.-length_1 G -> p.-length_1 (G / H).
Proof.
rewrite /plength_1 => G H pG1; rewrite eqEsubset pseries_sub.
by rewrite -{1}(eqP pG1) morphim_pseries.
Qed.

Lemma p'quo_plength1 : forall G H,
  H <| G -> p^'.-group H -> p.-length_1 (G / H) = p.-length_1 G.
Proof.
rewrite /plength_1 => G H nHG p'H; apply/idP/idP; last exact: plength1_quo.
move=> pGH1; rewrite eqEsubset pseries_sub.
have nOG: 'O_{p^'}(G) <| G by exact: pseries_normal.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _]) //.
have [|f f_inj im_f] := third_isom _ nHG nOG.
  by rewrite /= pseries1 pcore_max.
rewrite (quotient_pseries_cat [:: _]) -{}im_f //=.
rewrite -bgFunc_asresp; try by move: pseries_resp pseries_sub.
rewrite {f f_inj}morphimS // pseries1 -pquotient_pcore // -pseries1 /=.
by rewrite -quotient_pseries_cat /= (eqP pGH1).
Qed.

Lemma pquo_plength1 : forall G H,
    H <| G -> p.-group H -> 'O_p^'(G / H) = 1->
  p.-length_1 (G / H) = p.-length_1 G.
Proof.
rewrite /plength_1 => G H nHG pH trO; apply/idP/idP; last exact: plength1_quo.
rewrite (pseries_pop _ trO) => pGH1; rewrite eqEsubset pseries_sub /=.
rewrite pseries_pop //; last first.
  apply/eqP; rewrite -subG1; have <-: H :&: 'O_p^'(G) = 1.
    by apply: coprime_TIg; exact: pnat_coprime (pcore_pgroup _ _).
  rewrite setIC subsetI subxx -quotient_sub1.
    by rewrite -trO morphim_pcore.
  apply: subset_trans (normal_norm nHG); exact: pcore_sub.
have nOG: 'O_{p}(G) <| G by exact: pseries_normal.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _]) //.
have [|f f_inj im_f] := third_isom _ nHG nOG.
  by rewrite /= pseries1 pcore_max.
rewrite (quotient_pseries [::_]) -{}im_f //=.
rewrite -bgFunc_asresp; try by move: pcore_resp pcore_sub.
rewrite {f f_inj}morphimS // pseries1 -pquotient_pcore // -(pseries1 p) /=.
by rewrite -quotient_pseries /= (eqP pGH1).
Qed.

Definition p_elt_gen (A : {set gT}) := <<[set x \in A | p.-elt x]>>.
Canonical Structure p_elt_gen_group A : {group gT} :=
  Eval hnf in [group of p_elt_gen A].

(* If need be, we could easily make p_elt_gen into a functor. *)
Lemma p_elt_gen_normal : forall G, p_elt_gen G <| G.
Proof.
move=> G; apply/normalP; split=> [|x Gx].
  by rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP.
rewrite -genJ; congr <<_>>; apply/setP=> y; rewrite mem_conjg !inE.
by rewrite p_eltJ -mem_conjg conjGid.
Qed.

Hypothesis pr_p : prime p.

Lemma p_elt_gen_length1 : forall G,
  p.-length_1 G = p^'.-Hall(p_elt_gen G) 'O_p^'(p_elt_gen G).
Proof.
move=> G; rewrite /pHall pcore_sub pcore_pgroup pnatNK /= /plength_1.
have nUG := p_elt_gen_normal G; have [sUG nnUG]:= andP nUG.
apply/idP/idP=> [p1G | pU].
  apply: (@pnat_dvd _ #|p_elt_gen G : 'O_p^'(G)|).
    by rewrite -[#|_ : 'O_p^'(G)|]indexgI indexgS ?pcoreS.
  apply: (@pnat_dvd _ #|'O_p(G / 'O_{p^'}(G))|); last exact: pcore_pgroup.
  rewrite -card_quotient; last first.
    by rewrite (subset_trans sUG) // normal_norm ?pcore_normal.
  rewrite -quotient_pseries pseries1 cardSg ?morphimS //=.
  rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP=> Gx p_x.
  have nOx: x \in 'N('O_{p^',p}(G)).
    by apply: subsetP Gx; rewrite normal_norm ?pseries_normal.
  rewrite coset_idr //; apply/eqP; rewrite -[coset _ x]expg1 -order_dvdn.
  rewrite [#[_]](@pnat_1 p) //; first exact: morph_p_elt.
  apply: mem_p_elt (pcore_pgroup _ (G / _)) _.
  by rewrite /= -quotient_pseries /= (eqP p1G); apply/morphimP; exists x.
have nOG: 'O_{p^', p}(G) <| G by exact: pseries_normal.
rewrite eqEsubset pseries_sub.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _; _]) //=.
rewrite (quotient_pseries [::_;_]) pcore_max //.
rewrite /pgroup card_quotient ?normal_norm //.
apply: (@pnat_dvd _ #|G : p_elt_gen G|); last first.
  rewrite -card_quotient // p'natE //; apply/negP; case/Cauchy=> // Ux.
  case/morphimP=> x Nx Gx -> /= oUx_p; have:= prime_gt1 pr_p.
  rewrite -(part_pnat (pnat_id pr_p)) -{1}oUx_p {oUx_p} -order_constt.
  rewrite -morph_constt //= coset_id ?order1 //.
  by rewrite mem_gen // inE groupX // p_elt_constt.
apply: indexgS.
have nOU: p_elt_gen G \subset 'N('O_{p^'}(G)).
  by rewrite (subset_trans sUG) // normal_norm ?pseries_normal.
rewrite -(quotientSGK nOU) ?(pseries_sub_catl [:: _]) //=.
rewrite (quotient_pseries [::_]) pcore_max ?morphim_normal //.
rewrite /pgroup card_quotient //= pseries1; apply: pnat_dvd pU.
apply: indexgS; rewrite pcore_max ?pcore_pgroup //.
apply: char_normal_trans nUG; exact: pcore_char.
Qed.

End Plength1.

Lemma quo2_plength1 : forall p (gT : finGroupType) (G H K : {group gT}),
  prime p -> H <| G -> K <| G -> H :&: K = 1 ->
     p.-length_1 (G / H) && p.-length_1 (G / K) = p.-length_1 G.
Proof.
move=> p gT G H K pr_p nHG nKG trHK.
apply/andP/idP=> [[pH1 pK1] | pG1]; last by rewrite !plength1_quo.
pose U := p_elt_gen p G; have nU : U <| G by exact: p_elt_gen_normal.
have exB: forall N : {group gT},
   N <| G -> p.-length_1 (G / N) ->
     exists B : {group gT},
       [/\ U \subset 'N(B),
           forall x, x \in B -> #[x] = p -> x \in N
         & forall Q : {group gT}, p^'.-subgroup(U) Q -> Q \subset B].
- move=> N nNG; have [sNG nnNG] := andP nNG.
  rewrite p_elt_gen_length1 // (_ : p_elt_gen _ _ = U / N); last first.
    rewrite /quotient morphim_gen -?quotientE //; last first.
      by apply/subsetP=> x; rewrite inE; case/andP; move/(subsetP nnNG).
    congr <<_>>; apply/setP=> Nx; rewrite inE.
    apply/andP/morphimP=> [[]|[x NNx]].
      case/morphimP=> x NNx Gx ->{Nx} pNx.
      exists x.`_p; first exact: groupX.
        by rewrite inE p_elt_constt groupX.
      by rewrite morph_constt // constt_p_elt.
    rewrite inE; case/andP=> Gx p_x ->{Nx}.
    by rewrite morph_p_elt // -sub1set -morphim_set1 // morphimS ?sub1set.
  have nNU: U \subset 'N(N) := subset_trans (normal_sub nU) nnNG.
  have nN_UN: U <*> N \subset 'N(N) by rewrite gen_subG subUset normG nNU.
  case/(inv_quotientN _): (pcore_normal p^' [group of U <*> N / N]) => /= [|B].
    by rewrite /normal sub_gen ?subsetUr.
  rewrite /= quotient_mulgen //= /U => defB sNB; case/andP=> sB nB hallB.
  exists B; split=> [|x Ux p_x|Q].
  - by rewrite (subset_trans (sub_gen _) nB) ?subsetUl.
  - have nNx: x \in 'N(N) by rewrite (subsetP nN_UN) ?(subsetP sB).
    apply: coset_idr => //; rewrite -[coset N x](consttC p).
    rewrite !(constt1P _) ?mulg1 // ?p_eltNK.
      by rewrite morph_p_elt // /p_elt p_x pnat_id.
    have: coset N x \in B / N by apply/morphimP; exists x.
    by apply: mem_p_elt; rewrite /= -defB pcore_pgroup.
  case/andP=> sQU p'Q; rewrite -(quotientSGK (subset_trans sQU nNU) sNB).
  rewrite -defB (subset_normal_Hall _ hallB) ?pcore_normal //=.
  by rewrite /psubgroup morphimS ?morphim_pgroup.
have{pH1} [A [nAU pA p'A]] := exB H nHG pH1.
have{pK1 exB} [B [nBU pB p'B]] := exB K nKG pK1.
rewrite p_elt_gen_length1 //; apply: normal_max_pgroup_Hall (pcore_normal _ _).
apply/maxgroupP; split; first by rewrite /psubgroup pcore_sub pcore_pgroup.
move=> Q p'Q sOQ; apply/eqP; rewrite eqEsubset sOQ andbT.
apply: subset_trans (_ : U :&: (A :&: B) \subset _); last rewrite /U.
  by rewrite !subsetI p'A ?p'B //; case/andP: p'Q => ->.
apply: pcore_max; last by rewrite /normal subsetIl !normsI ?normG.
rewrite /pgroup p'natE //; apply/negP; case/Cauchy=> // x.
case/setIP=> _; case/setIP=> Ax Bx oxp.
suff: x \in 1%G by move/set1P=> x1; rewrite -oxp x1 order1 in pr_p.
by rewrite /= -trHK inE pA ?pB.
Qed.

Section OhmProps.

Section generic.

Variables (n : nat) (gT : finGroupType).
Implicit Type rT : finGroupType.
Implicit Type D G H : {group gT}.

Lemma Ohm_sub : forall G, 'Ohm_n(G) \subset G.
Proof.
by move=> G; rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP.
Qed.

Lemma Ohm_resp : forall rT G (f : {morphism G >-> rT}),
  f @* 'Ohm_n(G) \subset 'Ohm_n(f @* G).
Proof.
move=> rT G f; rewrite morphim_gen ?genS //; last by rewrite -gen_subG Ohm_sub.
apply/subsetP=> fx; case/morphimP=> x Gx; rewrite inE Gx => x_n -> {fx}.
rewrite inE morphimEdom mem_imset //=; apply: leq_trans x_n.
have fx_x: #[f x] %| #[x] by exact: morph_order.
rewrite (big_nat_widen _ _ #[x].+1) /=; last by rewrite ltnS dvdn_leq.
rewrite big_mkcond /=; apply (big_rel (fun m n => m <= n)) => // [|p _].
  by move=> m1 m2 n1 n2; rewrite leq_maxl !leq_maxr andbC orbC => -> ->.
case: ifP => // _; exact: dvdn_leq_log.
Qed.

Lemma OhmS : forall G H, H \subset G -> 'Ohm_n(H) \subset 'Ohm_n(G).
Proof.
move=> G H sHG; apply: genS; apply/subsetP=> x; rewrite !inE.
by case/andP=> Hx ->; rewrite (subsetP sHG).
Qed.

Lemma OhmE : forall (p : nat) G,
  p.-group G -> 'Ohm_n(G) = <<[set x \in G | x ^+ (p ^ n) == 1]>>.
Proof.
move=> p G pG; congr <<_>>; apply/setP=> x; rewrite !inE.
case Gx: (x \in G) => //=; rewrite -order_dvdn /OhmPred /order.
have: p.-elt x by exact: mem_p_elt pG Gx.
case/pgroup_1Vpr=> [/= -> | [pr_p]].
  by rewrite cards1 dvd1n unlock /= !logn1.
rewrite -/#[x] -ltnS => le_p_x [m defm]; rewrite {2 3}defm {defm}.
rewrite pfactor_dvdn ?expn_gt0 ?prime_gt0 // pfactorK //; congr (_ <= n).
apply/eqP; rewrite big_mkord eqn_leq andbC.
rewrite (leq_trans _ (leq_bigmax (Ordinal le_p_x))) ?pfactorK //=.
apply big_prop => // [n1 n2|q _]; first by rewrite leq_maxl => -> ->.
by rewrite logn_exp logn_prime // -{2}[m.+1]muln1 leq_pmul2l ?leq_b1.
Qed.

Lemma Ohm_compatible : forall i, compatible (Ohm i).
Proof.
move=> i hT H G Hsub; apply:genS; apply/subsetP=> x.
by rewrite !inE; move/andP => [Hx ->]; rewrite (subsetP Hsub _ Hx).
Qed.

Lemma Mho_sub : forall G, 'Mho^n(G) \subset G.
Proof.
move=> G; rewrite gen_subG; apply/subsetP=> fx; case/imsetP=> x Gx ->{fx}.
by rewrite /MhoFun; apply big_prop => // *; rewrite ?groupM ?groupX.
Qed.

Lemma morphim_Mho : forall rT D G (f : {morphism D >-> rT}),
  G \subset D -> f @* 'Mho^n(G) = 'Mho^n(f @* G).
Proof.
move=> rT D G f sGD; have sMho: @MhoFun n gT @: G \subset D.
  by rewrite -gen_subG (subset_trans (Mho_sub G)).
rewrite morphim_gen //; congr <<_>>; rewrite !morphimEsub // -!imset_comp.
symmetry; apply: eq_in_imset => x Gx /=; have Dx := subsetP sGD x Gx.
have fx_x: #[f x] %| #[x] by exact: morph_order.
rewrite /MhoFun (big_nat_widen _ _ #[x].+1) /=; last by rewrite ltnS dvdn_leq.
elim: (index_iota _ _) => [|p r IHr]; first by rewrite !big_nil morph1.
rewrite !big_cons {}IHr morphM ?groupX //; last first.
  by apply big_prop => // *; rewrite ?groupM ?groupX.
rewrite morphX ?groupX // morph_constt // ltnS -if_neg; case: ifP => // p_fx.
rewrite (constt1P _) ?exp1gn ?mul1g // /p_elt; apply/pnatP=> // q _ qfx.
apply: contra p_fx; move/eqnP <-; exact: dvdn_leq.
Qed.

Lemma Mho_resp : forall rT G (f : {morphism G >-> rT}),
  f @* 'Mho^n(G) \subset 'Mho^n(f @* G).
Proof. by move=> rT G f; rewrite morphim_Mho. Qed.

Lemma MhoS : forall G H, H \subset G -> 'Mho^n(H) \subset 'Mho^n(G).
Proof. move=> G H sHG; apply: genS; exact: imsetS. Qed.

Lemma MhoE : forall (p : nat) G,
  p.-group G -> 'Mho^n(G) = <<(fun x => x ^+ (p ^ n)) @: G>>.
Proof.
move=> p G pG; congr <<_>>; apply: eq_in_imset => x Gx.
have p_x: p.-elt x by exact: mem_p_elt pG Gx.
case: (pgroup_1Vpr p_x) => [/= x1 | [pr_p]].
  have ->: x = 1 by apply/set1gP; rewrite -x1 cycle_id.
  rewrite exp1gn; apply/set1P; apply: (subsetP (Mho_sub 1)).
  by rewrite mem_gen // mem_imset.
rewrite -/#[x] /MhoFun -ltnS => le_p_x _.
rewrite (big_cat_nat _ _ _ _ (ltnW le_p_x)) //= (big_ltn le_p_x).
have xq1: forall q, (q > p) || (q < p) -> x.`_q ^+ (q ^ n) = 1.
  move=> q; rewrite -neq_ltn => nqp; rewrite (constt1P _) ?exp1gn //.
  by apply: sub_in_pnat p_x => r _; move/eqnP->.
rewrite constt_p_elt // !big1_seq ?(mulg1, mul1g) // => q /=.
  by rewrite mem_index_iota; case/andP=> ltpq; rewrite xq1 // ltpq.
by rewrite mem_index_iota andTb => ltqp; rewrite xq1 // ltqp orbT.
Qed.

End generic.

Canonical Structure bgFunc_Ohm i := [bgFunc by Ohm_sub i & Ohm_resp i].
Canonical Structure gFunc_Ohm i := GFunc (Ohm_resp i).
Canonical Structure cgFunc_Ohm i := CGFunc (Ohm_compatible i).

Lemma Mho_compatible : forall i, compatible (Mho i).
Proof. move=> i hT H G sHG; exact: MhoS. Qed.

Canonical Structure bgFunc_Mho i := [bgFunc by Mho_sub i & Mho_resp i].
Canonical Structure gFunc_Mho i := GFunc (Mho_resp i).
Canonical Structure cgFunc_Mho i := CGFunc (Mho_compatible i).

Section char.

Variables (n : nat) (gT rT : finGroupType) (D G : {group gT}).

Lemma Ohm_char : 'Ohm_n(G) \char G.
Proof. exact: bgFunc_char. Qed.

Lemma Mho_char : 'Mho^n(G) \char G.
Proof. exact: bgFunc_char. Qed.

Lemma morphim_Ohm : forall f : {morphism D >-> rT},
  G \subset D -> f @* 'Ohm_n(G) \subset 'Ohm_n(f @* G).
Proof.  exact: morphim_sFunctor. Qed.

End char.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Type D G H E : {group gT}.
Implicit Type pi : nat_pred.

Lemma dvdn_exponent : forall x G, x \in G -> #[x] %| exponent G.
Proof. by move=> x G Gx; rewrite /exponent (bigD1 x) //= dvdn_lcml. Qed.


Lemma exponentP : forall G n,
  reflect (forall x, x \in G -> x ^+ n = 1) (exponent G %| n).
Proof.
rewrite /exponent => G n; apply: (iffP idP) => [eGn x Gx | eGn].
  apply/eqP; rewrite -order_dvdn; apply: dvdn_trans eGn; exact: dvdn_exponent.
apply big_prop=> [|p q pn qn|x Gx]; [exact: dvd1n | by rewrite dvdn_lcm pn | ].
by rewrite order_dvdn eGn.
Qed.

Lemma trivg_exponent : forall G, (G :==: 1) = (exponent G %| 1).
Proof.
move=> G; rewrite -subG1.
by apply/subsetP/exponentP=> trG x; move/trG; rewrite expg1; move/set1P.
Qed.

Lemma exponent1 : exponent [1 gT] = 1%N.
Proof. by apply/eqP; rewrite -dvdn1 -trivg_exponent eqxx. Qed.

Lemma exponent_dvdn : forall G, exponent G %| #|G|.
Proof.
by move=> G; apply/exponentP=> s Gx; apply/eqP; rewrite -order_dvdn order_dvdG.
Qed.

Lemma exponent_gt0 : forall G, 0 < exponent G.
Proof. move=> G; exact: dvdn_gt0 (exponent_dvdn G). Qed.
Hint Resolve exponent_gt0.

Lemma pnat_exponent : forall pi G, pi.-nat (exponent G) = pi.-group G.
Proof.
move=> pi G; congr (_ && _); first by rewrite cardG_gt0 exponent_gt0.
apply: eq_all_r=> p; rewrite !mem_primes cardG_gt0 exponent_gt0 /=.
case pr_p: (prime p) => //=; apply/idP/idP=> pG.
  exact: dvdn_trans pG (exponent_dvdn G).
case/Cauchy: pG => // x Gx <-; exact: dvdn_exponent.
Qed.

Lemma abelem1: abelem [1 gT]. 
Proof. by rewrite /abelem abelian1 pgroup1. Qed.

Lemma p_abelem1: forall p: nat, p.-abelem (1 : {set gT}).
Proof. by move=> p; rewrite /p_abelem abelem1 pgroup1. Qed.

Lemma abelemP : forall E,
  reflect (exists2 p, prime p & p.-abelem E) (abelem E).
Proof.
rewrite /p_abelem => E; apply: (iffP idP) => [abE | [p _]]; last by case/andP.
case: (andP abE) => _; move/pgroup_p; case/p_groupP => p pr_p pE.
by rewrite abE; exists p.
Qed.

Lemma p_abelemE : forall p E,
  prime p -> p.-abelem E = abelian E && (exponent E %| p).
Proof.
move=> p E pr_p; rewrite /p_abelem -andbA; congr (_ && _).
have e_E := exponent_dvdn E; apply/andP/idP => [[eE pE] | pE].
  case/p_natP: (pnat_dvd e_E pE) => // [[|k]] def_e; first by rewrite def_e.
  suff: (exponent E).-nat p by rewrite pnatE //; move/eqnP->.
  by apply: pnat_dvd eE; apply: dvdn_trans e_E; rewrite def_e expnS dvdn_mulr.
have pgE: p.-group E by rewrite -pnat_exponent; exact: pnat_dvd (pnat_id _).
split=> //; case/primeP: pr_p => _ pr_p; move/pr_p: pE.
rewrite orbC; case/predU1P=> [-> // |].
by rewrite -dvdn1 -trivg_exponent; move/eqP->; exact: pgroup1.
Qed.

Lemma p_abelemP : forall p E, prime p ->
  reflect (abelian E /\ forall x, x \in E -> x ^+ p = 1) (p.-abelem E).
Proof.
move=> p E pr_p; rewrite p_abelemE //.
by apply: (iffP andP) => [] [->]; move/exponentP.
Qed.

Lemma abelem_pgroup : forall p E, p.-abelem E -> p.-group E.
Proof. by move=> p E; case/andP. Qed.

Lemma abelem_Ohm1P : forall E,
  abelian E -> p_group E -> reflect ('Ohm_1(E) = E) (abelem E).
Proof.
move=> E abelE pgE; apply: (iffP (abelemP E)) => [[p pr_p pAE] {pgE}|].
  have pE: p.-group E by case/andP: pAE.
  apply/eqP; rewrite eqEsubset Ohm_sub (OhmE 1 pE) sub_gen //.
  apply/subsetP=> x Ex; rewrite inE Ex expn1 /=.
  by case/p_abelemP: pAE => // _ ->.
case/p_groupP: pgE => p pr_p pE; rewrite (OhmE 1 pE).
rewrite gen_set_id => [defE |]; last first.
  apply/group_setP; split=> [|x y]; rewrite !inE ?(exp1gn, group1) //=.
  case/andP=> Ex; move/eqP=> xp; case/andP=> Ey; move/eqP=> yp.
  rewrite groupM // expMgn ?(xp, yp, mulg1) //=; exact: (centsP abelE).
exists p => //; apply/p_abelemP=> //; split=> // x.
by rewrite -defE inE expn1; case/andP=> _; move/eqP.
Qed.

Lemma abelemS: forall E H,  E \subset H -> abelem H -> abelem E.
Proof.
move=> E H sEH; case/abelemP => p Pp; case/(p_abelemP _ Pp) => AH PH.
apply/abelemP; exists p => //; apply/(p_abelemP _ Pp); split => [|r Er] //.
  by apply: asub sEH.
by apply: PH; apply: (subsetP sEH).
Qed.
 
Lemma p_abelemS : forall p E H, E \subset H -> p.-abelem H -> p.-abelem E.
Proof.
move=> p E H sEH; case/andP=> abH pH.
by rewrite /p_abelem (abelemS sEH) ?(pgroupS sEH).
Qed.

Lemma Ohm_abelian: forall E, p_group E -> abelian E -> abelem ('Ohm_1(E)).
Proof.
move=> E; case/p_groupP => p Pp PgE AE.
rewrite (OhmE 1 PgE); apply/abelemP; exists p => //.
apply/(p_abelemP _ Pp); split.
  apply: (asub AE); rewrite gen_subG.
  by apply/subsetP => x; rewrite in_set; case/andP.
move=> x.
have GE: group_set [set x0 \in E | x0 ^+ (p ^ 1) == 1%g].
  rewrite /group_set in_set group1 exp1gn eqxx.
  apply/subsetP => y; case/mulsgP => x1 y1; rewrite !in_set.
  case/andP => Ix1P x1P1; case/andP => Iy1P y1P1 ->; rewrite groupM //.
  rewrite expMgn // ?(eqP x1P1, eqP y1P1, mul1g, eqxx) //.
  by move: AE; move/centsP; move/(_ _ Ix1P y1 Iy1P).
by move: (gen_set_id GE) => /= ->; rewrite in_set expn1; case/andP => _; move/eqP.
Qed.

Lemma TI_Ohm1 : forall E H, H :&: 'Ohm_1(E) = 1 -> H :&: E = 1.
Proof.
move=> E H trHE; case: (trivgVpdiv (H :&: E)) => // [[p pr_p]].
case/Cauchy=> // x; case/setIP=> Hx Ex ox.
suffices x1: x \in [1] by rewrite -ox (set1P x1) order1 in pr_p.
rewrite -{}trHE inE Hx mem_gen // inE Ex /= /OhmPred.
apply big_prop=> // [q1 q2|q _]; first by rewrite leq_maxl => ->.
by rewrite ox logn_prime ?leq_b1. 
Qed.

Lemma pnElemE : forall p n G,
  prime p -> 'E_p^n(G) = [set E \in 'E_p(G) | #|E| == (p ^ n)%N].
Proof.
move=> p n G pr_p; apply/setP=> E; rewrite 3!inE -2!andbA; congr (_ && _).
case pE: (p.-abelem E) => //=; case/andP: pE => _; case/p_natP=> // k ->.
by move/pfactorK: pr_p => pK; rewrite pK (can_eq pK).
Qed.

Lemma Elem1P : forall G E,
  reflect (E \subset G /\ exists2 p, prime p & #|E| = p) (E \in 'E^1(G)).
Proof.
move=> G E; rewrite ['E^1(G)]big_mkord.
apply: (iffP bigcupP) => [[[/= p _] _ pE]|[sEG [p pr_p pE]]].
  have pr_p: prime p by move: pE; rewrite 2!inE andbC lognE; case prime.
  move: pE; rewrite pnElemE // 2!inE expn1 -andbA; case/and3P=> sEG _.
  by move/eqP; split; last exists p.
have lt_p_G1: p < #|G|.+1 by rewrite ltnS dvdn_leq // -pE cardSg.
exists (Ordinal lt_p_G1); rewrite //= pnElemE // 2!inE sEG /= expn1 pE eqxx.
rewrite p_abelemE // -pE exponent_dvdn !andbT.
by rewrite cyclic_abelian ?prime_cyclic ?pE.
Qed.

End OhmProps.

