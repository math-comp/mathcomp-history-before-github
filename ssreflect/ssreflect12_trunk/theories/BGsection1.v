(* (c) Copyright Microsoft Corporation and Inria. All rights reserved. *)
Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype paths finfun bigops prime binomial finset ssralg.
Require Import groups finalg morphisms normal perm automorphism action gfunc.
Require Import commutators center cyclic gprod pgroups finmod nilpotent.
Require Import abelian maximal sylow hall matrix mxrepresentation.

(******************************************************************************)
(* This file contains most of the material in B & G, section 1, including the *)
(* definitions:                                                               *)
(*   stable_factor A H G == H <| G and A centralises G / H                    *)
(*             A.-stable == the stable_factor relation, in the scope of the   *)
(*                          r.-series notation.                               *)
(*            G.-central == the central_factor relation, in the scope of the  *)
(*                          r.-series notation.                               *)
(*              G.-chief == the chief_factor relation, in the scope of the    *)
(*                          r.-series notation.                               *)
(*         p.-length_1 G == the upper p-series of G has length <= 1, i.e.,    *)
(*                          'O_{p^',p,p^'}(G) = G                             *)
(*         p_elt_gen p G == the subgroup of G generated by its p-elements.    *)
(* This file currently covers B & G 1.3-4, 1.6, 1.8-1.21, and also            *)
(* Gorenstein 8.1.3 and 2.8.1 (maximal order of a p-subgroup of GL(2,p)).     *)
(*   This file also provides, mostly for future reference, the following      *)
(* definitions, drawn from Gorenstein, Chapter 8, and B & G, Appendix B:      *)
(*     p.-constrained G <-> the p',p core of G contains the centralisers of   *)
(*                          all its Sylow p-subgroups. The Hall-Higman Lemma  *)
(*                          1.2.3 (B & G, 1.15a) asserts that this holds for  *)
(*                          all solvable groups.                              *)
(*          p.-stable G <-> a rather group theoretic generalization of the    *)
(*                          Hall-Higman type condition that in a faithful     *)
(*                          p-modular linear representation of G no p-element *)
(*                          has a quadratic minimal polynomial, to groups G   *)
(*                          with a non-trivial p-core.                        *)
(* p.-abelian_constrained <-> the p',p core of G contains all the normal      *)
(*                          abelian subgroups of the Sylow p-subgroups of G.  *)
(*                          It is via this property and the ZL theorem (the   *)
(*                          substitute for the ZJ theorem) that the           *)
(*                          p-stability of groups of odd order is exploited   *)
(*                          in the proof of the Odd Order Theorem.            *)
(*      generated_by p G == G is generated by a set of subgroups satisfying   *)
(*                          p : pred {group gT}                               *)
(*      norm_abelian X A == A is abelian and normalised by X.                 *)
(*  p_norm_abelian p X A == A is an abelian p-group normalised by X.          *)
(*             'L_[G](X) == the group generated by the abelian subgroups of G *)
(*                          normalized by X.                                  *)
(*             'L_{n}(G) == the Puig group series, defined by the recurrence  *)
(*                          'L_{0}(G) = 1, 'L_{n.+1}(G) = 'L_[G]('L_{n}(G)).  *)
(*               'L_*(G) == the lower limits of the Puig series.              *)
(*                 'L(G) == the Puig subgroup: the upper limit of the Puig    *)
(*                          series ('L(G) = 'L_[G]('L_*(G)) and conversely).  *)
(*  The following notation is used locally here and in AppendixB, but is NOT  *)
(* exported:                                                                  *)
(*               D --> G == G is generated by abelian groups normalised by D  *)
(*                       := generated_by (norm_abelian D) G                   *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GroupScope.

Section Definitions.

Variables (n : nat) (gT : finGroupType).
Implicit Type p : nat.

Definition stable_factor (A V U : {set gT}) :=
  ([~: U, A] \subset V) && (V <| U). (* this orders allows and3P to be used *)

Definition central_factor (G V U : {set gT}) :=
  [&& [~: U, G] \subset V, V \subset U & U \subset G].

Definition chief_factor (G V U : {set gT}) := maxnormal V U G && (U <| G).

Definition plength_1 p (G : {set gT}) := 'O_{p^', p, p^'}(G) == G.

Definition p_elt_gen p (G : {set gT}) := <<[set x \in G | p.-elt x]>>.

Definition p_constrained p (G : {set gT}) :=
  forall P : {group gT},
    p.-Sylow('O_{p^',p}(G)) P ->
  'C_G(P) \subset 'O_{p^',p}(G).

Definition p_abelian_constrained p (G : {set gT}) :=
  forall S A : {group gT},
    p.-Sylow(G) S -> abelian A -> A <| S ->
  A \subset 'O_{p^',p}(G).

Definition p_stable p (G : {set gT}) :=
  forall P A : {group gT},
     p.-group P -> 'O_p^'(G) * P <| G ->
     p.-subgroup('N_G(P)) A -> [~: P, A, A] = 1 ->
  A / 'C_G(P) \subset 'O_p('N_G(P) / 'C_G(P)).

Definition generated_by (gp : pred {group gT}) (E : {set gT}) :=
  existsb gE : {set {group gT}}, <<\bigcup_(G \in gE | gp G) G>> == E.

Definition norm_abelian (D : {set gT}) : pred {group gT} :=
  fun A => (D \subset 'N(A)) && abelian A.

Definition p_norm_abelian p (D : {set gT}) : pred {group gT} :=
  fun A => p.-group A && norm_abelian D A.

Definition Puig_succ (D E : {set gT}) :=
  <<\bigcup_(A \in subgroups D | norm_abelian E A) A>>.

Definition Puig_rec D := iter n (Puig_succ D) 1.

End Definitions.

(* This must be defined outside a Section to avoid spurrious delta-reduction *)
Definition Puig_at := nosimpl Puig_rec.

Definition Puig_inf (gT : finGroupType) (G : {set gT}) := Puig_at #|G|.*2 G.

Definition Puig (gT : finGroupType) (G : {set gT}) := Puig_at #|G|.*2.+1 G.

Notation "p .-length_1" := (plength_1 p)
  (at level 2, format "p .-length_1") : group_scope.

Notation "p .-constrained" := (p_constrained p)
  (at level 2, format "p .-constrained") : group_scope.
Notation "p .-abelian_constrained" := (p_abelian_constrained p)
  (at level 2, format "p .-abelian_constrained") : group_scope.
Notation "p .-stable" := (p_stable p)
  (at level 2, format "p .-stable") : group_scope.

Notation "A .-stable" := (stable_factor A) : group_rel_scope.
Notation "G .-central" := (central_factor G)
  (at level 2, format "G .-central") : group_rel_scope.
Notation "G .-chief" := (chief_factor G)
  (at level 2, format "G .-chief") : group_rel_scope.

Notation "''L_[' G ] ( L )" := (Puig_succ G L)
  (at level 8, format  "''L_[' G ] ( L )") : group_scope.
Notation "''L_{' n } ( G )" := (Puig_at n G)
  (at level 8, format "''L_{' n } ( G )") : group_scope.
Notation "''L_*' ( G )" := (Puig_inf G)
  (at level 8, format "''L_*' ( G )") : group_scope.
Notation "''L' ( G )" := (Puig G)
  (at level 8, format "''L' ( G )") : group_scope.

Notation "G .-chief" := (chief_factor G)
  (at level 2, format "G .-chief") : group_rel_scope.

Section BGsection1.

Implicit Type gT : finGroupType.
Implicit Type p : nat.


(* First part of Elementary lemma 1.1 is covered by minnormal_solvable.
Here just for sake of convenience *)
Lemma minnormal_solvable_abelem : forall gT (M G : {group gT}),
  minnormal M G ->  solvable M -> is_abelem M.
Proof.
by move=> gT M G minM solM; case: (minnormal_solvable minM (subxx _) solM).
Qed.

(* Second part of lemma 1.1 *)
Lemma minnormal_solvable_Fitting_center : forall gT (M G : {group gT}),
  minnormal M G ->  M \subset G -> solvable M -> M \subset 'Z('F(G)).
Proof.
move=> gT M G minM sMG solM.
have nZG : 'Z('F(G)) <| G.
  apply: (char_normal_trans (center_char _)); exact: Fitting_normal.
suff: M :&: 'Z('F(G)) = M by move<-; apply: subsetIr.
case/mingroupP: (minM); case/andP=> ntM nMG minM'.
apply: (minM'); last exact:subsetIl.
apply/andP; split; last by apply: normsI => //; apply: normal_norm.
apply: nil_meet_Z => //; first by apply: Fitting_nil.
apply/andP; split; last by apply: subset_trans nMG; exact: Fitting_sub.
apply: Fitting_max; rewrite // /normal ?sMG //; apply: abelian_nil. 
by case: (minnormal_solvable_abelem minM solM); move/abelem_abelian.
Qed.

Lemma chief_factor_minnormal : forall gT (G V U : {group gT}),
  chief_factor G V U -> minnormal (U / V) (G / V).
Proof.
move=> gT G V U; case/and3P=> maxV sUG nUG.
case/maxgroupP: maxV; do 2![case/andP]=> sVU VltU nVG maxV.
have nVU := subset_trans sUG nVG.
apply/mingroupP; rewrite -subG1 quotient_sub1 ?VltU ?quotient_norms //.
split=> // Wbar ntWbar sWbarU; case/andP: ntWbar. 
have{sWbarU} [|W ->{Wbar} sVW] := inv_quotientS _ sWbarU; first exact/andP.
rewrite subEproper; case/predU1P=> [-> // | WltU ntWV].
have nVW := subset_trans (proper_sub WltU) nVU; have nWV := normsG sVW.
rewrite -quotient_normG ?quotientSGK // => [nWG|]; last exact/andP.
by rewrite (maxV W) ?trivg_quotient ?eqxx ?WltU in ntWV.
Qed.

Lemma chief_series_exists : forall gT (H G : {group gT}),
  H <| G -> {s | (G.-chief).-series 1%G s & last 1%G s = H}.
Proof.
move=> gT H G; elim: {H}_.+1 {-2}H (ltnSn #|H|) => // m IHm U leUm nsUG.
case: (eqVneq U 1%G) => [-> | ntU]; first by exists [::].
have [V maxV]: {V : {group gT} | maxnormal V U G}.
  by apply: ex_maxgroup; exists 1%G; rewrite proper1G ntU norms1.
have [ltVU nVG] := andP (maxgroupp maxV).
have [||s ch_s defV] := IHm V; first exact: leq_trans (proper_card ltVU) _.
  by rewrite /normal (subset_trans (proper_sub ltVU) (normal_sub nsUG)).
exists (rcons s U); last by rewrite last_rcons.
rewrite path_rcons defV /= ch_s /chief_factor; exact/and3P.
Qed.

Lemma sol_chief_abelem : forall gT (G V U : {group gT}), 
  solvable G -> chief_factor G V U -> is_abelem (U / V).
Proof.
move=> gT G V U solG chiefUV; have minUV := chief_factor_minnormal chiefUV.
have [|//] := minnormal_solvable minUV (quotientS _ _) (quotient_sol _ solG).
by case/and3P: chiefUV.
Qed.

Section HallLemma.

Variables (gT : finGroupType) (G G' : {group gT}).

Hypothesis solG : solvable G.
Hypothesis nsG'G : G' <| G.
Let sG'G := normal_sub nsG'G.
Let nG'G := normal_norm nsG'G.
Let nsF'G : 'F(G') <| G := char_normal_trans (Fitting_char G') nsG'G.

Let Gchief (UV : {group gT} * {group gT}) := chief_factor G UV.2 UV.1.
Let H := \bigcap_(UV | Gchief UV) 'C(UV.1 / UV.2 | 'Q).
Let H' :=
  G' :&: \bigcap_(UV | Gchief UV && (UV.1 \subset 'F(G'))) 'C(UV.1 / UV.2 | 'Q).

Lemma Fitting_stab_chief : 'F(G') \subset H.
Proof.
apply/bigcapsP=> [[U V] /=  UVchief]; have [/= Vmax sUG nUG] := and3P UVchief. 
case/maxgroupP: Vmax; do 2![case/andP] => sVU prVU nVG maxV.
rewrite sub_astabQ (subset_trans (normal_sub nsF'G) nVG) /=.
suffices: U / V \subset 'Z('F(G / V)).
  rewrite subsetI centsC; case/andP=> _; apply: subset_trans.
  by rewrite Fitting_max ?quotient_normal ?quotient_nil ?Fitting_nil.
have: solvable (U / V) by rewrite quotient_sol // (solvableS sUG).
apply: minnormal_solvable_Fitting_center (quotientS V sUG).
exact: chief_factor_minnormal.
Qed.

Lemma chief_stab_sub_Fitting : H' \subset 'F(G').
Proof.
have nsH'G : H' <| G.
  rewrite /normal subIset ?sG'G ?normsI ?norms_bigcap //; apply/bigcapsP.
  case=> U V; do 4![case/andP | move/maxgroupp] => /= _ nVG; case/andP=> _ nUG.
  by rewrite (subset_trans _ (astab_norm _ _)) ?actsQ.
apply/idPn=> s'H'F.
have [K]: {K | [min K | (K <| G) && ~~ (K \subset 'F(G'))] & K \subset H'}.
  by apply: mingroup_exists; rewrite nsH'G.
case/mingroupP; case/andP=> nsKG s'KF minK; have [sKG nKG] := andP nsKG.
rewrite subsetI; case/andP=> sKG' stabF'K; have nsKG' := normalS sKG' sG'G nsKG.
have{nsKG'} nil'K: ~~ nilpotent K by apply: contra s'KF; exact: Fitting_max.
case/forallP: (nil'K) => L; apply/implyP; rewrite subsetI; case/andP=> sLK sLR.
apply/idPn=> ntL; pose U := <<class_support [~: L, K] G>>.
have ntK : K :!=: 1 by apply: contra ntL; rewrite -!subG1; exact: subset_trans.
have{sLR} sLU: L \subset U.
  by rewrite sub_gen ?(subset_trans sLR) ?sub_class_support.
have{ntL} ntU: U != 1.
  by apply: contra ntL; rewrite -!subG1; apply: subset_trans.
have sUK: U \subset K by rewrite gen_subG class_support_sub_norm ?comm_subG.
have nUG: G \subset 'N(U) by rewrite norms_gen ?class_support_normG.
have [sUG nsUG]: U \subset G /\ U <| G by rewrite /normal !(subset_trans sUK).
have defU: U = [~: U, K].
  apply/eqP; rewrite eqEsubset commg_subl ?(subset_trans sKG) //=.
  by rewrite gen_subG class_support_sub_norm ?commSg ?normsR.
have prUK: U \proper K.
  by rewrite defU (sub_proper_trans (commSg K sUK)) ?(sol_der1_proper solG).
have{prUK} sUF': U \subset 'F(G').
  by case/andP: prUK => _; apply: contraR => s'UF; rewrite [U]minK ?nsUG.
have [V maxV]: {V : {group gT} | maxnormal V U G}.
  by apply: ex_maxgroup; exists 1%G; rewrite proper1G ntU norms1.
case/andP: (maxgroupp maxV); case/andP=> sVU s'UV nVG; case/negP: s'UV.
rewrite defU commGC -sub_astabQR ?(subset_trans _ nVG) //.
by rewrite (bigcapsP stabF'K (_, _)) /Gchief //= -/U -andbA maxV nsUG.
Qed.

End HallLemma.

(* This is B & G, Proposition 1.3. *)
Lemma cent_sub_Fitting : forall gT (G : {group gT}),
  solvable G -> 'C_G('F(G)) \subset 'F(G).
Proof.
move=> gT G solG; apply: subset_trans (chief_stab_sub_Fitting solG _) => //.
rewrite subsetI subsetIl; apply/bigcapsP=> [[U V]] /=.
do 4![case/andP | move/maxgroupp] => _ nVG _ sUF.
by rewrite astabQ (subset_trans _ (morphpre_cent _ _)) // setISS ?centS.
Qed.

(* This is B & G, Proposition 1.4, for internal actions.                      *)
Lemma coprime_trivg_cent_Fitting : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> solvable G -> 
  'C_A(G) = 1 -> 'C_A('F(G)) = 1.
Proof.
move=> gT A G nGA coGA solG regAG; wlog cycA: A nGA coGA regAG / cyclic A.
  move=> IH; apply/trivgP; apply/subsetP=> a; rewrite -!cycle_subG subsetI.
  case/andP=> saA; move/setIidPl <-.
  rewrite {}IH ?cycle_cyclic ?(coprimegS saA) ?(subset_trans saA) //.
  by apply/trivgP; rewrite -regAG setSI.
pose X := G <*> A; pose F := 'F(X); pose pi := \pi(#|A|); pose Q := 'O_pi(F).
have pi'G: pi^'.-group G by rewrite /pgroup -coprime_pi' // coprime_sym.
have piA: pi.-group A by exact: pnat_pi.
have oX: #|X| = (#|G| * #|A|)%N by rewrite [X]norm_mulgenEr ?coprime_cardMg.
have hallG: pi^'.-Hall(X) G.
  by rewrite /pHall -divgS mulgen_subl //= pi'G pnatNK oX mulKn.
have nsGX: G <| X by rewrite /normal mulgen_subl mulgen_subG normG.
have{oX pi'G piA} hallA: pi.-Hall(X) A.
  by rewrite /pHall -divgS mulgen_subr //= piA oX mulnK.
have nsQX: Q <| X := char_normal_trans (pcore_char _ _) (Fitting_normal _).
have{solG cycA} solX: solvable X.
  rewrite (series_sol nsGX) {}solG /= norm_mulgenEr // quotient_mulgr //.
  by rewrite morphim_sol // abelian_sol // cyclic_abelian.
have sQA: Q \subset A.
  by apply: normal_sub_max_pgroup (Hall_max hallA) (pcore_pgroup _ _) nsQX.
have pi'F: 'O_pi(F) = 1.
  suff cQG: G \subset 'C(Q) by apply/trivgP; rewrite -regAG subsetI sQA centsC.
  apply/commG1P; apply/trivgP; rewrite -(coprime_TIg coGA) subsetI commg_subl.
  rewrite (subset_trans sQA) // (subset_trans _ sQA) // commg_subr.
  by rewrite (subset_trans _ (normal_norm nsQX)) ?mulgen_subl.
have sFG: F \subset G.
  rewrite (subset_normal_Hall _ hallG) //= -/X /psubgroup Fitting_sub /=.
  have: nilpotent F := Fitting_nil _; move/(nilpotent_pcoreC pi) => /=.
  by case/dprodP=> _ <- _ _; rewrite pi'F mul1g pcore_pgroup.
have <-: F = 'F(G).
  apply/eqP; rewrite eqEsubset -{1}(setIidPr sFG) FittingS ?mulgen_subl //=.
  by rewrite Fitting_max ?Fitting_nil // (char_normal_trans (Fitting_char _)).
apply/trivgP; rewrite /= -(coprime_TIg coGA) subsetI subsetIl andbT.
apply: subset_trans (subset_trans (cent_sub_Fitting solX) sFG).
by rewrite setSI ?mulgen_subr.
Qed.

(* A "contrapositive" of Proposition 1.4 above.                               *)
Lemma coprime_cent_Fitting : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> solvable G ->
  'C_A('F(G)) \subset 'C(G).
Proof.
move=> gT A G nGA coGA solG; apply/setIidPl; rewrite -setIA setIIr.
apply/setIidPl; set C := 'C_A(G); rewrite -quotient_sub1 /= -/C; last first.
  by rewrite subIset // normsI ?normG // norms_cent.
apply: subset_trans (quotient_subcent _ _ _) _; rewrite /= -/C.
have nCG: G \subset 'N(C) by rewrite cents_norm // centsC subsetIr.
rewrite /= -(setIidPr (Fitting_sub _)) -[(G :&: _) / _](morphim_restrm nCG).
rewrite bgFunc_ascont //=; last first.
  by rewrite ker_restrm ker_coset setIA (coprime_TIg coGA) subIset ?subxx.
rewrite morphim_restrm -quotientE setIid.
rewrite coprime_trivg_cent_Fitting ?quotient_norms ?coprime_morph //=.
  exact: morphim_sol.
rewrite -strongest_coprime_quotient_cent ?trivg_quotient ?solG ?orbT //.
  by rewrite -setIA subsetIl.
by rewrite coprime_sym -setIA (coprimegS (subsetIl _ _)).
Qed.

(* B & G Proposition 1.5 is covered by several lemmas in hall.v :             *)
(*  1.5a -> coprime_Hall_exists (internal action)                             *)
(*          ext_coprime_Hall_exists (general group action)                    *)
(*  1.5b -> coprime_Hall_subset (internal action)                             *)
(*          ext_coprime_Hall_subset (general group action)                    *)
(*  1.5c -> coprime_Hall_trans (internal action)                              *)
(*          ext_coprime_Hall_trans (general group action)                     *)
(*  1.5d -> coprime_quotient_cent (internal action)                           *)
(*          ext_coprime_quotient_cent (general group action)                  *)
(*          several stronger variants are proved for internal action          *)
(*  1.5e -> coprime_comm_pcore (internal action only)                         *)

(* Stronger variant of B & G 1.6(a) *)
Lemma coprimeR_cent_prod : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|[~: G, A]| #|A| -> solvable [~: G, A] ->
  [~: G, A] * 'C_G(A) = G.
Proof.
move=> gT A G nGA coRA solR.
have nRG: [~: G, A] <| G by rewrite /normal commg_subl nGA commg_norml.
apply/eqP; rewrite eqEsubset mulG_subG commg_subl nGA subsetIl /=.
rewrite -quotientSK ?commg_norml ?coprime_norm_quotient_cent ?commg_normr //=.
by rewrite subsetI subxx quotient_cents2r.
Qed.

(* B & G, Proposition 1.6(a) *)
Lemma coprime_cent_prod : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> solvable G ->
  [~: G, A] * 'C_G(A) = G.
Proof.
move=> gT A G nGA; have sRG: [~: G, A] \subset G by rewrite commg_subl.
rewrite -(LaGrange sRG) coprime_mull; case/andP=> coRA _; move/(solvableS sRG).
exact: coprimeR_cent_prod.
Qed.

(* B & G, Proposition 1.6(b) *)
Lemma coprime_commGid : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> solvable G ->
  [~: G, A, A] = [~: G, A].
Proof.
move=> gT A G nGA coGA solG; apply/eqP; rewrite eqEsubset commSg ?commg_subl //.
have nAC: 'C_G(A) \subset 'N(A) by rewrite subIset ?cent_sub ?orbT.
rewrite -{1}(coprime_cent_prod nGA) // commMG //=; first 1 last.
  by rewrite !normsR // subIset ?normG.
by rewrite (commG1P (subsetIr _ _)) mulg1.
Qed.

(* B & G, Proposition 1.6(c) *)
Lemma coprime_commGG1P : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> solvable G ->
  [~: G, A, A] = 1 -> A \subset 'C(G).
Proof.
by move=> gT A G nGA coGA solG; rewrite centsC coprime_commGid //; move/commG1P.
Qed.

(* B & G, Proposition 1.6(d), TI-part, from finmod.v *)
Definition coprime_abel_cent_TI := coprime_abel_cent_TI.

(* B & G, Proposition 1.6(d) (direct product) *)
Theorem coprime_abelian_cent_dprod : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> abelian G ->
  [~: G, A] \x 'C_G(A) = G.
Proof.
move=> gT A G nGA coGA abelG; rewrite dprodE ?coprime_cent_prod ?abelian_sol //.
  by rewrite centsC subIset 1?(subset_trans abelG) // centS // commg_subl.
by apply/trivgP; rewrite /= setICA coprime_abel_cent_TI ?subsetIr.
Qed.

(* B & G, Proposition 1.6(e), which generalises Aschbacher 24.3 *)
Lemma coprime_abelian_faithful_Ohm1 : forall gT (A G : {group gT}),
    A \subset 'N(G) -> coprime #|G| #|A| -> abelian G ->
  A \subset 'C('Ohm_1(G)) -> A \subset 'C(G).
Proof.
move=> gT A G nGA coGA abG; rewrite centsC => cGAp; rewrite centsC.
case/dprodP: (coprime_abelian_cent_dprod nGA coGA abG) => _ defG _ TI_G.
have sRG: [~: G, A] \subset G by rewrite commg_subl.
rewrite -{}defG -(setIidPl sRG) TI_Ohm1 ?mul1g ?subsetIr //.
by apply/trivgP; rewrite -{}TI_G setIS // subsetI Ohm_sub.
Qed.

(* B & G, Lemma 1.7 is covered by several lemmas in maximal.v :               *)
(*   1.7a -> Phi_nongen                                                       *)
(*   1.7b -> Phi_quotient_abelem                                              *)
(*   1.7c -> trivg_Phin                                                       *)
(*   1.7d -> Phi_mulgen                                                       *)

(* This is B & G, Proposition 1.8, Aschbacher 24.1. Note that the coprime     *)
(* assumption is slightly weaker than requiring that A be a p'-group.  *)
Lemma coprime_cent_Phi : forall gT p (A G : {group gT}),
    p.-group G -> coprime #|G| #|A| -> [~: G, A] \subset 'Phi(G) ->
  A \subset 'C(G).
Proof.
move=> gT p A G pG coGA sRphi; rewrite centsC; apply/setIidPl.
rewrite -['C_G(A)]genGid; apply: Phi_nongen; apply/eqP.
rewrite eqEsubset mulgen_subG Phi_sub subsetIl -genM_mulgen sub_gen //=.
have [sPhiG nPhiG] := andP (char_normal (Phi_char G)).
have nPhiA: A \subset 'N('Phi(G)).
  by rewrite -commg_subl (subset_trans _ sRphi) ?commSg.
rewrite -quotientSK // coprime_quotient_cent ?(pgroup_sol pG) // subsetI subxx.
by rewrite (sameP commG1P trivgP) /= -morphimR ?quotient_sub1 // comm_subG.
Qed.

(* B & G, Proposition 1.9, base (and most common) case, internal action.      *)
Theorem stable_factor_cent : forall gT (A G H : {group gT}),
    A \subset 'C(H) -> stable_factor A H G ->
    coprime #|G| #|A| -> solvable G ->
  A \subset 'C(G).
Proof.
move=> gT A G H cHA; case/and3P=> sRH sHG nHG coGA solG.
suffices: G \subset 'C_G(A) by rewrite subsetI subxx centsC.
rewrite -(quotientSGK nHG) ?subsetI ?sHG 1?centsC //.
by rewrite coprime_quotient_cent ?cents_norm ?subsetI ?subxx ?quotient_cents2r.
Qed.

(* This is B & G, Proposition 1.9 (for internal coprime action) *)
Theorem stable_series_cent : forall gT (A G : {group gT}) s,
   last 1%G s :=: G -> (A.-stable).-series 1%G s ->
   coprime #|G| #|A| -> solvable G ->
  A \subset 'C(G).
Proof.
move=> gT A _ s <-; elim/last_ind: s => /= [| s G IHs]; first by rewrite cents1.
rewrite last_rcons path_rcons /=.
case/andP; move/IHs {IHs}; move: {s}(last _ _) => H IH_H nHGA coGA solG.
have [_ sHG _] := and3P nHGA.
by rewrite (stable_factor_cent _ nHGA) ?IH_H ?(solvableS sHG) ?(coprimeSg sHG).
Qed.

(* This is B & G, Proposition 1.10 *)
Theorem coprime_nil_faithful_cent_stab : forall gT (A G : {group gT}),
     A \subset 'N(G) -> coprime #|G| #|A| -> nilpotent G ->
  let C := 'C_G(A) in 'C_G(C) \subset C -> A \subset 'C(G).
Proof.
move=> gT A G nGA coGA nilG C; rewrite subsetI subsetIl centsC /= -/C => cCA.
pose N := 'N_G(C); have sNG: N \subset G by rewrite subsetIl.
have sCG: C \subset G by rewrite subsetIl.
suffices cNA : A \subset 'C(N).
  rewrite centsC (sameP setIidPl eqP) -(nilpotent_sub_norm nilG sCG) //= -/C.
  by rewrite subsetI subsetIl centsC.
have{nilG} solN: solvable N by rewrite(solvableS sNG) ?nilpotent_sol.
rewrite (stable_factor_cent cCA) ?(coprimeSg sNG) /stable_factor //= -/N -/C.
rewrite subcent_normal subsetI (subset_trans (commSg A sNG)) ?commg_subl //=.
rewrite comm_norm_cent_cent 1?centsC ?subsetIr // normsI // !norms_norm //.
by rewrite cents_norm 1?centsC ?subsetIr.
Qed.

(* B & G, Theorem 1.11, via Aschbacher 24.7 rather than Gorenstein 5.3.10 *)
Theorem coprime_odd_faithful_Ohm1 : forall gT p (A G : {group gT}),
    p.-group G -> A \subset 'N(G) -> coprime #|G| #|A| -> odd #|G| ->
  A \subset 'C('Ohm_1(G)) -> A \subset 'C(G).
Proof.
move=> gT p A G pG nGA coGA oddG; rewrite !(centsC A) => cAG1.
case: (eqsVneq G 1) => [-> | ntG]; first exact: sub1G.
have{oddG ntG} [p_pr oddp]: prime p /\ odd p.
  have [p_pr p_dv_G _] := pgroup_pdiv pG ntG.
  by rewrite !odd_2'nat in oddG *; rewrite pnatE ?(pgroupP oddG).
wlog defR: G pG nGA coGA cAG1 / [~: G, A] = G.
  move=> IH; have solG := pgroup_sol pG.
  rewrite -(coprime_cent_prod nGA) ?mul_subG ?subsetIr //=.
  have sRG: [~: G, A] \subset G by rewrite commg_subl.
  rewrite IH ?coprime_commGid ?(pgroupS sRG) ?commg_normr ?(coprimeSg sRG) //.
  by rewrite (subset_trans (OhmS 1 sRG)).
have [|[defPhi defG'] defC] := abelian_charsimple_special pG coGA defR.
  apply/bigcupsP=> H; case/andP=> chH abH; have sHG := char_sub chH.
  have nHA := char_norm_trans chH nGA.
  rewrite centsC coprime_abelian_faithful_Ohm1 ?(coprimeSg sHG) //.
  by rewrite centsC (subset_trans (OhmS 1 sHG)).
have elemZ: p.-abelem 'Z(G) by exact: center_special_abelem.
have cAZ: {in 'Z(G), centralised A} by apply/centsP; rewrite -defC subsetIr.
have cGZ: {in 'Z(G), centralised G} by apply/centsP; rewrite subsetIr.
have defG1: 'Ohm_1(G) = 'Z(G).
  apply/eqP; rewrite eqEsubset -{1}defC subsetI Ohm_sub cAG1 /=.
  by rewrite -(Ohm1_id elemZ) OhmS ?center_sub.
rewrite (subset_trans _ (subsetIr G _)) // defC -defG1 -{1}defR gen_subG /=.
apply/subsetP=> xa; case/imset2P=> x a Gx Aa ->{xa}; rewrite commgEl.
set u := x^-1; set v := x ^ a; pose w := [~ v, u].
have [Gu Gv]: u \in G /\ v \in G by rewrite groupV memJ_norm ?(subsetP nGA).
have Zw: w \in 'Z(G) by rewrite -defG' mem_commg.
rewrite (OhmE 1 pG) mem_gen // inE expn1 groupM //=.
rewrite expMg_Rmul /commute ?(cGZ w) // bin2odd // expgn_mul.
case/(abelemP p_pr): elemZ => _; move/(_ w)=> -> //.
rewrite exp1gn mulg1 expVgn -conjXg (sameP commgP eqP) cAZ //.
rewrite -defPhi (Phi_mulgen pG) (MhoE 1 pG) mulgen_idr mem_gen // !inE.
by rewrite orbC expn1 (mem_imset (expgn^~ p)).
Qed.

(* This is B & G, Corollary 1.12 *)
Corollary coprime_odd_faithful_cent_abelem : forall gT p (A G E : {group gT}),
    E \in 'E_p(G) -> p.-group G ->
    A \subset 'N(G) -> coprime #|G| #|A| -> odd #|G| ->
  A \subset 'C([set x \in 'C_G(E) | #[x] == p]) -> A \subset 'C(G).
Proof.
move=> gT p A G E; rewrite inE; case/andP=> sEG elemE pG nGA coGA oddG cCEA.
case: (eqsVneq G 1) => [-> | ntG]; first by rewrite cents1.
have [p_pr _ _] := pgroup_pdiv pG ntG.
have spG: p.-group (G :&: _) := pgroupS (subsetIl _ _) pG.
have{cCEA} cCEA: A \subset 'C('Ohm_1('C_G(E))).
  apply: subset_trans cCEA _; rewrite -cent_gen centS // (OhmE 1 (spG _)).
  rewrite gen_subG; apply/subsetP=> x; case/setIdP=> CEx.
  rewrite expn1 -order_dvdn; case/primeP: p_pr => _ p_pr; move/p_pr.
  rewrite order_eq1; case/predU1P=> [-> | defM]; first exact: group1.
  by rewrite mem_gen // inE CEx.
apply: coprime_nil_faithful_cent_stab (pgroup_nil pG) _ => //.
rewrite subsetI subsetIl centsC /=; set CC := 'C_G(_).
have sCCG: CC \subset G := subsetIl _ _; have pCC := pgroupS sCCG pG.
rewrite (coprime_odd_faithful_Ohm1 pCC) ?(coprimeSg sCCG) ?(oddSg sCCG) //.
  by rewrite !(normsI, norms_cent, normG).
rewrite (subset_trans cCEA) // centS // OhmS // setIS // centS //.
rewrite subsetI sEG /= centsC (subset_trans cCEA) // centS //.
have abelE: abelian E by case/and3P: elemE.
by rewrite -{1}(Ohm1_id elemE) OhmS // subsetI sEG.
Qed.

(* This is B & G, Theorem 1.13.                                               *)
Theorem critical_odd : forall  gT p (G : {group gT}), 
    odd p -> p.-group G -> G :!=: 1 ->
  {H : {group gT} |
     [/\ H \char G, [~: H, G] \subset 'Z(H), nil_class H <= 2, exponent H = p
       & p.-group 'C_(Aut G)(H | 'P)]}.
Proof.
move=> gT p G odd_p pG ntG; have [H krH]:= Thompson_critical pG.
have [chH sPhiZ sGH_Z scH] := krH; have clH := critical_class2 krH.
have sHG := char_sub chH; set D := 'Ohm_1(H)%G; exists D.
have chD: D \char G := char_trans (Ohm_char _ _) chH.
have sDH: D \subset H := Ohm_sub _ _.
have sDG_Z: [~: D, G] \subset 'Z(D).
  rewrite subsetI commg_subl char_norm // commGC.
  apply: subset_trans (subset_trans sGH_Z _); first by rewrite commgS.
  by rewrite subIset // orbC centS.
rewrite nil_class2 sDG_Z (subset_trans (commgS _ _) sDG_Z) // ?char_sub //.
have [p_pr _ _] := pgroup_pdiv pG ntG.
split=> //.
  have: exponent D %| p by rewrite exponent_Ohm1_class2 ?(pgroupS _ pG).
  case/primeP: p_pr => _ p_pr; move/p_pr; rewrite orbC; case/predU1P=> {p_pr}//.
  rewrite -dvdn1 -trivg_exponent /=; move/eqP => D1; case/eqP: ntG.
  suffices H1: H :=: 1 by rewrite H1 center1 cent1T !setIT in scH.
  by rewrite -(setIid H) TI_Ohm1 ?D1 ?(setIidPr (sub1G _)).  
apply/pgroupP=> q pr_q; case/Cauchy=> // f; case/setIdP=> Af cDf ofq.
apply/idPn=> nqp {sDG_Z chD sDH}; suffices: f \in 'C_(Aut G)(H | 'P).
  move/(mem_p_elt (critical_p_stab_Aut krH pG)); move/pnatP=> pf.
  by rewrite pf // ofq in nqp.
rewrite inE Af; apply/astabP=> x Hx; rewrite /= /aperm /=.
rewrite nil_class2 in clH; have pH := pgroupS sHG pG.
have: p.-elt x by apply: mem_p_elt Hx.
case/p_natP=> // i ox; have:= expg_order x; rewrite {}ox.
elim: i x Hx => [|[|i] IHi] x Hx xp1.
- by rewrite expg1 in xp1; rewrite xp1 -(autmE Af) morph1.
- apply: (astabP cDf); rewrite /=.
  by rewrite (OhmE 1 pH) mem_gen // inE Hx xp1 eqxx.
have expH': {in H &, forall y z, [~ y, z] ^+ p = 1}.
  move=> y z Hy Hz.
  have: [~ y, z] \in 'Z(H) by rewrite (subsetP clH) // mem_commg.
  case/setIP=> _; move/centP=> Cyz.
  rewrite -commXg; last by apply: commute_sym; exact: Cyz.
  have: y ^+ p \in 'Z(H).
    rewrite (subsetP sPhiZ) // (Phi_mulgen pH) mem_gen // inE orbC.
    rewrite (MhoE 1 pH) expn1 mem_gen //; exact: mem_imset.
  case/setIP=> _; move/centP=> Cyp; apply/eqP; apply/commgP; exact: Cyp.
have Hfx: f x \in H.
  case/charP: chH => _ chH.
  rewrite -(chH _ (injm_autm Af) (im_autm Af)) -{1}(autmE Af).
  rewrite mem_morphim // (subsetP sHG) //.
set y := x^-1 * f x; set z := [~ f x, x^-1].
have Hy: y \in H by rewrite groupM ?groupV.
have: z \in 'Z(H); last case/centerP=> _ Zz.
  by rewrite (subsetP clH) // mem_commg ?groupV.
have fy: f y = y.
  apply: (IHi); first by rewrite groupM ?groupV.
  rewrite expMg_Rmul; try by apply: commute_sym; apply: Zz; rewrite ?groupV.
  rewrite -/z bin2odd ?odd_exp // {3}expnS -mulnA expgn_mul expH' ?groupV //.
  rewrite exp1gn mulg1 expVgn -(autmE Af) -morphX ?(subsetP sHG) //= autmE.
  rewrite IHi ?mulVg ?groupX // {2}expnS expgn_mul -(expgn_mul x _ p) -expnSr.
  by rewrite xp1 exp1gn.
have: (f ^+ q) x = x * y ^+ q.
  elim: (q) => [|j IHj]; first by rewrite perm1 mulg1.
  rewrite expgSr permM {}IHj -(autmE Af).
  rewrite morphM ?morphX ?groupX ?(subsetP sHG) //= autmE.
  by rewrite fy expgS mulgA mulKVg.
move/eqP; rewrite -{1}ofq expg_order perm1 eq_mulVg1 mulKg -order_dvdn.
case: (primeP pr_q) => _ dv_q; move/dv_q; rewrite order_eq1 -eq_mulVg1.
case: eqP => //= _; move/eqP=> oyq; case/negP: nqp.
by apply: (pgroupP pH); rewrite // -oyq order_dvdG.
Qed.

Section CoprimeQuotientPgroup.

(* This is B & G, Lemma 1.14, which we divide in four lemmas, each one giving *)
(* the (sub)centraliser or (sub)normaliser of a quotient by a coprime p-group *)
(* acting on it. Note that we weaken the assumptions of B & G -- M does not   *)
(* need to be normal in G, T need not be a subgroup of G, p need not be a     *)
(* prime, and M only needs to be coprime with T. Note also that the subcenter *)
(* quotient lemma is special case of a lemma in coprime_act.                  *)

Variables (gT : finGroupType) (p : nat) (T M G : {group gT}).
Hypothesis pT : p.-group T.
Hypotheses (nMT : T \subset 'N(M)) (coMT : coprime #|M| #|T|).

Lemma coprime_norm_quotient_pgroup : 'N(T / M) = 'N(T) / M.
Proof.
case: (eqsVneq T 1) => [-> | ntT].
  by rewrite quotient1 !norm1 -quotientInorm setTI quotientT.
have [p_pr _ [m oMpm]] := pgroup_pdiv pT ntT.
apply/eqP; rewrite eqEsubset morphim_norms // andbT; apply/subsetP=> Mx.
case: (cosetP Mx) => x Nx ->{Mx} nTqMx.
have sylT: p.-Sylow(M <*> T) T.
  rewrite /pHall pT -divgS mulgen_subr //= norm_mulgenEr ?coprime_cardMg //.
  rewrite mulnK // ?p'natE -?prime_coprime // coprime_sym.
  by rewrite -(@coprime_pexpr m.+1) -?oMpm.
have sylTx: p.-Sylow(M <*> T) (T :^ x).
  have nMTx: x \in 'N(M <*> T).
    rewrite norm_mulgenEr // inE -quotientSK ?conj_subG ?mul_subG ?normG //.
    by rewrite quotientJ // quotient_mulgr (normP nTqMx).
  by rewrite pHallE /= -{1}(normP nMTx) conjSg cardJg -pHallE.
have{sylT sylTx} [ay] := Sylow_trans sylT sylTx.
rewrite /= mulgenC norm_mulgenEl //; case/imset2P=> a y Ta.
rewrite -groupV => My ->{ay} defTx; rewrite -(coset_kerr x My).
rewrite mem_morphim //; first by rewrite groupM // (subsetP (normG M)).
by rewrite inE !(conjsgM, defTx) conjsgK conjGid.
Qed.

Lemma coprime_cent_quotient_pgroup : 'C(T / M) = 'C(T) / M.
Proof.
symmetry; rewrite -quotientInorm -quotient_mulgr -['C(T / M)]cosetpreK.
congr (_ / M); set Cq := _ @*^-1 _; set C := 'N__(M).
suff <-: 'N_Cq(T) = C.
  rewrite setIC group_modl ?sub_cosetpre //= -/Cq; apply/setIidPr.
  rewrite -quotientSK ?subsetIl // cosetpreK.
  by rewrite -coprime_norm_quotient_pgroup cent_sub.
apply/eqP; rewrite eqEsubset subsetI -sub_quotient_pre ?subsetIr //.
rewrite quotientInorm quotient_cents //= andbC subIset ?cent_sub //=.
have nMC': 'N_Cq(T) \subset 'N(M) by rewrite subIset ?subsetIl.
rewrite subsetI nMC' andbT (sameP commG1P trivgP) /=.
rewrite -(coprime_TIg coMT) subsetI commg_subr subsetIr andbT.
by rewrite -quotient_cents2 ?sub_quotient_pre ?subsetIl.
Qed.

Hypothesis sMG : M \subset G.

Lemma coprime_subnorm_quotient_pgroup : 'N_(G / M)(T / M) = 'N_G(T) / M.
Proof. by rewrite quotientGI -?coprime_norm_quotient_pgroup. Qed.

Lemma coprime_subcent_quotient_pgroup : 'C_(G / M)(T / M) = 'C_G(T) / M.
Proof. by rewrite quotientGI -?coprime_cent_quotient_pgroup. Qed.

End CoprimeQuotientPgroup.

Section Constrained.

Variables (gT : finGroupType) (p : nat) (G : {group gT}).

(* This is B & G, Proposition 1.15a (Hall-Higman Lemma 1.2.3) *)
Lemma solvable_p_constrained : solvable G -> p.-constrained G.
Proof.
move=> solG P sylP; have [sPO pP _] := and3P sylP; pose K := 'O_p^'(G).
have nKG: G \subset 'N(K) by rewrite normal_norm ?pcore_normal.
have nKC: 'C_G(P) \subset 'N(K) by rewrite subIset ?nKG.
rewrite -(quotientSGK nKC) //; last first.
  by rewrite /= -pseries1 (pseries_sub_catl [::_]).
apply: subset_trans (quotient_subcent _ _ _) _ ;rewrite /= -/K.
suffices ->: P / K = 'O_p(G / K).
  rewrite quotient_pseries2 -Fitting_eq_pcore ?trivg_pcore_quotient // -/K.
  by rewrite cent_sub_Fitting ?morphim_sol.
apply/eqP; rewrite eqEcard -(part_pnat_id (pcore_pgroup _ _)).
have sylPK: p.-Sylow('O_p(G / K)) (P / K).
  rewrite -quotient_pseries2 morphim_pHall //.
  exact: subset_trans (subset_trans sPO (pseries_sub _ _)) nKG.
by rewrite -(card_Hall sylPK) leqnn -quotient_pseries2 quotientS.
Qed.

(* This is Gorenstein, Proposition 8.1.3 *)
Lemma p_stable_abelian_constrained :
  p.-constrained G -> p.-stable G -> p.-abelian_constrained G.
Proof.
move=> constrG stabG P A sylP cAA; case/andP=> sAP nAP.
have [sPG pP _] := and3P sylP; have sAG := subset_trans sAP sPG.
set K2 := 'O_{p^', p}(G); pose K1 := 'O_p^'(G); pose Q := P :&: K2.
have sQG: Q \subset G by rewrite subIset ?sPG.
have nK1G: G \subset 'N(K1) by rewrite normal_norm ?pcore_normal.
have nsK2G: K2 <| G := pseries_normal _ _; have [sK2G nK2G] := andP nsK2G.
have sylQ: p.-Sylow(K2) Q by rewrite /Q setIC (pSylow_normalI nsK2G).
have defK2: K1 * Q = K2.
  have sK12: K1 \subset K2 by rewrite /K1 -pseries1 (pseries_sub_catl [::_]).
  apply/eqP; rewrite eqEsubset mulG_subG /= sK12 subsetIr /=.
  rewrite -quotientSK ?(subset_trans sK2G) //= quotientIG //= -/K1 -/K2.
  rewrite subsetI subxx andbT quotient_pseries2.
  by rewrite pcore_sub_Hall // morphim_pHall // ?(subset_trans sPG).
have{cAA} rQAA_1: [~: Q, A, A] = 1.
  by apply/commG1P; apply: subset_trans cAA; rewrite commg_subr subIset // nAP.
have nK2A := subset_trans sAG nK2G.
have sAN: A \subset 'N_G(Q) by rewrite subsetI sAG normsI // normsG.
have{stabG rQAA_1 defK2 sQG} stabA: A / 'C_G(Q) \subset 'O_p('N_G(Q) / 'C_G(Q)).
  apply: stabG; rewrite //= /psubgroup -/Q ?sAN ?(pgroupS _ pP) ?subsetIl //.
  by rewrite defK2 pseries_normal.
rewrite -quotient_sub1 //= -/K2 -(setIidPr sAN).
have nK2N: 'N_G(Q) \subset 'N(K2) by rewrite subIset ?nK2G.
rewrite -[_ / _](morphim_restrm nK2N); set qK2 := restrm _ _.
have{constrG} fqKp: 'ker (coset 'C_G(Q)) \subset 'ker qK2.
  by rewrite ker_restrm !ker_coset subsetI subcent_sub constrG.
rewrite -(morphim_factm fqKp (subcent_norm _ _)) -(quotientE A _).
apply: subset_trans {stabA}(morphimS _ stabA) (subset_trans (pcore_cont _ _) _).
rewrite morphim_factm morphim_restrm setIid -quotientE.
rewrite /= -quotient_mulgr /= -/K2 (Frattini_arg _ sylQ) ?pseries_normal //.
by rewrite -quotient_pseries //= (pseries_rcons_id [::_]) trivg_quotient.
Qed.

End Constrained.

(* This is B & G, Proposition 1.15b (attributed to D. Goldschmith).          *)
Lemma p'core_cent_pgroup : forall gT p (G R : {group gT}),
  p.-subgroup(G) R -> solvable G -> 'O_p^'('C_G(R)) \subset 'O_p^'(G).
Proof.
move=> gT p G R; case/andP=> sRG pR solG.
wlog p'G1: gT G R sRG pR solG / 'O_p^'(G) = 1.
  have nOG_CR: 'C_G(R) \subset 'N('O_p^'(G)) by rewrite subIset ?bgFunc_norm.
  move=> IH; rewrite -quotient_sub1 ?(subset_trans (pcore_sub _ _)) //.
  apply: subset_trans (morphim_sFunctor _ _ nOG_CR) _; rewrite /= -quotientE.
  rewrite -(coprime_subcent_quotient_pgroup pR) ?pcore_sub //; first 1 last.
  - by rewrite (subset_trans sRG) ?bgFunc_norm.
  - by rewrite coprime_sym (pnat_coprime _ (pcore_pgroup _ _)).
  have p'Gq1 : 'O_p^'(G / 'O_p^'(G)) = 1 := trivg_pcore_quotient p^' G.
  by rewrite -p'Gq1 IH ?morphimS ?morphim_pgroup ?morphim_sol.
set M := 'O_p^'('C_G(R)); pose T := 'O_p(G).
have [sMG cMR]: M \subset G /\ M \subset 'C(R).
  by apply/andP; rewrite -subsetI pcore_sub.
have [p'M pT]: p^'.-group M /\ p.-group T by rewrite !pcore_pgroup.
have nRT: R \subset 'N(T) by rewrite (subset_trans sRG) ?bgFunc_norm.
have pRT: p.-group (R <*> T).
  rewrite -(pquotient_pgroup pT) ?mulgen_subG ?nRT ?normG //=.
  by rewrite norm_mulgenEl // quotient_mulg morphim_pgroup.
have nRT_M: M \subset 'N(R <*> T).
  by rewrite norms_mulgen ?(cents_norm cMR) // (subset_trans sMG) ?bgFunc_norm.
have coRT_M: coprime #|R <*> T| #|M| := pnat_coprime pRT p'M.
have cMcR: 'C_(R <*> T)(R) \subset 'C(M).
  apply/commG1P; apply/trivgP; rewrite -(coprime_TIg coRT_M) subsetI commg_subr.
  rewrite (subset_trans (commSg _ (subsetIl _ _))) ?commg_subl //= -/M.
  apply: subset_trans (bgFunc_norm _ _).
  by rewrite setSI // mulgen_subG sRG pcore_sub.
have cRT_M: M \subset 'C(R <*> T).
  rewrite coprime_nil_faithful_cent_stab ?(pgroup_nil pRT) //= -/M.
  rewrite subsetI subsetIl (subset_trans _ cMcR) // ?setIS ?centS //.
  by rewrite subsetI mulgen_subl centsC.
have sMT: M \subset T.
  have defT: 'F(G) = T := Fitting_eq_pcore p'G1.
  rewrite -defT (subset_trans _ (cent_sub_Fitting solG)) // defT subsetI sMG.
  by rewrite (subset_trans cRT_M) // cent_mulgen subsetIr.
by rewrite -(setIidPr sMT) p'G1 coprime_TIg // (pnat_coprime pT).
Qed.

(* This is B & G, Proposition 1.16, second assertion. Contrary to the text,  *)
(* we derive this directly, rather than by induction on the first, because   *)
(* this is actually how the proof is done in Gorenstein. Note that the non   *)
(* cyclic assumption for A is not needed here.                               *)
Lemma coprime_abelian_gen_cent : forall gT (A G : {group gT}),
   abelian A -> A \subset 'N(G) -> coprime #|G| #|A| ->
  G = (\prod_(B : {group gT} | cyclic (A / B) && (B <| A)) 'C_G(B))%G.
Proof.
move=> gT A G abelA nGA coGA; apply: val_inj; rewrite /= bigprodGE.
move: {2}_.+1 (ltnSn #|G|) => n.
elim: n gT => // n IHn gT in A G abelA nGA coGA *; rewrite ltnS => leGn.
without loss nilG: G nGA coGA leGn / nilpotent G.
  move=> {IHn} IHn; apply/eqP; rewrite eqEsubset gen_subG.
  apply/andP; split; last by apply/bigcupsP=> B _; exact: subsetIl.
  pose T := [set P : {group gT} | Sylow G P && (A \subset 'N(P))].
  rewrite -{1}(@Sylow_transversal_gen _ T G) => [|P | p _]; first 1 last.
  - by rewrite inE -!andbA; case/and4P.
  - have [//|P sylP nPA] := sol_coprime_Sylow_exists p (abelian_sol abelA) nGA.
    by exists P; rewrite ?inE ?(p_Sylow sylP).
  rewrite gen_subG; apply/bigcupsP=> P; rewrite {T}inE.
  case/andP; case/SylowP=> p _ sylP nPA; have sPG := pHall_sub sylP.
  rewrite (IHn P) ?(pgroup_nil (pHall_pgroup sylP)) ?(coprimeSg sPG) ?genS //.
    by apply/bigcupsP=> B cycBq; rewrite (bigcup_max B) ?setSI.
  by rewrite (leq_trans (subset_leq_card sPG)).
apply/eqP; rewrite eqEsubset gen_subG.
apply/andP; split; last by apply/bigcupsP=> B _; exact: subsetIl.
case: (eqsVneq 'Z(G) 1) => [Z1 | ntZ].
  by rewrite (nil_TI_Z _ (normal_refl G)) ?Z1 ?(setIidPr _) ?sub1G.
have nZA: A \subset 'N('Z(G)) := char_norm_trans (center_char G) nGA.
have{ntZ nZA} [M /= minM] := minnormal_exists ntZ nZA.
rewrite subsetI centsC; case/andP=> sMG; move/cents_norm=> nMG. 
have coMA := coprimeSg sMG coGA; have{nilG} solG := nilpotent_sol nilG.
have [nMA ntM abelM] := minnormal_solvable minM sMG solG.
set GC := <<_>>; have sMGC: M \subset GC.
  rewrite sub_gen ?(bigcup_max 'C_A(M)%G) //=; last first.
    by rewrite subsetI sMG centsC subsetIr.
  case/is_abelemP: abelM => p _ abelM; rewrite -(rker_abelem abelM ntM nMA).
  have ker_q_cyc := mx_repr_faithful_irr_abelian_cyclic _ (kquo_mx_faithful _).
  rewrite rker_normal {}ker_q_cyc ?morphim_abelian //.
  by apply/quo_mx_irr=> //; exact/abelem_mx_irrP.
rewrite -(quotientSGK nMG sMGC).
have: A / M \subset 'N(G / M) by rewrite morphim_norms.
move/IHn->; rewrite ?morphim_abelian ?coprime_morph {IHn}//; first 1 last.
  by rewrite (leq_trans _ leGn) ?ltn_quotient.
rewrite gen_subG; apply/bigcupsP=> Bq; rewrite andbC; case/andP.
have: A :&: M = 1 by rewrite setIC coprime_TIg.
move/(quotient_isom nMA); case/isomP=> /=; set qM := restrm _ _ => injqM <-.
move=> nsBqA; have sBqA := normal_sub nsBqA.
rewrite -(morphpreK sBqA) /= -/qM; set B := qM @*^-1 Bq.
move: nsBqA; rewrite -(morphpre_normal sBqA) ?injmK //= -/B => nsBA.
rewrite -(morphim_quotm _ nsBA) /= -/B injm_cyclic ?injm_quotm //= => cycBA.
rewrite morphim_restrm -quotientE morphpreIdom -/B; have sBA := normal_sub nsBA.
rewrite -coprime_quotient_cent ?(coprimegS sBA, subset_trans sBA) //= -/B.
by rewrite quotientS ?sub_gen // (bigcup_max [group of B]) ?cycBA.
Qed.

(* B & G, Proposition 1.16, first assertion. *)
Lemma coprime_abelian_gen_cent1 : forall gT (A G : {group gT}),
   abelian A -> ~~ cyclic A -> A \subset 'N(G) -> coprime #|G| #|A| ->
  G = (\prod_(a \in A^#) 'C_G[a])%G.
Proof.
move=> gT A G abelA ncycA nGA coGA.
apply/eqP; rewrite -val_eqE eqEsubset /= bigprodGE gen_subG.
apply/andP; split; last by apply/bigcupsP=> B _; exact: subsetIl.
rewrite {1}(coprime_abelian_gen_cent abelA nGA) // bigprodGE genS //.
apply/bigcupsP=> B; case: (eqsVneq B 1) => [-> |].
  by rewrite injm_cyclic ?coset1_injm ?norms1 ?(negbTE ncycA).
case/trivgPn=> a Ba n1a; case/and3P=> _ sBA _.
rewrite (bigcup_max a) ?inE ?n1a ?(subsetP sBA) // setIS //=.
by rewrite -cent_set1 centS // sub1set.
Qed.

Section Focal_Subgroup.

Variables (gT : finGroupType) (G S : {group gT}) (p : nat).
Hypothesis sylS : p.-Sylow(G) S.

Import finalg FiniteModule.

(* This is B & G, Theorem 1.17 (or Gorenstein 7.3.4, Aschbacher 37.4)        *)
Theorem focal_subgroup_gen :
  S :&: G^`(1) = <<[set [~ x, u] | x <- S, u <- G, x ^ u \in S]>>.
Proof.
set K := <<_>>; set G' := G^`(1); have [sSG coSiSG] := andP (pHall_Hall sylS).
apply/eqP; rewrite eqEsubset gen_subG andbC; apply/andP; split.
  apply/subsetP=> xu; case/imset2P=> x u Sx; case/setIdP=> Gu Sxu ->{xu}.
  by rewrite inE groupM ?groupV // mem_commg // (subsetP sSG).
apply/subsetP=> g; case/setIP=> Sg G'g; have Gg := subsetP sSG g Sg.
have nKS: S \subset 'N(K).
  rewrite norms_gen //; apply/subsetP=> y Sy; rewrite inE.
  apply/subsetP=> xuy; case/imsetP=> xu; case/imset2P=> x u Sx.
  case/setIdP=> Gu Sxu ->{xu} ->{xuy}; rewrite conjRg mem_imset2 ?groupJ //.
  by rewrite inE -conjJg /= 2?groupJ // (subsetP sSG).
set alpha := restrm_morphism nKS (coset_morphism K).
have alphim: (alpha @* S) = (S / K) by rewrite morphim_restrm setIid.
have abelSK : abelian (alpha @* S).
  rewrite alphim sub_der1_abelian // genS //.
  apply/subsetP=> xy; case/imset2P=> x y Sx Sy ->{xy}.
  by rewrite mem_imset2 // inE (subsetP sSG) ?groupJ.
set ker_trans := 'ker (transfer G abelSK).
have G'ker : G' \subset ker_trans.
  rewrite gen_subG; apply/subsetP=> h; case/imset2P=> h1 h2 Gh1 Gh2 ->{h}.
  rewrite !inE groupR // morphR //; apply/commgP.
  exact: (GRing.addrC (transfer _ _ _)).
have transg0: transfer G abelSK g = 0%R.
  by move/kerP: (subsetP G'ker g G'g); apply.
case: (rcosets_pcycle_transversal_exists sSG Gg) => X n_ transX.
case: (transX)=> _ sXG _.
have gGSeq0: (fmod abelSK (alpha g) *+ #|G : S| = 0)%R.
  rewrite -transg0 (transfer_pcycle_def abelSK Gg transX).
  rewrite -(sum_card_rcosets_pcycles Gg transX).
  rewrite -GRing.sumr_muln_r /restrm.
  apply: eq_bigr=> x Xx; rewrite -[(_ *+ _)%R]morphX ?mem_morphim //=.
  rewrite -morphX //= /restrm; congr fmod.
  apply/rcoset_kercosetP; rewrite /= -/K.
  - by rewrite (subsetP nKS) ?groupX.
  - rewrite (subsetP nKS) // conjgE invgK mulgA -mem_rcoset.
    exact: mulg_exp_card_rcosets.
  rewrite mem_rcoset -{1}[g ^+ _]invgK -conjVg -commgEl mem_gen ?mem_imset2 //.
    by rewrite groupV groupX.
  rewrite inE conjVg !groupV (subsetP sXG) //= conjgE invgK mulgA -mem_rcoset.
  exact: mulg_exp_card_rcosets.
move: (congr_fmod gGSeq0).
rewrite fmval0 morphX ?inE //= fmodK ?mem_morphim // /restrm /=.
move/((congr1 (expgn^~ (expgn_inv (S / K) #|G : S|))) _).
rewrite exp1gn expgnK ?mem_quotient ?coprime_morphl // => Kg1.
by rewrite coset_idr ?(subsetP nKS).
Qed.

(* This is B & G, Theorem 1.18. *)
Theorem Burnside_normal_complement :
  'N_G(S) \subset 'C(S) -> 'O_p^'(G) ><| S = G.
Proof.
move=> cSN; set K := 'O_p^'(G); have [sSG pS _] := and3P sylS.
have [p'K]:  p^'.-group K /\ K <| G by rewrite pcore_pgroup pcore_normal.
case/andP=> sKG nKG; have{nKG} nKS := subset_trans sSG nKG.
have{pS p'K} tiKS: K :&: S = 1 by rewrite setIC coprime_TIg ?(pnat_coprime pS).
suffices{tiKS nKS} hallK: p^'.-Hall(G) K.
  rewrite sdprodE //= -/K; apply/eqP; rewrite eqEcard ?mul_subG //=.
  by rewrite TI_cardMg //= (card_Hall sylS) (card_Hall hallK) mulnC partnC.
pose G' := G^`(1); have nsG'G : G' <| G by rewrite der_normalS.
suffices{K sKG} p'G': p^'.-group G'.
  have nsG'K: G' <| K by rewrite (normalS _ sKG) ?pcore_max.
  rewrite -(pquotient_pHall p'G') -?pquotient_pcore //= -/G'.
  by rewrite nilpotent_pcore_Hall ?abelian_nil ?der_abelian.
suffices{nsG'G} tiSG': S :&: G' = 1.
  have sylG'S : p.-Sylow(G') (G' :&: S) by rewrite (pSylow_normalI _ sylS).
  rewrite /pgroup -[#|_|](partnC p) ?cardG_gt0 // -{sylG'S}(card_Hall sylG'S).
  by rewrite /= setIC tiSG' cards1 mul1n part_pnat.
apply/trivgP; rewrite /= focal_subgroup_gen ?(p_Sylow sylS) // gen_subG.
apply/subsetP=> z; case/imset2P=> x u Sx; case/setIdP=> Gu Sxu ->{z}.
have cSS: forall y, y \in S -> S \subset 'C_G[y].
  move=> y; rewrite subsetI sSG -cent_set1 centsC sub1set; apply: subsetP.
  by apply: subset_trans cSN; rewrite subsetI sSG normG.
have{cSS} [v]: exists2 v, v \in 'C_G[x ^ u | 'J] & S :=: S :^ u :^ v.
  have sylSu : p.-Sylow(G) (S :^ u) by rewrite pHallJ.
  have [sSC sCG] := (cSS _ Sxu, subsetIl G 'C[x ^ u]).
  rewrite astab1J; apply: (@Sylow_trans p); apply: pHall_subl sCG _ => //=.
  by rewrite -conjg_set1 normJ -(conjGid Gu) -conjIg conjSg cSS.
rewrite in_set1 -conjsgM; case/setIP=> Gv; move/astab1P=> cx_uv nSuv.
apply/conjg_fixP; rewrite -cx_uv /= -conjgM; apply: astabP Sx.
by rewrite astabJ (subsetP cSN) // !inE -nSuv groupM /=.
Qed.

(* This is B & G, Corollary 1.19a *)
Lemma cyclic_Sylow_tiVsub_der1 :
  cyclic S -> S :&: G^`(1) = 1 \/ S \subset G^`(1).
Proof.
move=> cycS; have [sSG pS _] := and3P sylS.
have nsSN: S <| 'N_G(S) by rewrite normalSG.
have hallSN: Hall 'N_G(S) S.
  by apply: pHall_Hall (pHall_subl _ _ sylS); rewrite ?subsetIl ?normal_sub.
case/splitsP: (SchurZassenhaus_split hallSN nsSN) => K.
case/complP=> /= tiSK defN.
have sKN: K \subset 'N_G(S) by rewrite -defN mulG_subr.
have [sKG nSK]: K \subset G /\ K \subset 'N(S) by apply/andP; rewrite -subsetI.
have coSK: coprime #|S| #|K|.
  by case/andP: hallSN => sSN; rewrite -divgS //= -defN TI_cardMg ?mulKn.
have:= coprime_abelian_cent_dprod nSK coSK (cyclic_abelian cycS).
case/(cyclic_pgroup_dprod_trivg pS cycS) => [[_ cSK]|[_ <-]]; last first.
  by right; rewrite commgSS.
have cSN: 'N_G(S) \subset 'C(S).
  by rewrite -defN mulG_subG -abelianE cyclic_abelian // centsC -cSK subsetIr.
case/sdprodP: (Burnside_normal_complement cSN) => _ /= defG _ _.
set Q := 'O_p^'(G) in defG; have nQG: G \subset 'N(Q) := bgFunc_norm _ _.
left; rewrite coprime_TIg ?(pnat_coprime pS) //.
apply: pgroupS (pcore_pgroup _ G); rewrite /= -/Q.
rewrite -quotient_sub1 ?(subset_trans (der_sub _ _)) ?quotientR //= -/Q.
rewrite -defG quotient_mulgr (sameP trivgP commG1P) -abelianE.
by rewrite morphim_abelian ?cyclic_abelian.
Qed.

End Focal_Subgroup.

(* This is B & G, Corollary 1.19b. *)
Lemma Zgroup_der1_Hall : forall gT (G : {group gT}), Zgroup G -> Hall G G^`(1).
Proof.
move=> gT G ZgG; set G' := G^`(1).
rewrite /Hall der_sub coprime_sym coprime_pi' ?cardG_gt0 //=.
apply/pgroupP=> p p_pr pG'; have [P sylP]:= Sylow_exists p G.
have cycP: cyclic P by have:= forallP ZgG P; rewrite (p_Sylow sylP).
case: (cyclic_Sylow_tiVsub_der1 sylP cycP) => [tiPG' | sPG'].
  have: p.-Sylow(G') (P :&: G').
    by rewrite setIC (pSylow_normalI _ sylP) ?bgFunc_normal.
  move/card_Hall; move/eqP; rewrite /= tiPG' cards1 eq_sym.
  by rewrite partn_eq1 ?cardG_gt0 // p'natE ?pG'.
rewrite inE /= mem_primes p_pr indexg_gt0 -?p'natE // -partn_eq1 //.
have sylPq: p.-Sylow(G / G') (P / G') by rewrite morphim_pHall ?normsG.
rewrite -card_quotient ?bgFunc_norm // -(card_Hall sylPq) -trivg_card1.
by rewrite /= -quotient_mulg mulSGid ?trivg_quotient.
Qed.

(* This is B & G, Theorem 1.20 (Maeshke's Theorem) for internal action on     *)
(* elementary abelian subgroups; a more general case, for linear              *)
(* represenations on matrices, can be found in mxrepresentation.v.            *)
Theorem Maeshke_abelem : forall gT p (G V U : {group gT}),
  p.-abelem V -> p^'.-group G -> U \subset V ->
    G \subset 'N(V) -> G \subset 'N(U) ->
  exists2 W : {group gT}, U \x W = V & G \subset 'N(W).
Proof.
move=> gT p G V U pV p'G sUV nVG nUG.
have splitU: [splits V, over U] := abelem_splits pV sUV.
case/and3P: pV => pV abV; have cUV := subset_trans sUV abV.
have sVVG := mulgen_subl V G.
have{nUG} nUVG: U <| V <*> G.
  by rewrite /(U <| _) mulgen_subG (subset_trans sUV) // cents_norm // centsC.
rewrite -{nUVG}(Gaschutz_split nUVG) ?(abelianS sUV) // in splitU; last first.
  rewrite -divgS ?mulgen_subl //= norm_mulgenEr //.
  have coVG: coprime #|V| #|G| := pnat_coprime pV p'G.
  by rewrite coprime_cardMg // mulnC mulnK // (coprimeSg sUV).
case/splitsP: splitU => WG; case/complP=> trUWG /= defVG.
exists (WG :&: V)%G.
  rewrite dprodE; last by rewrite setIA trUWG (setIidPl _) ?sub1G.
    by rewrite group_modl // defVG (setIidPr _).
  by rewrite (subset_trans cUV) ?centS ?subsetIr.
rewrite (subset_trans (mulgen_subr V _)) // -defVG mul_subG //.
   by rewrite cents_norm ?(subset_trans cUV) ?centS ?subsetIr.
rewrite normsI ?normG // (subset_trans (mulG_subr U _)) //.
by rewrite defVG mulgen_subG normG.
Qed.

Section Plength1.

Variables (gT : finGroupType) (p : nat).
Implicit Types G H : {group gT}.

(* This is B & G Lemma 1.21a. *)
Lemma plenght1S : forall G H, H \subset G -> p.-length_1 G -> p.-length_1 H.
Proof.
rewrite /plength_1 => G H sHG pG1; rewrite eqEsubset pseries_sub.
by apply: subset_trans (pseriesS _ sHG); rewrite (eqP pG1) (setIidPr _).
Qed.

Lemma plength1_quo : forall G H, p.-length_1 G -> p.-length_1 (G / H).
Proof.
rewrite /plength_1 => G H pG1; rewrite eqEsubset pseries_sub.
by rewrite -{1}(eqP pG1) morphim_pseries.
Qed.

(* This is B & G Lemma 1.21b. *)
Lemma p'quo_plength1 : forall G H,
  H <| G -> p^'.-group H -> p.-length_1 (G / H) = p.-length_1 G.
Proof.
rewrite /plength_1 => G H nHG p'H; apply/idP/idP; last exact: plength1_quo.
move=> pGH1; rewrite eqEsubset pseries_sub.
have nOG: 'O_{p^'}(G) <| G by exact: pseries_normal.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _]) //.
have [|f f_inj im_f] := third_isom _ nHG nOG.
  by rewrite /= pseries1 pcore_max.
rewrite (quotient_pseries_cat [:: _]) -{}im_f //=.
rewrite -bgFunc_ascont; try by move: pseries_cont pseries_sub.
rewrite {f f_inj}morphimS // pseries1 -pquotient_pcore // -pseries1 /=.
by rewrite -quotient_pseries_cat /= (eqP pGH1).
Qed.

(* This is B & G Lemma 1.21c. *)
Lemma pquo_plength1 : forall G H,
    H <| G -> p.-group H -> 'O_p^'(G / H) = 1->
  p.-length_1 (G / H) = p.-length_1 G.
Proof.
rewrite /plength_1 => G H nHG pH trO; apply/idP/idP; last exact: plength1_quo.
rewrite (pseries_pop _ trO) => pGH1; rewrite eqEsubset pseries_sub /=.
rewrite pseries_pop //; last first.
  apply/eqP; rewrite -subG1; have <-: H :&: 'O_p^'(G) = 1.
    by apply: coprime_TIg; exact: pnat_coprime (pcore_pgroup _ _).
  rewrite setIC subsetI subxx -quotient_sub1.
    by rewrite -trO morphim_pcore.
  apply: subset_trans (normal_norm nHG); exact: pcore_sub.
have nOG: 'O_{p}(G) <| G by exact: pseries_normal.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _]) //.
have [|f f_inj im_f] := third_isom _ nHG nOG.
  by rewrite /= pseries1 pcore_max.
rewrite (quotient_pseries [::_]) -{}im_f //=.
rewrite -bgFunc_ascont; try by move: pcore_cont pcore_sub.
rewrite {f f_inj}morphimS // pseries1 -pquotient_pcore // -(pseries1 p) /=.
by rewrite -quotient_pseries /= (eqP pGH1).
Qed.

(* An elementary converse to B & G, Lemma 1.21d   *)
Lemma plenght1_pSylow : forall G,
  p.-length_1 G -> p.-Sylow(G / 'O_p^'(G)) 'O_p(G / 'O_p^'(G)).
Proof.
move=> G; move/(_ :=P: G) => defG; set K := 'O_p^'(G); set P := 'O_p(G / K).
rewrite -(pquotient_pHall _ _ (normal_refl _)) ?pcore_normal ?pcore_pgroup //=.
rewrite trivg_quotient pHallE sub1G cards1 part_p'nat //= -/P -/K -defG {}/P.
rewrite -[K]pseries1 (quotient_pseries_cat [:: _]) quotient_pseries2.
exact: pcore_pgroup.
Qed.

Canonical Structure p_elt_gen_group A : {group gT} :=
  Eval hnf in [group of p_elt_gen p A].

(* Note that p_elt_gen could be a functor. *)
Lemma p_elt_gen_normal : forall G, p_elt_gen p G <| G.
Proof.
move=> G; apply/normalP; split=> [|x Gx].
  by rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP.
rewrite -genJ; congr <<_>>; apply/setP=> y; rewrite mem_conjg !inE.
by rewrite p_eltJ -mem_conjg conjGid.
Qed.

Hypothesis pr_p : prime p.

(* This is B & G Lemma 1.21d. *)
Lemma p_elt_gen_length1 : forall G,
  p.-length_1 G = p^'.-Hall(p_elt_gen p G) 'O_p^'(p_elt_gen p G).
Proof.
move=> G; rewrite /pHall pcore_sub pcore_pgroup pnatNK /= /plength_1.
have nUG := p_elt_gen_normal G; have [sUG nnUG]:= andP nUG.
apply/idP/idP=> [p1G | pU].
  apply: (@pnat_dvd _ #|p_elt_gen p G : 'O_p^'(G)|).
    by rewrite -[#|_ : 'O_p^'(G)|]indexgI indexgS ?pcoreS.
  apply: (@pnat_dvd _ #|'O_p(G / 'O_{p^'}(G))|); last exact: pcore_pgroup.
  rewrite -card_quotient; last first.
    by rewrite (subset_trans sUG) // normal_norm ?pcore_normal.
  rewrite -quotient_pseries pseries1 cardSg ?morphimS //=.
  rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP=> Gx p_x.
  have nOx: x \in 'N('O_{p^',p}(G)).
    by apply: subsetP Gx; rewrite normal_norm ?pseries_normal.
  rewrite coset_idr //; apply/eqP; rewrite -[coset _ x]expg1 -order_dvdn.
  rewrite [#[_]](@pnat_1 p) //; first exact: morph_p_elt.
  apply: mem_p_elt (pcore_pgroup _ (G / _)) _.
  by rewrite /= -quotient_pseries /= (eqP p1G); apply/morphimP; exists x.
have nOG: 'O_{p^', p}(G) <| G by exact: pseries_normal.
rewrite eqEsubset pseries_sub.
rewrite -(quotientSGK (normal_norm nOG)) ?(pseries_sub_catl [:: _; _]) //=.
rewrite (quotient_pseries [::_;_]) pcore_max //.
rewrite /pgroup card_quotient ?normal_norm //.
apply: (@pnat_dvd _ #|G : p_elt_gen p G|); last first.
  rewrite -card_quotient // p'natE //; apply/negP; case/Cauchy=> // Ux.
  case/morphimP=> x Nx Gx -> /= oUx_p; have:= prime_gt1 pr_p.
  rewrite -(part_pnat_id (pnat_id pr_p)) -{1}oUx_p {oUx_p} -order_constt.
  rewrite -morph_constt //= coset_id ?order1 //.
  by rewrite mem_gen // inE groupX // p_elt_constt.
apply: indexgS.
have nOU: p_elt_gen p G \subset 'N('O_{p^'}(G)).
  by rewrite (subset_trans sUG) // normal_norm ?pseries_normal.
rewrite -(quotientSGK nOU) ?(pseries_sub_catl [:: _]) //=.
rewrite (quotient_pseries [::_]) pcore_max ?morphim_normal //.
rewrite /pgroup card_quotient //= pseries1; apply: pnat_dvd pU.
apply: indexgS; rewrite pcore_max ?pcore_pgroup //.
apply: char_normal_trans nUG; exact: pcore_char.
Qed.

End Plength1.

(* This is B & G, Lemma 1.21e. *)
Lemma quo2_plength1 : forall gT p (G H K : {group gT}),
  prime p -> H <| G -> K <| G -> H :&: K = 1 ->
     p.-length_1 (G / H) && p.-length_1 (G / K) = p.-length_1 G.
Proof.
move=> gT p G H K pr_p nHG nKG trHK.
apply/andP/idP=> [[pH1 pK1] | pG1]; last by rewrite !plength1_quo.
pose U := p_elt_gen p G; have nU : U <| G by exact: p_elt_gen_normal.
have exB: forall N : {group gT},
   N <| G -> p.-length_1 (G / N) ->
     exists B : {group gT},
       [/\ U \subset 'N(B),
           forall x, x \in B -> #[x] = p -> x \in N
         & forall Q : {group gT}, p^'.-subgroup(U) Q -> Q \subset B].
- move=> N nNG; have [sNG nnNG] := andP nNG.
  rewrite p_elt_gen_length1 // (_ : p_elt_gen _ _ = U / N); last first.
    rewrite /quotient morphim_gen -?quotientE //; last first.
      by apply/subsetP=> x; rewrite inE; case/andP; move/(subsetP nnNG).
    congr <<_>>; apply/setP=> Nx; rewrite inE.
    apply/andP/morphimP=> [[]|[x NNx]].
      case/morphimP=> x NNx Gx ->{Nx} pNx.
      exists x.`_p; first exact: groupX.
        by rewrite inE p_elt_constt groupX.
      by rewrite morph_constt // constt_p_elt.
    rewrite inE; case/andP=> Gx p_x ->{Nx}.
    by rewrite morph_p_elt // -sub1set -morphim_set1 // morphimS ?sub1set.
  have nNU: U \subset 'N(N) := subset_trans (normal_sub nU) nnNG.
  have nN_UN: U <*> N \subset 'N(N) by rewrite gen_subG subUset normG nNU.
  case/(inv_quotientN _): (pcore_normal p^' [group of U <*> N / N]) => /= [|B].
    by rewrite /normal sub_gen ?subsetUr.
  rewrite /= quotient_mulgen //= /U => defB sNB; case/andP=> sB nB hallB.
  exists B; split=> [|x Ux p_x|Q].
  - by rewrite (subset_trans (sub_gen _) nB) ?subsetUl.
  - have nNx: x \in 'N(N) by rewrite (subsetP nN_UN) ?(subsetP sB).
    apply: coset_idr => //; rewrite -[coset N x](consttC p).
    rewrite !(constt1P _) ?mulg1 // ?p_eltNK.
      by rewrite morph_p_elt // /p_elt p_x pnat_id.
    have: coset N x \in B / N by apply/morphimP; exists x.
    by apply: mem_p_elt; rewrite /= -defB pcore_pgroup.
  case/andP=> sQU p'Q; rewrite -(quotientSGK (subset_trans sQU nNU) sNB).
  rewrite -defB (subset_normal_Hall _ hallB) ?pcore_normal //=.
  by rewrite /psubgroup morphimS ?morphim_pgroup.
have{pH1} [A [nAU pA p'A]] := exB H nHG pH1.
have{pK1 exB} [B [nBU pB p'B]] := exB K nKG pK1.
rewrite p_elt_gen_length1 //; apply: normal_max_pgroup_Hall (pcore_normal _ _).
apply/maxgroupP; split; first by rewrite /psubgroup pcore_sub pcore_pgroup.
move=> Q p'Q sOQ; apply/eqP; rewrite eqEsubset sOQ andbT.
apply: subset_trans (_ : U :&: (A :&: B) \subset _); last rewrite /U.
  by rewrite !subsetI p'A ?p'B //; case/andP: p'Q => ->.
apply: pcore_max; last by rewrite /normal subsetIl !normsI ?normG.
rewrite /pgroup p'natE //; apply/negP; case/Cauchy=> // x.
case/setIP=> _; case/setIP=> Ax Bx oxp.
suff: x \in 1%G by move/set1P=> x1; rewrite -oxp x1 order1 in pr_p.
by rewrite /= -trHK inE pA ?pB.
Qed.

(* B & G Lemma 1.22 is covered by sylow.normal_pgroup. *)

Require Import zmodp.

Lemma logn_quotient_cent_abelem : forall gT p (A E : {group gT}),
    A \subset 'N(E) -> p.-abelem E -> logn p #|E| <= 2 ->
  logn p #|A : 'C_A(E)| <= 1.
Proof.
move=> gT p A E nEA abelE maxdimE; case: (eqsVneq E 1) => [-> | ntE].
  by rewrite (setIidPl (cents1 _)) indexgg logn1.
pose rP := abelem_repr abelE ntE nEA.
have [p_pr _ _] := pgroup_pdiv (abelem_pgroup abelE) ntE.
have ->: 'C_A(E) = 'ker (reprGLm rP) by rewrite ker_reprGLm rker_abelem.
rewrite -card_quotient ?ker_norm // (isog_card (first_isog _)).
apply: leq_trans (dvdn_leq_log _ _ (cardSg (subsetT _))) _ => //.
rewrite logn_card_GL_p ?(dim_abelemE abelE) //.
by case: logn maxdimE; do 2?case.
Qed.

End BGsection1.

Section PuigSeriesGroups.

Implicit Type gT : finGroupType.

Canonical Structure Puig_succ_group gT (D E : {set gT}) := [group of 'L_[D](E)].

Lemma Puig_at_group_set : forall n gT D, @group_set gT 'L_{n}(D).
Proof. case=> [|n] gT G; exact: groupP. Qed.

Canonical Structure Puig_at_group n gT D := Group (@Puig_at_group_set n gT D).
Canonical Structure Puig_inf_group gT (D : {set gT}) := [group of 'L_*(D)].
Canonical Structure Puig_group gT (D : {set gT}) := [group of 'L(D)].

End PuigSeriesGroups.

Notation "''L_[' G ] ( L )" := (Puig_succ_group G L) : subgroup_scope.
Notation "''L_{' n } ( G )" := (Puig_at_group n G)
  (at level 8, format "''L_{' n } ( G )") : subgroup_scope.
Notation "''L_*' ( G )" := (Puig_inf_group G) : subgroup_scope.
Notation "''L' ( G )" := (Puig_group G) : subgroup_scope.

(* Elementary properties of the Puig series. *)
Section PuigBasics.

Variable gT : finGroupType.
Implicit Types D E : {set gT}.
Implicit Types G H : {group gT}.

Lemma Puig0 : forall D, 'L_{0}(D) = 1. Proof. by []. Qed.
Lemma PuigS : forall n D, 'L_{n.+1}(D) = 'L_[D]('L_{n}(D)). Proof. by []. Qed.
Lemma Puig_recE : forall n D, Puig_rec n D = 'L_{n}(D). Proof. by []. Qed.
Lemma Puig_def : forall D, 'L(D) = 'L_[D]('L_*(D)). Proof. by []. Qed.

Local Notation "D --> E" := (generated_by (norm_abelian D) E)
  (at level 70, no associativity) : group_scope.

Lemma Puig_gen : forall D E, E --> 'L_[D](E).
Proof. by move=> D E; apply/existsP; exists (subgroups D). Qed.

Lemma Puig_max : forall G D E,
  D --> E -> E \subset G -> E \subset 'L_[G](D).
Proof.
move=> G D E; case/existsP=> gE; move/eqP=> <-{E}; rewrite !gen_subG.
move/bigcupsP=> sEG; apply/bigcupsP=> A gEA; have [_ abnA]:= andP gEA.
by rewrite sub_gen // bigcup_sup // inE sEG.
Qed.

Lemma norm_abgenS : forall D1 D2 E, D1 \subset D2 -> D2 --> E -> D1 --> E.
Proof.
move=> D1 D2 E sD12; case/existsP=> gE; move/eqP=> <-{E}.
apply/existsP; exists [set A \in gE | norm_abelian D2 A].
apply/eqP; congr <<_>>; apply: eq_bigl => A; rewrite !inE.
case: (@andP (A \in _)) => //= [] [_]; case/andP=> nAD cAA.
by apply/andP; rewrite (subset_trans sD12).
Qed.

Lemma Puig_succ_sub : forall G D, 'L_[G](D) \subset G.
Proof.
by move=> G D; rewrite gen_subG; apply/bigcupsP=> A; case/andP; rewrite inE.
Qed.

Lemma Puig_at_sub : forall n G, 'L_{n}(G) \subset G.
Proof. by case=> [|n] G; rewrite ?sub1G ?Puig_succ_sub. Qed.

Lemma Puig_inf_sub : forall G, 'L_*(G) \subset G.
Proof. move=> G; exact: Puig_at_sub. Qed.

Lemma Puig_sub : forall G, 'L(G) \subset G.
Proof. move=> G; exact: Puig_at_sub. Qed.

Lemma Puig1 : forall G, 'L_{1}(G) = G.
Proof.
move=> G; apply/eqP; rewrite eqEsubset Puig_at_sub.
apply/subsetP=> x Gx; rewrite -cycle_subG sub_gen //.
rewrite -[<[x]>]/(gval _) bigcup_sup //= inE cycle_subG Gx /= /norm_abelian.
by rewrite cycle_abelian sub1G.
Qed.

End PuigBasics.

(* Functoriality of the Puig series. *)

Lemma Puig_at_cont : forall n, acont (Puig_at n).
Proof.
elim=> [|n IHn] aT rT G f injf; first by rewrite morphim1.
have IHnS := Puig_at_sub n; pose func_n := [bgFunc by IHnS & !IHn].
rewrite !PuigS sub_morphim_pre ?Puig_succ_sub // gen_subG; apply/bigcupsP=> A.
rewrite inE; case/and3P=> sAG nAL cAA; rewrite -sub_morphim_pre ?sub_gen //.
rewrite -[f @* A]/(gval _) bigcup_sup // inE morphimS // /norm_abelian.
rewrite morphim_abelian // -['L_{n}(_)](bgFunc_ascont func_n injf) //=.
by rewrite morphim_norms.
Qed.

Canonical Structure bgFunc_Puig_at n :=
  [bgFunc by (@Puig_at_sub)^~ n & ! @Puig_at_cont n].

Lemma Puig_inf_cont : acont Puig_inf.
Proof.
by move=> aT rT G f injf; rewrite /Puig_inf card_injm // Puig_at_cont.
Qed.

Canonical Structure bgFunc_Puig_inf :=
  [bgFunc by Puig_inf_sub & !Puig_inf_cont].

Lemma Puig_cont : acont Puig.
Proof. by move=> aT rT G f injf; rewrite /Puig card_injm // Puig_at_cont. Qed.

Canonical Structure bgFunc_Puig := [bgFunc by Puig_sub & !Puig_cont].
