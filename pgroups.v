Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype paths finfun ssralg bigops finset prime.
Require Import groups action morphisms group_perm automorphism normal cyclic.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GroupScope.

(*****************************************************************************)
(* Standard group notions and constructions based on the prime decomposition *)
(* of the order of the group or its elements.                                *)
(*   pi.-group G      <=> G is a pi-group                                    *)
(*                    <-> pi.-nat #|G|                                       *)
(*     + Recall that here and in the sequel pi can be a prime p              *)
(*   pi.-subgroup(H) G   <=> H is a pi-subgroup of G                         *)
(*                    <-> (H \subset G) && pi.-group H                       *)
(*     + This is provided mostly as a shorhand, with few associated lemmas.  *)
(*     + However, we do establish some results on maximal pi-subgroups.      *)
(*   pi.-elt x        <=> x is a pi-element                                  *)
(*                    <-> pi.-nat #[x] (<-> pi.-group <[x]>)                 *)
(*   x.`_pi           == the pi-componet of x: the only pi-element           *)
(*                       y \in <[x]> s.t. x * y^-1 is a pi'-element          *)
(*   pi.-Hall(G) H    <=> H is a Hall pi-subgroup of G                       *)
(*                    <-> [&& H \subset G, pi.-group H & pi^'.-nat #|G : H|] *)
(*                     -> #|H| = #|G|`_pi                                    *)
(*   p.-Sylow(G) P    <=> P is a Sylow p-subgroup of G                       *)
(*                    <-> p.-Hall(G) P                                       *)
(*     + This is only a display notation; note that due to an ugly display   *)
(*       engine bug, Coq will fail to use the notation under a coercion such *)
(*       as is_true, and will display p.-Hall(G) P instead.                  *)
(*   'Syl_p(G)        == the set of the p-Sylow subgroups of G               *)
(*                    := [set P : {group _} | p.-Sylow(G) P]                 *)
(*   p_group P        <=> P is a p-group for some prime p                    *)
(*                    <-> (pdiv #|P|).-group P                               *)
(*   Hall G H         <=> P is a Hall pi-subgroup of G for some pi           *)
(*                    <-> coprime #|H| #|G : H| && (H \subset G)             *)
(*   Sylow G P        <=> P is a Sylow p-subgroup of G for some p            *)
(*                    <-> p_group P && Hall G P                              *)
(*   'O_pi(G)         == the pi-core of G                                    *)
(*                    := the largest normal pi-subgroup of G                 *)
(*   'O_{pi2, pi1}(G) == the pi1,pi2-core of G                               *)
(*                    := the pi1-core of G mod 'O_pi2(G)                     *)
(*     + We have 'O_{pi2, pi1}(G) / 'O_pi2(G) = 'O_pi1(G / 'O_pi2(G))        *)
(*          with 'O_pi2(G) <| 'O_{pi2, pi1}(G) <| G                          *)
(*   'O_{pn, ..., p1}(G) == the p1, ..., pn-core of G, more generally        *)
(*                    := the p1-core of G mod 'O_{pn, ..., p2}(G)            *)
(*   p.-length_1 G    <=> G has p-length 1, as per B&G p.2                   *)
(*                    <-> 'O_{p^', p, p^'}(G) == G                           *)
(*   'Ohm_n(P)        == if P is a p-group, the group generated by the x of  *)
(*                       order at most p ^ n in P; else, if ~~ p_group P, 1  *)
(*   'Mho^n(P)        == if P is a p-group, the group generated by all the   *)
(*                       x ^+ (p ^ n) for x in P; else, if ~~ p_group P, 1   *)
(*   exponent G       == the exponent of G                                   *)
(*                    := \big[lcmn/1]_(x \in G) #[x]                         *)
(*   abelem E         <=> E is elementary abelian                            *)
(*                    <-> abelian E && (exponent E).-group E                 *)
(*   p.-abelem E      <=> E is an elementary abelian p-group                 *)
(*                    <-> abelem E && p.-group E                             *)
(*                    <-> abelian E && (exponent E %| p) if p is a prime     *)
(*   'E_p(G)          == the set of p-abelem subgroups of G                  *)
(*                    := [set E : {group _} | p.-abelem E && (E \subset G)]  *)
(*   'm_p(G)          == the p-rank of G                                     *)
(*                    := \max_(E \in 'E_p(G)) logn p #|E|                    *)
(*   'm(G)            == the rank of G                                       *)
(*                    := \max_(0 <= p < #|G|.+1) 'm_p(G)                     *)
(*   'E_p^n(G)        == the set of rank n p-abelem subgroups of G           *)
(*                    := [set E \in 'E_p(G) | logn p #|E| == n]              *)
(*                    := [set E \in 'E_p(G) | #|E| == p ^ n]%N if prime p    *)
(*   'E_p^*(G)        == the set of maximal p-abelem subgroups of G          *)
(*                    := [set E | [max E | E \in 'E_p(G)]]                   *)
(*   'E^n(G)          == the set of rank n abelem subgroups of G             *)
(*                    := \bigcup_(0 <= p < #|G|.+1) 'E_p^n(G)                *)
(* NOT YET SUPPORTED/TESTED, MAY BE DEFERRED TO ABELIAN:                     *)
(*   basis A X        <=> X is a basis for the abelian group A               *)
(*                    <-> [/\ <<X>> = A, 1 \notin X                          *)
(*                          & forall x \in X, <[x]> :&: <<X :\ x>> = 1]      *)
(*   abel_type P      == the abelian type of an abelian p-group P            *)
(*                    := the sorted seq of #[x], x in some basis X of P      *)
(*   homocyclic P     <=> P is a homocyclic abelian p-group                  *)
(*                    <-> constant (abel_type P)                             *)
(* Note that notions are always defined on sets even though their name       *)
(* indicates "group" properties; the actual definition of the notion never   *)
(* tests for the group property, since this property will always be          *)
(* provided by a (canonical) group structure. Similarly, p-group properties  *)
(* assume without test that p is a prime.                                    *)
(*****************************************************************************)

Section PgroupDefs.

(* We defer the definition of the functors ('0_p(G), etc) because they need *)
(* to quantify over the finGroupType explicitly.                            *)

Variable gT : finGroupType.
Implicit Type x : gT.
Implicit Types A B : {set gT}.
Implicit Type pi : nat_pred.
Implicit Types p n : nat.

Definition pgroup pi A := pi.-nat #|A|.

Definition psubgroup pi A B := (B \subset A) && pgroup pi B.

Definition p_group A := pgroup (pdiv #|A|) A.

Definition p_elt pi x := pi.-nat #[x].

Definition compg x pi := x ^+ (chinese #[x]`_pi #[x]`_pi^' 1 0).

Definition Hall A B := (B \subset A) && coprime #|B| #|A : B|.

Definition pHall pi A B := [&& B \subset A, pgroup pi B & pi^'.-nat #|A : B|].

Definition Syl p A := [set P : {group gT} | pHall p A P].

Definition Sylow A B := p_group B && Hall A B.

Definition exponent A := \big[lcmn/1%N]_(x \in A) #[x].

Definition abelem A := abelian A && pgroup (exponent A) A.

Definition p_abelem p A := abelem A && pgroup p A.

Definition pElem p A := [set E : {group gT} | (E \subset A) && p_abelem p E].

Definition pnElem p n A := [set E \in pElem p A | logn p #|E| == n].

Definition nElem n A :=  \bigcup_(0 <= p < #|A|.+1) pnElem p n A.

Definition pmaxElem p A := [set E | [max E | (E \subset A) && p_abelem p E]].

Definition p_rank p A := \max_(E \in pElem p A) logn p #|E|.

Definition rank A := \max_(0 <= p < #|A|.+1) p_rank p A.

Definition basis A X :=
  [&& <<X>> == A, 1 \notin X
    & forallb x, (x \in X) ==> trivg (<[x]> :&: <<X :\ x>>)].

Definition abel_type A :=
  if pick (basis A) is Some X then
    sort leq (maps order (enum (mem X)))
  else [::].

Definition homocyclic A := [&& abelian A, p_group A & constant (abel_type A)].

End PgroupDefs.

Prenex Implicits p_group Hall Sylow exponent abelem rank.
Prenex Implicits basis abel_type homocyclic.

Notation "pi .-group" := (pgroup pi)
  (at level 2, format "pi .-group") : group_scope.

Notation "pi .-subgroup ( A )" := (psubgroup pi A)
  (at level 8, format "pi .-subgroup ( A )") : group_scope.

Notation "pi .-elt" := (p_elt pi)
  (at level 2, format "pi .-elt") : group_scope.

Notation "x .`_ pi" := (compg x pi)
  (at level 3, format "x .`_ pi") : group_scope.

Notation "pi .-Hall ( G )" := (pHall pi G)
  (at level 8, format "pi .-Hall ( G )") : group_scope.

Notation "p .-Sylow ( G )" := (nat_pred_of_nat p).-Hall(G)
  (at level 8, format "p .-Sylow ( G )") : group_scope.

Notation "''Syl_' p ( G )" := (Syl p G)
  (at level 8, p at level 2, format "''Syl_' p ( G )") : group_scope.

Notation "p .-abelem" := (p_abelem p)
  (at level 2, format "p .-abelem") : group_scope.

Notation "''E_' p ( G )" := (pElem p G)
  (at level 8, p at level 2, format "''E_' p ( G )") : group_scope.

Notation "''E_' p ^ n ( G )" := (pnElem p n G)
  (at level 8, p, n at level 2, format "''E_' p ^ n ( G )") : group_scope.

Notation "''E' ^ n ( G )" := (nElem n G)
  (at level 8, n at level 2, format "''E' ^ n ( G )") : group_scope.

Notation "''E_' p ^* ( G )" := (pmaxElem p G)
  (at level 8, p at level 2, format "''E_' p ^* ( G )") : group_scope.

Section PgroupProps.

Variable gT : finGroupType.
Implicit Type pi : nat_pred.
Implicit Type p : nat.
Implicit Types x y z : gT.
Implicit Types A B C D : {set gT}.
Implicit Types G H K P Q : {group gT}.

Lemma pgroupP : forall pi G,
  reflect (forall p, prime p -> p %| #|G| -> p \in pi) (pi.-group G).
Proof. move=> pi G; exact: pnatP. Qed.

Lemma pgroup1 : forall pi, pi.-group (1 : {set gT}).
Proof. by move=> pi; rewrite /pgroup cards1. Qed.

Lemma pgroupS : forall pi G H, H \subset G -> pi.-group G -> pi.-group H.
Proof. move=> pi G H sHG; exact: pnat_dvd (group_dvdn sHG). Qed.

Lemma pgroupM : forall pi G H, pi.-group (G * H) = pi.-group G && pi.-group H.
Proof.
move=> pi G H; have GH_pos: 0 < #|G :&: H| := ltn_0group _.
rewrite /pgroup -(divn_mull #|_| GH_pos) card_mulG -(LaGrangeI G H) -mulnA.
by rewrite divn_mulr // -(LaGrangeI H G) setIC !pnat_mul andbCA; case pnat.
Qed.

Lemma pgroupJ : forall pi G x, pi.-group (G :^ x) = pi.-group G.
Proof. by move=> pi G x; rewrite /pgroup card_conjg. Qed.

Lemma pgroup_p : forall p P, p.-group P -> p_group P.
Proof.
move=> p P pgP; case: (leqP #|P| 1).
  rewrite -trivg_card; move/trivgP->; exact: pgroup1.
move/prime_pdiv=> pr_q; have:= pgroupP _ _ pgP _ pr_q (dvdn_pdiv _).
by rewrite /p_group; move/eqnP->.
Qed.

Lemma p_groupP : forall P, p_group P -> exists2 p, prime p & p.-group P.
Proof.
move=> P; case: (ltnP 1 #|P|); first by move/prime_pdiv; exists (pdiv #|P|).
rewrite -trivg_card; move/trivgP=> -> _; exists 2 => //; exact: pgroup1.
Qed.

Lemma card_Hall : forall pi G H, pi.-Hall(G) H -> #|H| = #|G|`_pi.
Proof.
move=> pi G H; case/and3P=> sHG piH pi'H.
by rewrite -(LaGrange sHG) partn_mul ?LaGrange // part_pnat ?part_p'nat ?muln1.
Qed.

Lemma pHall_subset : forall pi A B, pi.-Hall(A) B -> B \subset A.
Proof. by move=> pi A B; case/andP. Qed.

Lemma pHall_pgroup : forall pi A B, pi.-Hall(A) B -> pi.-group B.
Proof. by move=> pi A B; case/and3P. Qed.

Lemma pHallP : forall pi G H,
  reflect (H \subset G /\ #|H| = #|G|`_pi) (pi.-Hall(G) H). 
Proof.
move=> pi G H; apply: (iffP idP) => [piH | [sHG oH]].
  split; [exact: pHall_subset piH | exact: card_Hall].
rewrite /pHall sHG -group_divn // /pgroup oH.
by rewrite -{2}(@partnC pi #|G|) ?divn_mulr ?pnat_part.
Qed.

Lemma pHallE : forall pi G H,
  pi.-Hall(G) H = (H \subset G) && (#|H| == #|G|`_pi).
Proof. by move=> pi G H; apply/pHallP/andP=> [] [->]; move/eqP. Qed.

Lemma pHall_Hall : forall pi A B, pi.-Hall(A) B -> Hall A B.
Proof.
move=> pi A B; case/and3P=> sBA piB pi'B.
by rewrite /Hall sBA (pnat_coprime piB).
Qed.

Lemma Hall_pi : forall G H, Hall G H -> \pi(#|H|).-Hall(G) H.
Proof.
move=> G H; case/andP=> sHG coHG.
by rewrite /pHall sHG /pgroup pnat_pi -?coprime_pi'.
Qed.

Lemma HallP : forall G H, Hall G H -> exists pi, pi.-Hall(G) H.
Proof. move=> G H HallH; exists \pi(#|H|); exact: Hall_pi. Qed.

Lemma pHallJ : forall pi G H x,
  x \in G -> pi.-Hall(G) (H :^ x) = pi.-Hall(G) H.
Proof.
by move=> pi G H x Gx; rewrite !pHallE card_conjg -{1}(conjGid Gx) conjSg.
Qed.

Lemma HallJ : forall G H x, x \in G -> Hall G (H :^ x) = Hall G H.
Proof.
move=> G H x Gx; rewrite /Hall -!group_divnI.
by rewrite -{1 3}(conjGid Gx) conjSg -conjIg !card_conjg.
Qed.

Lemma psubgroupJ : forall pi G H x,
  x \in G -> pi.-subgroup(G) (H :^ x) = pi.-subgroup(G) H.
Proof.
by move=> pi G H x Gx; rewrite /psubgroup pgroupJ -{1}(conjGid Gx) conjSg.
Qed.

Lemma p_groupJ : forall P x, p_group (P :^ x) = p_group P.
Proof. by move=> P x; rewrite /p_group card_conjg pgroupJ. Qed.

Lemma SylowJ : forall G P x, x \in G -> Sylow G (P :^ x) = Sylow G P.
Proof. by move=> G P x Gx; rewrite /Sylow p_groupJ HallJ. Qed.

Lemma p_Sylow : forall p G P, p.-Sylow(G) P -> Sylow G P.
Proof.
move=> p G P pP.
by rewrite /Sylow (pgroup_p (pHall_pgroup pP)) (pHall_Hall pP).
Qed.

Lemma Hall1 : forall G, Hall G 1.
Proof. by move=> G; rewrite /Hall sub1G cards1 coprime1n. Qed.

Lemma p_group1 : @p_group gT 1.
Proof. by rewrite (@pgroup_p 2) ?pgroup1. Qed.

Lemma Sylow1 : forall G, Sylow G 1.
Proof. by move=> G; rewrite /Sylow p_group1 Hall1. Qed.

Lemma eq_pHall : forall pi1 pi2 A B,
  pi1 =i pi2 -> pi1.-Hall(A) B = pi2.-Hall(A) B.
Proof.
move=> pi1 pi2 A B eq_pi; congr [&& _, _ & _]; apply: eq_pnat => // q.
congr (~~ _); exact: eq_pi.
Qed.

Lemma SylowP : forall G P,
  reflect (exists2 p, prime p & p.-Sylow(G) P) (Sylow G P).
Proof.
move=> G P; apply: (iffP idP) => [| [p _]]; last exact: p_Sylow.
case/andP; case/p_groupP=> p p_pr; case/p_natP=> // [[P1 _ | n oP]].
  have{p p_pr P1} ->: P = 1%G by apply/trivGP; rewrite trivg_card P1.
  pose p := pdiv #|G|.+1; have pr_p: prime p by rewrite prime_pdiv ?ltnS.
  exists p; rewrite // pHallE sub1G cards1 part_p'nat //.
  apply/pgroupP=> q pr_q qG; apply/eqnP=> def_q.
  have: p %| #|G| + 1 by rewrite addn1 dvdn_pdiv.
  by rewrite dvdn_addr -def_q // euclid1.
move/Hall_pi; rewrite oP pi_of_exp // (eq_pHall _ _ (pi_of_prime _)) //.
by exists p.
Qed.

Lemma p_elt_exp : forall pi x m, pi.-elt (x ^+ m) = (#[x]`_pi^' %| m).
Proof.
move=> pi x m; apply/idP/idP=> [pi_xm|].
  rewrite -(@gauss _ #[x ^+ m]); last first.
    by rewrite coprime_sym (pnat_coprime pi_xm) ?pnat_part.
  apply: (@dvdn_trans #[x]); first by rewrite -{2}[#[x]](partnC pi) ?dvdn_mull.
  by rewrite order_dvd mulnC expgn_mul order_expn1.
case/dvdnP=> q ->{m}; rewrite mulnC; apply: pnat_dvd (pnat_part pi #[x]).
by rewrite order_dvd -expgn_mul mulnC mulnA partnC // -order_dvd dvdn_mulr.
Qed.

Lemma mem_p_elt : forall pi x G, pi.-group G -> x \in G -> pi.-elt x.
Proof. by move=>pi x G piG Gx; apply: pgroupS piG; rewrite cycle_h. Qed.

Lemma p_eltM_norm : forall pi x y, x \in 'N(<[y]>) ->
  pi.-elt x -> pi.-elt y -> pi.-elt (x * y).
Proof.
move=> pi x y nyx pi_x pi_y; apply: (@mem_p_elt pi _ (<[x]> <*> <[y]>)%G).
  rewrite /= norm_mulgenE ?cycle_h // pgroupM; exact/andP.
by rewrite groupM // mem_gen // inE cyclenn ?orbT.
Qed.

Lemma p_eltM :  forall pi x y, commute x y ->
  pi.-elt x -> pi.-elt y -> pi.-elt (x * y).
Proof.
move=> pi x y cxy; apply: p_eltM_norm; apply: (subsetP (cent_subset _)).
rewrite cent_gen cent_set1; exact/cent1P.
Qed.

Lemma p_elt1 : forall pi, pi.-elt (1 : gT).
Proof. by move=> pi; rewrite /p_elt order1. Qed.

Lemma p_eltV : forall pi x, pi.-elt x^-1 = pi.-elt x.
Proof. by move=> pi x; rewrite /p_elt orderV. Qed.

Lemma p_eltX : forall pi x n, pi.-elt x -> pi.-elt (x ^+ n).
Proof.
by move=> pi x n; rewrite -{1}[x]expg1 !p_elt_exp dvdn1; move/eqnP->.
Qed.

Lemma p_eltJ : forall pi x y, pi.-elt (x ^ y) = pi.-elt x.
Proof. by move=> pi x y; congr pnat; rewrite orderJ. Qed.

Lemma sub_p_elt : forall pi1 pi2 x,
  {subset pi1 <= pi2} -> pi1.-elt x -> pi2.-elt x.
Proof. move=> pi1 pi2 x pi12; apply: subd_pnat => q _; exact: pi12. Qed.

Lemma eq_p_elt : forall pi1 pi2 x, pi1 =i pi2 -> pi1.-elt x = pi2.-elt x.
Proof. move=> pi1 pi2 x pi12; exact: eq_pnat. Qed.

Lemma p_eltNK : forall pi x, pi^'^'.-elt x = pi.-elt x.
Proof. move=> pi x; exact: pnatNK. Qed.

Lemma eq_expg_mod_order : forall x m n,
  (x ^+ m == x ^+ n) = (m %% #[x] == n %% #[x]).
Proof.
move=> x m n; wlog le_nm: m n / n <= m.
  by move=> IH; case/orP: (leq_total m n); move/IH; rewrite // eq_sym => ->.
rewrite eqn_mod_dvd // -{1}(subnK le_nm) expgn_add.
by rewrite (can2_eq (mulKg _) (mulKVg _)) mulVg order_dvd.
Qed.

Lemma eq_compg : forall pi1 pi2 x, pi1 =i pi2 -> x.`_pi1 = x.`_pi2.
Proof.
move=> pi1 pi2 x pi12; congr (x ^+ (chinese _ _ 1 0)); apply: eq_partn => //.
move=> q; congr (~~ _); exact: pi12.
Qed.

Lemma compgNK : forall pi x, x.`_pi^'^' = x.`_pi.
Proof. by move=> pi x; rewrite /compg !partnNK. Qed.

Lemma cycle_comp : forall pi (x : gT), x.`_pi \in <[x]>.
Proof. move=> pi x; exact: cycle_in. Qed.

Lemma compVg : forall pi x, (x^-1).`_pi = (x.`_pi)^-1.
Proof. by move=> pi x; rewrite /compg expVgn orderV. Qed.

Lemma comp1g : forall pi, 1.`_pi = 1 :> gT.
Proof. move=> pi; exact: exp1gn. Qed.

Lemma compJg : forall pi x y, (x ^ y).`_pi = x.`_pi ^ y.
Proof. by move=> pi x y; rewrite /compg orderJ conjXg. Qed.

Lemma p_elt_comp : forall pi x, pi.-elt x.`_pi.
Proof. by move=> pi x; rewrite p_elt_exp /chinese addn0 mul1n dvdn_mulr. Qed.

Lemma compgC : forall pi x, x.`_pi * x.`_pi^' = x.
Proof.
move=> pi x; apply/eqP; rewrite -{3}[x]expg1 -expgn_add eq_expg_mod_order.
rewrite partnNK -{5 6}(@partnC pi #[x]) // /chinese !addn0.
by rewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC ?eqxx.
Qed.

Lemma p'_elt_comp : forall pi x, pi^'.-elt (x * (x.`_pi)^-1).
Proof.
by move=> pi x; rewrite -{1}(compgC pi^' x) compgNK mulgK p_elt_comp.
Qed.

Lemma order_comp : forall pi (x : gT), #[x.`_pi] = #[x]`_pi.
Proof.
move=> pi x; rewrite -{2}(compgC pi x) order_mul; [|exact: commuteX2|].
  rewrite partn_mul // part_pnat ?part_p'nat ?muln1 //; exact: p_elt_comp.
apply: (@pnat_coprime pi); exact: p_elt_comp.
Qed.

Lemma compMg : forall pi x y, commute x y -> (x * y).`_pi = x.`_pi * y.`_pi.
Proof.
move=> pi x y cxy; pose m := #|<<[set x; y]>>|.
pose k := chinese m`_pi m`_pi^' 1 0; have m_pos: 0 < m := ltn_0group _.
suffices kXpi: forall z, z \in <<[set x; y]>> -> z.`_pi = z ^+ k.
  by rewrite !kXpi ?expMgn // ?groupM ?mem_gen // (set21, set22).
move=> z xyz; have{xyz} zm: #[z] %| m by rewrite group_dvdn ?cycle_h.
apply/eqP; rewrite eq_expg_mod_order -{3 4}[#[z]](partnC pi) //.
rewrite chinese_remainder ?chinese_modl ?chinese_modr ?coprime_partC //.
rewrite -!(modn_dvdm k (partn_dvd _ m_pos zm)).
rewrite chinese_modl ?chinese_modr ?coprime_partC //.
by rewrite !modn_dvdm ?partn_dvd ?eqxx.
Qed.

Lemma compXg : forall pi x n, (x ^+ n).`_pi = x.`_pi ^+ n.
Proof.
move=> pi x; elim=> [|n IHn]; first exact: comp1g.
rewrite !expgS compMg ?IHn //; exact: commuteX.
Qed.

Lemma compg1P: forall pi x, reflect (x.`_pi = 1) (pi^'.-elt x).
Proof.
move=> pi x; rewrite -{2}[x]expg1 p_elt_exp -order_comp compgNK.
rewrite order_dvd expg1; exact: eqP.
Qed.

Lemma compg_p_elt : forall pi x, pi.-elt x -> x.`_pi = x.
Proof.
move=> pi x; rewrite -p_eltNK -{3}(compgC pi x); move/compg1P->.
by rewrite mulg1.
Qed.

Lemma subd_compg : forall pi1 pi2 x,
  {in \pi(#[x]), {subset pi1 <= pi2}} -> x.`_pi2.`_pi1 = x.`_pi1.
Proof.
move=> pi1 pi2 x pi12; rewrite -{2}(compgC pi2 x).
rewrite compMg; last exact: commuteX2.
rewrite (compg1P _ x.`_pi2^' _) ?mulg1 //.
apply: subd_pnat (p_elt_comp _ x) => p; rewrite order_comp => pi_p.
apply: contra; apply: pi12.
by rewrite -[#[x]](partnC pi2^') // primes_mul // pi_p.
Qed.

Lemma prod_compg : forall x, \prod_(0 <= p < #[x].+1) x.`_p = x.
Proof.
move=> x; pose lp n := [pred p | p < n].
have: (lp #[x].+1).-elt x by apply/pnatP=> // p _; exact: dvdn_leq.
move/compg_p_elt=> def_x; symmetry; rewrite -{1}def_x {def_x}.
elim: _.+1 => [|p IHp].
  by rewrite big_seq0; apply/compg1P; exact/pgroupP.
rewrite big_nat_recr /= -{}IHp -(compgC (lp p) x.`__); congr (_ * _).
  rewrite subd_compg // => q _; exact: leqW.
set y := _.`__; rewrite -(compgC p y) (compg1P p^' _ _) ?mulg1.
  by rewrite 2?subd_compg // => q _; move/eqnP->; rewrite inE //= inE /= ltnn.
rewrite /p_elt pnatNK !order_comp -partnI.
apply: subd_pnat (pnat_part _ _) => q _; do 3!rewrite !inE /=.
by rewrite ltnS -leqNgt -eqn_leq.
Qed.

Lemma max_pgroupJ : forall pi M G x,
  x \in G -> [max M | pi.-subgroup(G) M] -> 
   [max M :^ x of M | pi.-subgroup(G) M].
Proof.
move=> pi M G x Gx; case/maxgroupP=> piM maxM; apply/maxgroupP.
split=> [|H piH]; first by rewrite psubgroupJ.
rewrite -(conjsgKV x H) conjSg; move/maxM=> /= -> //.
by rewrite psubgroupJ ?groupV.
Qed.

Lemma comm_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H \subset G ->
  commute H M -> H \subset M.
Proof.
move=> pi H M G; case/maxgroupP; case/andP=> sMG piM maxM piH sHG cHM.
rewrite -(maxM (H <*> M)%G) /= comm_mulgenE ?(mulG_subl, mulG_subr) //.
by rewrite /psubgroup pgroupM piM piH mul_subG.
Qed.

Lemma normal_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H <| G -> H \subset M.
Proof.
move=> pi H M G maxM piH; case/andP=> sHG nHG.
apply: comm_sub_max_pgroup piH sHG _ => //; apply: commute_sym; apply: normC.
by apply: subset_trans nHG; case/andP: (maxgroupp maxM).
Qed.

Lemma norm_sub_max_pgroup : forall pi H M G,
  [max M | pi.-subgroup(G) M] -> pi.-group H -> H \subset G ->
  H \subset 'N(M) -> H \subset M.
Proof.
move=> pi H M G maxM piH sHG; move/normC; exact: comm_sub_max_pgroup piH sHG.
Qed.

Lemma Hall_max : forall pi H G, pi.-Hall(G) H -> [max H | pi.-subgroup(G) H].
Proof.
move=> pi H G hallH; apply/maxgroupP; split=> [|K].
  by rewrite /psubgroup; case/and3P: hallH => ->.
case/andP=> sKG piK sHK; apply/eqP; rewrite eq_sym eqset_sub_card sHK.
by rewrite (card_Hall hallH) -(part_pnat piK) dvdn_leq ?partn_dvd ?group_dvdn.
Qed.

(* These lemmas actually hold for maximal pi-groups, but below we'll *)
(* derive from the Cauchy lemma that a normal max pi-group is Hall.  *)

Lemma subset_normal_Hall : forall pi H G K,
  pi.-Hall(G) H -> H <| G -> (K \subset H) = pi.-subgroup(G) K.
Proof.
move=> pi H G K hallH nHG; apply/idP/andP=> [sKH | [sKG piK]].
  by case/and3P: hallH => sHG piH _; rewrite (pgroupS sKH) ?(subset_trans sKH).
apply: norm_sub_max_pgroup (Hall_max hallH) piK _ _ => //.
case/andP: nHG => _; exact: subset_trans.
Qed.

Lemma mem_normal_Hall : forall pi H G x,
  pi.-Hall(G) H -> H <| G -> x \in G -> (x \in H) = pi.-elt x.
Proof.
move=> pi H G x hallH nHG Gx; have:= subset_normal_Hall <[x]> hallH nHG.
by rewrite /psubgroup !gen_subG !sub1set Gx.
Qed.

Lemma uniq_normal_Hall : forall pi H G K,
  pi.-Hall(G) H -> H <| G -> [max K | pi.-subgroup(G) K] -> K :=: H.
Proof.
move=> pi H G K hallH nHG; case/maxgroupP.
rewrite -(subset_normal_Hall _ hallH) /psubgroup // => sKH maxK.
rewrite (maxK H) //; exact: maxgroupp (Hall_max hallH).
Qed.

End PgroupProps.

Section ModP.

Variable (gT : finGroupType) (sT : finType).

Variable to : {action gT &-> sT}.

(***********************************************************************)
(*                                                                     *)
(*           The mod p lemma                                           *)
(*                                                                     *)
(***********************************************************************)

Lemma pgroup_fix_mod : forall p (G : {group gT}) (S : {set sT}),
  prime p -> p.-group G -> [acts (G | to) on S] ->
   #|S| %% p = #|'C_S(G | to)| %% p.
Proof.
move=> p G S prime_p; case/p_natP => // n cardG GactS; apply/eqP.
rewrite -(cardsID 'C(G | to)) eqn_mod_dvd (leq_addr, addKn) //.
set S1 := S :\: _; have: [acts (G | to) on S1].
  apply/actsP=> a Ga x; rewrite !in_setD (actsP GactS) //; congr (~~ _ && _).
  by apply: actsP Ga x; rewrite norm_act_fix ?normG.
move/acts_sum_card_orbit <-.
apply big_prop => // [m1 m2|X]; first exact: dvdn_add.
case/imsetP=> x; case/setDP=> _ nfx ->{X}.
have:= dvdn_orbit to G x; rewrite cardG.
case/dvdn_pfactor=> [//|[_|m _ ->]]; last exact: dvdn_mulr.
move/card_orbit1=> fix_x; case/afixP: nfx => a Ga; apply/set1P.
by rewrite -fix_x mem_imset.
Qed.

End ModP.

Section Morphim.

Variables (aT rT : finGroupType) (D : {group aT}) (f : {morphism D >-> rT}).
Implicit Type pi : nat_pred.
Implicit Types G H P : {group aT}.

Lemma morphim_pgroup : forall pi G, pi.-group G -> pi.-group (f @* G).
Proof. move=> pi G; apply: pnat_dvd; exact: dvdn_morphim. Qed.

Lemma morphim_p_index : forall pi G H,
  H \subset D -> pi.-nat #|G : H| -> pi.-nat #|f @* G : f @* H|.
Proof.
move=> pi G H dH; apply: pnat_dvd; apply: dvdn_morphim_index.
by rewrite subIset // orbC dH.
Qed.

Lemma morphim_pHall : forall pi G H,
  H \subset D -> pi.-Hall(G) H -> pi.-Hall(f @* G) (f @* H).
Proof.
move=> pi G H dH; case/and3P=> sHG piH pi'GH.
by rewrite /pHall morphimS // morphim_pgroup // morphim_p_index.
Qed.

Lemma morphim_Hall : forall G H,
   H \subset D -> Hall G H -> Hall (f @* G) (f @* H).
Proof.
move=> G H dH; case/HallP=> pi piH; apply: (@pHall_Hall _ pi).
exact: morphim_pHall.
Qed.

Lemma morphim_pSylow : forall p G P,
  P \subset D -> p.-Sylow(G) P -> p.-Sylow(f @* G) (f @* P).
Proof. move=> p; exact: morphim_pHall. Qed.

Lemma morphim_p_group : forall P, p_group P -> p_group (f @* P).
Proof. move=> P; move/morphim_pgroup; exact: pgroup_p. Qed.

Lemma morphim_Sylow : forall G P,
  P \subset D -> Sylow G P -> Sylow (f @* G) (f @* P).
Proof.
move=> G P dP; case/andP=> pP hallP.
by rewrite /Sylow morphim_p_group // morphim_Hall.
Qed.

Lemma morph_p_elt : forall pi x, x \in D -> pi.-elt x -> pi.-elt (f x).
Proof. move=> pi x Dx; apply: pnat_dvd; exact: morph_order. Qed.

Lemma morph_comp : forall pi x, x \in D -> f x.`_pi = (f x).`_pi.
Proof.
move=> pi x Dx; rewrite -{2}(compgC pi x) morphM ?groupX //.
rewrite compMg; last by rewrite !morphX //; exact: commuteX2.
have: pi.-elt (f x.`_pi) by rewrite morph_p_elt ?groupX ?p_elt_comp //.
have: pi^'.-elt (f x.`_pi^') by rewrite morph_p_elt ?groupX ?p_elt_comp //.
by move/compg1P->; move/compg_p_elt->; rewrite mulg1.
Qed.

End Morphim.

Section PgroupFunctor.

Implicit Type gT rT : finGroupType.

Variable F : nat -> forall gT, {set gT} -> {set gT}.
Hypothesis subF : forall p gT (G : {group gT}), F p G \subset G.
Hypothesis funF : forall p gT rT (G : {group gT}) (f : {morphism G >-> rT}),
  f @* (F p G) \subset F p (f @* G).

Definition pgroup_functor gT (A : {set gT}) :=
  <<if p_group A then F (pdiv #|A|) A else 1>>.

Lemma pgroup_functor_1 : forall gT (G : {group gT}),
  ~~ p_group G -> pgroup_functor G = 1.
Proof. by move=> gT G npG; rewrite /pgroup_functor -if_neg npG genGid. Qed.

Lemma pgroup_functor_sub : forall gT (G : {group gT}),
  pgroup_functor G \subset G.
Proof. by move=> gT G; rewrite gen_subG; case: ifP; rewrite ?sub1G. Qed.

Lemma pgroup_functor1 : forall gT, pgroup_functor 1 = 1 :> {set gT}.
Proof. move=> gT; apply/trivgP; exact: pgroup_functor_sub. Qed.

Lemma pgroup_functor_p : forall (p : nat) gT (G : {group gT}),
  p.-group G -> pgroup_functor G = <<F p G>>.
Proof.
move=> p gT G pG; case: (leqP #|G| 1).
  rewrite -trivg_card; move/trivGP=> ->; apply/eqP.
  by rewrite pgroup_functor1 eqset_sub sub1G gen_subG subF.
move/prime_pdiv=> pr_p.
have def_p: pdiv #|G| = p by apply/eqP; exact: (pnatP _ _ pG) (dvdn_pdiv _).
by rewrite /pgroup_functor /p_group def_p pG.
Qed.

Lemma morphim_pgroup_functor : forall gT rT
    (G : {group gT}) (f : {morphism G >-> rT}),
  f @* (pgroup_functor G) \subset pgroup_functor (f @* G).
Proof.
move=> gT rT G f; case pG: (p_group G); last first.
  by rewrite pgroup_functor_1 ?pG // morphim1 sub1G.
rewrite {1}/pgroup_functor pG morphim_gen //.
rewrite (@pgroup_functor_p (pdiv #|G|)) ?genS ?funF //.
by apply: pnat_dvd pG; exact: dvdn_morphim.
Qed.

End PgroupFunctor.

Section Pcore.

(* A functor needs to quantify over the finGroupType just beore the set. *)

Variables (n p : nat) (pi : nat_pred) (gT : finGroupType) (A : {set gT}).

Definition pcore := \bigcap_(G | [max G | pi.-subgroup(A) G]) G.

Definition OhmFun := [set x \in A | x ^+ (p ^ n) == 1].

Definition MhoFun := (fun x => x ^+ (p ^ n)) @: A.

Canonical Structure pcore_group := Eval hnf in [group of pcore].

End Pcore.

Notation "''O_' pi ( G )" := (pcore pi G)
  (at level 8, pi at level 2, format "''O_' pi ( G )") : group_scope.
Notation "''O_' pi ( G )" := (pcore_group pi G) : subgroup_scope.

Definition Ohm n := pgroup_functor (OhmFun n).
Canonical Structure Ohm_group n gT A := Eval hnf in [group of @Ohm n gT A].
Notation "''Ohm_' n ( G )" := (Ohm n G)
  (at level 8, n at level 2, format "''Ohm_' n ( G )") : group_scope.
Notation "''Ohm_' n ( G )" := (Ohm_group n G) : subgroup_scope.

Definition Mho n := pgroup_functor (MhoFun n).
Canonical Structure Mho_group n gT A := Eval hnf in [group of @Mho n gT A].
Notation "''Mho^' n ( G )" := (Mho n G)
  (at level 8, n at level 2, format "''Mho^' n ( G )") : group_scope.
Notation "''Mho^' n ( G )" := (Mho_group n G) : subgroup_scope.

Section PseriesDefs.

Variables (pis : seq nat_pred) (gT : finGroupType) (A : {set gT}).

Definition pcore_mod pi B := coset_of B @*^-1 'O_pi(A / B).
Canonical Structure pcore_mod_group pi B :=
  Eval hnf in [group of pcore_mod pi B].

Definition pseries := foldr pcore_mod 1 (rev pis).

Lemma pseries_group_set : group_set pseries.
Proof. rewrite /pseries; case: rev => [|pi1 pi1']; exact: groupP. Qed.

Canonical Structure pseries_group := Group pseries_group_set.

End PseriesDefs.

Notation Local AddPred := (@Adds nat_pred) (only parsing).
Notation "''O_{' p1 , .. , pn } ( A )" :=
  (pseries (AddPred p1 .. (AddPred pn [::]) ..) A)
  (at level 8, format "''O_{' p1 , .. , pn } ( A )") : group_scope.
Notation "''O_{' p1 , .. , pn } ( A )" :=
  (pseries_group (AddPred p1 .. (AddPred pn [::]) ..) A) : subgroup_scope.

Definition plength_1 (p : nat) (gT : finGroupType) (A : {set gT}) :=
  'O_{p^', p, p^'}(A) == A.

Notation "p .-length_1" := (@plength_1 p _)
  (at level 2, format "p .-length_1") : group_scope.

Section PCoreProps.

Variables (pi : nat_pred) (gT : finGroupType).
Implicit Type A : {set gT}.
Implicit Types G H M K : {group gT}.

Lemma pcore_psubgroup : forall G, pi.-subgroup(G) 'O_pi(G).
Proof.
move=> G; have [M maxM]: {M | [max M | pi.-subgroup(G) M] & 1%G \subset M}.
  by apply: maxgroup_exists; rewrite /psubgroup sub1G pgroup1.
have sOM: 'O_pi(G) \subset M by exact: bigcap_inf.
case/andP: (maxgroupp maxM) => piM sMG _.
by rewrite /psubgroup (pgroupS sOM) // (subset_trans sOM).
Qed.

Lemma pcore_pgroup : forall G, pi.-group 'O_pi(G).
Proof. by move=> G; case/andP: (pcore_psubgroup G). Qed.

Lemma pcore_subset : forall G, 'O_pi(G) \subset G.
Proof. by move=> G; case/andP: (pcore_psubgroup G). Qed.

Lemma subset_pcore : forall G H, pi.-group H -> H <| G -> H \subset 'O_pi(G).
Proof.
move=> G H piH nHG; apply/bigcap_inP=> M maxM.
exact: normal_sub_max_pgroup piH nHG.
Qed.

Lemma pcore_normal : forall G, 'O_pi(G) <| G.
Proof.
move=> G; rewrite /(_ <| G) pcore_subset; apply/subsetP=> x Gx.
rewrite inE; apply/bigcap_inP=> M maxM; rewrite sub_conjg.
by apply: bigcap_inf; apply: max_pgroupJ; rewrite ?groupV.
Qed.

Lemma normal_Hall_pcore : forall H G, pi.-Hall(G) H -> H <| G -> 'O_pi(G) = H.
Proof.
move=> H G hallH nHG; apply/eqP.
rewrite eqset_sub (subset_normal_Hall _ hallH) //= pcore_psubgroup.
by rewrite subset_pcore //= (pHall_pgroup hallH).
Qed.

End PCoreProps.

Section Cauchy.

Implicit Type gT : finGroupType.

Lemma Cauchy : forall p gT (G : {group gT}),
  prime p -> p %| #|G| -> {x | x \in G & #[x] = p}.
Proof.
move=> p gT G pr_p; elim: {G}_.+1 {-2}G (ltnSn #|G|) => // n IHn G.
rewrite ltnS => leGn pG; pose xpG := [pred x \in G | #[x] == p].
case: (pickP xpG) => [x|no_x]; first by case/andP=> Gx; move/eqP; exists x.
have{pG n leGn IHn} pZ: p %| #|'C_G(G)|.
  have:= pG; rewrite -(cardsID 'C(G)) dvdn_addl //.
  have: [acts (G | 'J) on G :\: 'C(G)]; last move/acts_sum_card_orbit <-.
    by apply/actsP=> x Gx y; rewrite !inE -!mem_conjgV -centJ conjGid ?groupV.
  apply big_prop => // [|C]; first exact: dvdn_add.
  case/imsetP=> x; case/setDP=> Gx nCx ->{C}; rewrite card_orbit conjg_astab1.
  move: pG; rewrite -(LaGrange (subsetIl G 'C[x]%G)) euclid //; case/orP => //.
  case/IHn=> [|y]; last first.
    by case/setIP=> Gy _; move/eqP=> oyp; case/andP: (no_x y).
  apply: leq_trans leGn; apply: proper_card; rewrite properE subsetIl.
  by rewrite subsetI subset_refl /= -cent_set1 centsC sub1set.
have: p^'.-group 'O_p^'(G) by exact: pcore_pgroup.
rewrite /pgroup p'natE //; case/negP; apply: dvdn_trans pZ (group_dvdn _).
apply/subsetP=> x; case/setIP=> Cx Gx.
rewrite -sub1set -gen_subG subset_pcore //; last first.
  rewrite /(_ <| _) cycle_h //; apply: subset_trans (cent_subset _).
  by rewrite centsC cycle_h.
apply/pgroupP=> q _ p_x; apply/eqP=> def_q; rewrite {q}def_q in p_x.
case/dvdnP: p_x => m ox; case/idP: (no_x (x ^+ m)) => /=.
have m_pos: 0 < m by rewrite -(ltn_pmul2r (ltn_0prime pr_p)) -ox ltn_0order.
by rewrite /= groupX //= order_gcd // [#[x]]ox gcdnC gcdn_mulr divn_mulr.
Qed.

Lemma normal_max_pgroup_Hall : forall pi gT (G H : {group gT}),
  [max H | pi.-subgroup(G) H] -> H <| G -> pi.-Hall(G) H.
Proof.
move=> pi gT G H; case/maxgroupP; case/andP=> sHG piH maxH nHG.
have [_ nnHG] := andP nHG; rewrite /pHall sHG piH; apply/pnatP=> // p pr_p.
rewrite inE /= -pnatE // -card_quotient //.
case/Cauchy=> //= Hx; rewrite -sub1set -gen_subG -/<[Hx]> /order.
case/inv_quotientS=> //= K; move/(congr1 val)=> /= -> sHK sKG {Hx}.
rewrite card_quotient ?(subset_trans sKG) // => iKH; apply/negP=> pi_p.
rewrite -iKH -group_divn // (maxH K) ?divnn ?ltn_0group // in pr_p.
by rewrite /psubgroup sKG /pgroup -(LaGrange sHK) mulnC pnat_mul iKH pi_p.
Qed.

End Cauchy.

Section MorphPcore.

Implicit Type pi : nat_pred.
Implicit Types gT rT : finGroupType.

Section Gfunctor.

Variable F : forall gT, {set gT} -> {set gT}.
Hypothesis subF : forall gT (G : {group gT}), F G \subset G.
Hypothesis funF : forall gT rT (D : {group gT}) (f : {morphism D >-> rT}),
                  f @* (F D) \subset F (f @* D).

Lemma gfunctor_norm : forall gT (G : {group gT}), G \subset 'N(F G).
Proof.
move=> gT G; apply/subsetP=> x Gx; rewrite inE -{2}(conjGid Gx) -{2}(setIid G).
by rewrite -(setIidPr (subF G)) -!morphim_conj funF.
Qed.

Lemma gfunctor_normal : forall gT (G : {group gT}), F G <| G.
Proof. by move=> gT G; apply/andP; rewrite subF gfunctor_norm. Qed.

Lemma gfunctor_char : forall gT (G : {group gT}), F G \char G.
Proof.
move=> gT G; apply/andP; split=> //; apply/forallP=> f; apply/implyP=> Af.
by rewrite -{2}(autm_dom Af) -(morphimEsub (autm_morphism Af)) ?subF ?funF.
Qed.

Lemma morphim_gfunctor : forall gT rT (D G : {group gT}) 
                                      (f : {morphism D >-> rT}),
  G \subset D -> f @* (F G) \subset F (f @* G).
Proof.
move=> gT rT D G f sGD; rewrite -(setIidPr (subF G)) -{3}(setIid G).
by rewrite -!(morphim_restrm sGD) funF.
Qed.

Lemma injm_gfunctor : forall gT rT (D G : {group gT}) 
                                   (f : {morphism D >-> rT}),
  'injm f -> G \subset D -> f @* (F G) = F (f @* G).
Proof.
move=> gT rT D G f injf sGD; apply/eqP; rewrite eqset_sub morphim_gfunctor //=.
rewrite -{2}(morphim_invm injf sGD) -[f @* F _](morphpre_invm injf).
have sFtr := subset_trans (subF _).
by rewrite -sub_morphim_pre (morphim_gfunctor, sFtr) ?morphimS.
Qed.


Lemma isom_gfunctor : forall gT rT (D G : {group gT}) (R : {group rT}) 
                                   (f : {morphism D >-> rT}),
  G \subset D -> isom G R f -> isom (F G) (F R) f.
Proof.
move=> gT rT D G R f; case/(restrmP f)=> g _ ->; case/isomP=> injf <-.
rewrite /isom -!setDset1 -(injm_gfunctor injf) //.
by rewrite -morphimEsub ?morphimDG ?morphim1 // subDset subsetU // subF orbT.
Qed.

Lemma isog_gfunctor : forall gT rT (D : {group gT}) (R : {group rT}),
  D \isog R -> F D \isog F R.
Proof.
move=> gT rT D R; case/isogP=> f *; case/(restrmP f): (subF D) => g _ fg.
apply: isom_isog (g) _; rewrite -fg isom_gfunctor //; exact/isomP.
Qed.

End Gfunctor.

Lemma gfunc_pcore : forall pi gT rT (D : {group gT}) (f : {morphism D >-> rT}),
  f @* 'O_pi(D) \subset 'O_pi(f @* D).
Proof.
move=> pi gT rT D f; apply/bigcap_inP=> M; move/normal_sub_max_pgroup; apply.
  by rewrite morphim_pgroup ?pcore_pgroup.
apply: morphim_normal; exact: pcore_normal.
Qed.

Lemma morphim_pcore : forall pi gT rT (D G : {group gT})
                                      (f : {morphism D >-> rT}),
  G \subset D -> f @* 'O_pi(G) \subset 'O_pi(f @* G).
Proof.
move=> pi; exact: morphim_gfunctor (pcore_subset pi) (gfunc_pcore pi).
Qed.

Lemma char_pcore : forall pi gT (G : {group gT}), 'O_pi(G) \char G.
Proof.
move=> pi; exact: gfunctor_char (pcore_subset pi) (gfunc_pcore pi).
Qed.

Section PcoreMod.

Variable F : forall gT, {set gT} -> {set gT}.
Hypothesis subF : forall gT (G : {group gT}), F G \subset G.
Hypothesis funF : forall gT rT (D : {group gT}) (f : {morphism D >-> rT}),
                  f @* (F D) \subset F (f @* D).

Lemma pcore_mod_sub : forall pi gT (G : {group gT}),
  pcore_mod G pi (F G) \subset G.
Proof.
move=> pi gT G; have nFD := gfunctor_norm subF funF G.
rewrite sub_morphpre_im ?pcore_subset //=.
  by rewrite ker_coset_gen subIset // gen_subG subF.
by apply: subset_trans (pcore_subset _ _) _; apply: morphimS.
Qed.

Lemma gfunc_pcore_mod : forall pi gT rT (D : {group gT}),
  forall f : {morphism D >-> rT},
  f @* pcore_mod D pi (F D) \subset pcore_mod (f @* D) pi (F (f @* D)).
Proof.
move=> pi gT rT D f; have nFD := gfunctor_norm subF funF D.
have sDg: D \subset 'dom (coset_of (F (f @* D)) \o f).
  by rewrite -sub_morphim_pre // gfunctor_norm.
pose K := 'ker (restrm sDg (coset_of (F (f @* D)) \o f)).
have sFK: 'ker (coset_of (F D)) \subset K.
  rewrite /K ker_restrm ker_comp !ker_coset_gen subIset //; apply/orP; left.
  rewrite gen_subG subsetI subF -sub_morphim_pre ?subF //=.
  rewrite (setIidPl _) ?sub_gen // gen_subG.
  apply: subset_trans (subF _) _; exact: gfunctor_norm.
rewrite -sub_morphim_pre -?quotientE; last first.
  apply: subset_trans (gfunctor_norm _ _ _) => //.
  by rewrite -morphimIdom morphimS // subsetIl.
have nFO: 'O_pi(D / F D) \subset 'N(F D) / F D.
  by apply: subset_trans (pcore_subset _ _) (morphimS _ _).
have:= gfunc_pcore pi (factm_morphism nFD sFK) => /=; rewrite -?quotientE.
rewrite -{1}['O_pi(_)](morphpreK nFO) !morphim_factm.
by rewrite !morphim_restrm !morphim_comp !morphimIdom.
Qed.

Lemma quotient_pcore_mod : forall pi gT (G : {group gT}) (B : {set gT}),
  pcore_mod G pi B / B = 'O_pi(G / B).
Proof.
move=> pi gT A B; apply: morphpreK; apply: subset_trans (pcore_subset _ _) _.
by rewrite /= /quotient -morphimIdom  morphimS ?subsetIl.
Qed.

Lemma pcore_mod1 : forall pi gT (G : {group gT}), pcore_mod G pi 1 = 'O_pi(G).
Proof.
move=> pi gT G; apply: congr_group.
apply: (@quotient_inj _ 1); rewrite ?inE /= ?normal1 // quotient_pcore_mod.
rewrite -(injm_gfunctor (pcore_subset pi) (gfunc_pcore pi)) ?ker_coset //=.
by rewrite normaliser1 subsetT.
Qed.

End PcoreMod.

Lemma pseries_add_last : forall pi pis gT (A : {set gT}),
  pseries (add_last pis pi) A = pcore_mod A pi (pseries pis A).
Proof. by move=> pi pis gT A; rewrite /pseries rev_add_last. Qed.

Lemma pseries_subfun : forall pis,
   [/\ forall gT (G : {group gT}), pseries pis G \subset G
    & forall gT rT (G : {group gT}) (f : {morphism G >-> rT}),
      f @* (pseries pis G) \subset pseries pis (f @* G)].
Proof.
elim/last_ind=> [|pi pis [sFpi fFpi]].
  by split=> [gT G | gT rT G f]; rewrite (sub1G, morphim1).
split=> [gT G | gT rT G f]; rewrite !pseries_add_last ?pcore_mod_sub //.
exact: gfunc_pcore_mod.
Qed.

Lemma pseries_sub : forall pis gT (G : {group gT}), pseries pis G \subset G.
Proof. by move=> pis; case: (pseries_subfun pis). Qed.

Lemma gfunc_pseries : forall pis gT rT (G : {group gT}),
  forall f : {morphism G >-> rT},
  f @* (pseries pis G) \subset pseries pis (f @* G).
Proof. by move=> pis; case: (pseries_subfun pis). Qed.

Lemma pseries_char : forall pis gT (G : {group gT}), pseries pis G \char G.
Proof.
move=> pis; exact: gfunctor_char (pseries_sub pis) (gfunc_pseries pis).
Qed.

Lemma pseries_normal : forall pis gT (G : {group gT}), pseries pis G <| G.
Proof.
move=> pis; exact: gfunctor_normal (pseries_sub pis) (gfunc_pseries pis).
Qed.

Lemma pseries1 : forall pi gT (G : {group gT}), 'O_{pi}(G) = 'O_pi(G).
Proof. exact: pcore_mod1. Qed.

Lemma pseries_pop : forall pi pis gT (G : {group gT}),
  trivg 'O_pi(G) -> pseries (pi :: pis) G = pseries pis G.
Proof.
move=> pi pis gT G; move/trivgP=> /= OG1.
by rewrite /pseries rev_adds -cats1 foldr_cat /= pcore_mod1 OG1.
Qed.

Lemma pseries_pop2 : forall pi1 pi2 gT (G : {group gT}),
  trivg 'O_pi1(G) -> 'O_{pi1, pi2}(G) = 'O_pi2(G).
Proof. move=> pi1 pi2 gT G; move/pseries_pop->; exact: pseries1. Qed.

Lemma pseries_sub_catl : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s G \subset pseries (pi1s ++ pi2s) G.
Proof.
move=> pi1s pis gT G; elim/last_ind: pis => [|pi pis IHpi]; rewrite ?cats0 //.
rewrite -add_last_cat pseries_add_last; apply: subset_trans IHpi _.
by rewrite normal_sub // normal_ker_cosetpre.
Qed.

Lemma quotient_pseries : forall pis pi gT (G : {group gT}),
  pseries (add_last pis pi) G / pseries pis G = 'O_pi(G / pseries pis G).
Proof. by move=> pis pi gT G; rewrite pseries_add_last quotient_pcore_mod. Qed.

Lemma pseries_norm2 : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \subset 'N(pseries pi1s G).
Proof.
move=> pi1s pi2s gt G.
apply: subset_trans (normal_norm (pseries_normal pi1s G)); exact: pseries_sub.
Qed.

Lemma pseries_sub_catr : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \subset pseries (pi1s ++ pi2s) G.
Proof.
elim=> //= pi1 pi1s IH pi2s gT G; apply: subset_trans (IH _ _ _) _ => {IH}.
elim/last_ind: {pi1s pi2s}(_ ++ _) => [|pis pi IHpi]; first exact: sub1G.
rewrite -add_last_adds (pseries_add_last _ (pi1 :: pis)).
rewrite -sub_morphim_pre ?pseries_norm2 //.
apply: subset_pcore; last by rewrite morphim_normal ?pseries_normal.
have: pi.-group (pseries (add_last pis pi) G / pseries pis G).
  by rewrite quotient_pseries pcore_pgroup.
by apply: pnat_dvd; rewrite !card_quotient ?pseries_norm2 // dvdn_indexgS.
Qed.

Lemma quotient_pseries2 : forall pi1 pi2 gT (G : {group gT}),
  'O_{pi1, pi2}(G) / 'O_pi1(G) = 'O_pi2(G / 'O_pi1(G)).
Proof. by move=> pi1 pi2 gT G; rewrite -pseries1 quotient_pseries. Qed.

(* This is unduly awkward because we don't have access to the witness *)
(* for the third iso theorem, hence we need to reconstruct it on-the-fly. *)
Lemma quotient_pseries_cat : forall pi1s pi2s gT (G : {group gT}),
  pseries (pi1s ++ pi2s) G / pseries pi1s G
    = pseries pi2s (G / pseries pi1s G).
Proof.
move=> pi1s pis gT G; elim/last_ind: pis => [|pis pi IHpi].
  by rewrite cats0 trivial_quotient.
pose Gbar := G / pseries pi1s G.
pose Hbar := pseries (pi1s ++ pis) G / pseries pi1s G.
have Gf1: G \subset 'N(pseries pi1s G) by rewrite normal_norm ?pseries_normal.
have Gf2: G \subset 'N(pseries (pi1s ++ pis) G).
  by rewrite normal_norm ?pseries_normal.
have Gf: G \subset 'dom (coset_of Hbar \o coset_of (pseries pi1s G)).
  by rewrite -sub_morphim_pre ?morphim_norms.
pose kf1 := 'ker (restrm Gf (coset_of Hbar \o coset_of (pseries pi1s G))).
have skf: 'ker (coset_of (pseries (pi1s ++ pis) G)) \subset kf1.
  rewrite [kf1]ker_restrm ker_comp !ker_coset subsetI pseries_sub /=.
  by rewrite -sub_morphim_pre // pseries_norm2.
have injf: 'injm (factm Gf2 skf).
  rewrite ker_factm ker_restrm ker_comp !ker_coset morphimK ?pseries_norm2 //.
  rewrite ker_coset mulSGid ?pseries_sub_catl // trivg_quotient ?subsetIr //.
  by rewrite subIset ?Gf2.
apply: congr_group; apply: (@quotient_inj _ (pseries_group pis Gbar)).
- rewrite inE /= -IHpi morphim_normal // /(_ <| _) pseries_norm2.
  by rewrite -cats1 catA pseries_sub_catl.
- by rewrite inE /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
rewrite /= quotient_pseries /= -/Gbar -IHpi -/Hbar.
have ->: Gbar / Hbar = (factm Gf2 skf) @* (G /  pseries (pi1s ++ pis) G).
  by rewrite morphim_factm morphim_restrm setIid morphim_comp.
rewrite -(injm_gfunctor (pcore_subset pi) (gfunc_pcore pi)) //.
rewrite -quotient_pseries morphim_factm morphim_restrm morphim_comp.
by rewrite add_last_cat (setIidPr _) // pseries_sub.
Qed.

Lemma pseries_catl_id : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s (pseries (pi1s ++ pi2s) G) = pseries pi1s G.
Proof.
elim/last_ind=> [|pis pi IHpi] pi2s gT G; first by [].
apply: congr_group; apply: (@quotient_inj _ (pseries_group pis G)).
- rewrite inE /= -(IHpi (pi :: pi2s)) cat_add_last /(_ <| _) pseries_norm2.
  by rewrite -cats1 pseries_sub_catl.
- by rewrite inE /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
rewrite /= cat_add_last -(IHpi (pi :: pi2s)) {1}quotient_pseries IHpi.
apply/eqP; rewrite quotient_pseries eqset_sub !subset_pcore ?pcore_pgroup //=.
  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.
  by rewrite -cat_add_last pseries_sub_catl.
apply: char_norm_trans (char_pcore pi _) (morphim_normal _ _).
exact: pseries_normal.
Qed.

Lemma pseries_char_catl : forall pi1s pi2s gT (G : {group gT}),
  pseries pi1s G \char pseries (pi1s ++ pi2s) G.
Proof.
by move=> pi1s pi2s gT G; rewrite -(pseries_catl_id pi1s pi2s G) pseries_char.
Qed.

Lemma pseries_catr_id : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s (pseries (pi1s ++ pi2s) G) = pseries pi2s G.
Proof.
move=> pi1s pis gT; elim/last_ind: pis => [|pis pi IHpi] G; first by [].
have Epis: pseries pis (pseries (pi1s ++ add_last pis pi) G) = pseries pis G.
  by rewrite -cats1 catA -2!IHpi pseries_catl_id.
apply: congr_group; apply: (@quotient_inj _ (pseries_group pis G)).
- by rewrite inE /= -Epis /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
- by rewrite inE /= /(_ <| _) pseries_norm2 -cats1 pseries_sub_catl.
rewrite /= -Epis {1}quotient_pseries Epis quotient_pseries.
apply/eqP; rewrite eqset_sub !subset_pcore ?pcore_pgroup //=.
  rewrite -quotient_pseries morphim_normal // /(_ <| _) pseries_norm2.
  by rewrite pseries_sub_catr.
apply: char_norm_trans (char_pcore pi _) (morphim_normal _ _).
exact: pseries_normal.
Qed.

Lemma pseries_char_catr : forall pi1s pi2s gT (G : {group gT}),
  pseries pi2s G \char pseries (pi1s ++ pi2s) G.
Proof.
by move=> pi1s pi2s gT G; rewrite -(pseries_catr_id pi1s pi2s G) pseries_char.
Qed.

Lemma trivg_pcore_quotient : forall pi gT (G : {group gT}),
  trivg 'O_pi(G / 'O_pi(G)).
Proof.
move=> pi gT G; rewrite -!pseries1 -quotient_pseries_cat.
rewrite trivg_quotient /= ?pseries_norm2 // pseries1.
rewrite subset_pcore ?pseries_normal //.
rewrite /pgroup card_morphpre ?ker_coset /= pcore_mod1.
  by rewrite pnat_mul ![pnat _ _]pcore_pgroup.
apply: subset_trans (pcore_subset pi _) _.
by rewrite morphimS ?normal_norm ?pcore_normal.
Qed.

End MorphPcore.

Section OhmProps.

Section bases.

Variables (n p : nat) (gT rT : finGroupType).
Variables (G : {group gT}) (f : {morphism G >-> rT}).

Lemma OhmFun_sub : OhmFun n p G \subset G.
Proof. by apply/subsetP=> x; rewrite inE; case/andP. Qed.

Lemma MhoFun_sub : MhoFun n p G \subset G.
Proof. apply/subsetP=> y; case/imsetP=> x Gx ->; exact: groupX. Qed.

Lemma morphim_OhmFun :
  f @* (OhmFun n p G) \subset OhmFun n p (f @* G).
Proof.
apply/subsetP=> y; case/morphimP=> x _; rewrite inE; case/andP=> Gx oxpn ->.
by rewrite inE morphimEdom mem_imset //= -morphX // (eqP oxpn) morph1.
Qed.

Lemma morphim_MhoFun : f @* (MhoFun n p G) = MhoFun n p (f @* G).
Proof.
rewrite morphimEdom morphimEsub ?MhoFun_sub // /MhoFun -!imset_comp.
by apply: dfequal_imset => x Gx; rewrite /= morphX.
Qed.

End bases.

Section generic.

Variables (n : nat) (gT : finGroupType).
Implicit Type rT : finGroupType.
Implicit Type G : {group gT}.

Hint Resolve OhmFun_sub MhoFun_sub.

Lemma Ohm_subset : forall G, 'Ohm_n(G) \subset G.
Proof. exact: pgroup_functor_sub. Qed.

Lemma Mho_subset : forall G, 'Mho^n(G) \subset G.
Proof. exact: pgroup_functor_sub. Qed.

Hint Resolve Ohm_subset Mho_subset.

Lemma morphim_Ohm : forall rT G (f : {morphism G >-> rT}),
  f @* 'Ohm_n(G) \subset 'Ohm_n(f @* G).
Proof. by apply: morphim_pgroup_functor => //; exact: morphim_OhmFun. Qed.

Lemma morphim_Mho : forall rT G (f : {morphism G >-> rT}),
  f @* 'Mho^n(G) \subset 'Mho^n(f @* G).
Proof.
by apply: morphim_pgroup_functor => // p aT arT G f; rewrite morphim_MhoFun.
Qed.

Lemma OhmE : forall (p : nat) G, p.-group G -> 'Ohm_n(G) = <<OhmFun n p G>>.
Proof. move=> p; exact: pgroup_functor_p. Qed.

Lemma MhoE : forall (p : nat) G, p.-group G -> 'Mho^n(G) = <<MhoFun n p G>>.
Proof. move=> p; exact: pgroup_functor_p. Qed.

Lemma morphim_Mho_eq : forall rT G (f : {morphism G >-> rT}),
  p_group G -> f @* 'Mho^n(G) = 'Mho^n(f @* G).
Proof.
move=> rT G f; case/p_groupP=> p _ pG; rewrite (MhoE pG) morphim_gen //.
by rewrite morphim_MhoFun -pgroup_functor_p // morphim_pgroup.
Qed.

End generic.

Section char.

Variables (n : nat) (gT : finGroupType) (G : {group gT}).

Lemma char_Ohm : 'Ohm_n(G) \char G.
Proof. exact: (gfunctor_char (Ohm_subset n) (morphim_Ohm n)). Qed.

Lemma char_Mho : 'Mho^n(G) \char G.
Proof. exact: (gfunctor_char (Mho_subset n) (morphim_Mho n)). Qed.

End char.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Type G H E : {group gT}.
Implicit Type pi : nat_pred.

Lemma dvdn_exponent : forall x G, x \in G -> #[x] %| exponent G.
Proof. by move=> x G Gx; rewrite /exponent (bigD1 x) //= dvdn_lcml. Qed.

Lemma exponentP : forall G n,
  reflect (forall x, x \in G -> x ^+ n = 1) (exponent G %| n).
Proof.
rewrite /exponent => G n; apply: (iffP idP) => [eGn x Gx | eGn].
  apply/eqP; rewrite -order_dvd; apply: dvdn_trans eGn; exact: dvdn_exponent.
apply big_prop=> [|p q|x Gx]; [exact: dvd1n | exact: dvdn_lcm | ].
by rewrite order_dvd eGn.
Qed.

Lemma trivg_exponent : forall G, trivg G = (exponent G %| 1).
Proof.
move=> G.
by apply/subsetP/exponentP=> trG x; move/trG; rewrite expg1; move/set1P.
Qed.

Lemma exponent1 : exponent (1 : {set gT}) = 1%N.
Proof. by apply/eqP; rewrite -dvdn1 -trivg_exponent trivg1. Qed.

Lemma exponent_dvdn : forall G, exponent G %| #|G|.
Proof.
by move=> G; apply/exponentP=> s Gx; apply/eqP; rewrite -order_dvd order_dvd_g.
Qed.

Lemma ltn_0exponent : forall G, 0 < exponent G.
Proof. move=> G; exact: ltn_0dvd (exponent_dvdn G). Qed.
Hint Resolve ltn_0exponent.

Lemma pnat_exponent : forall pi G, pi.-nat (exponent G) = pi.-group G.
Proof.
move=> pi G; congr (_ && _); first by rewrite ltn_0group ltn_0exponent.
apply: eq_all_r=> p; rewrite !mem_primes ltn_0group ltn_0exponent /=.
case pr_p: (prime p) => //=; apply/idP/idP=> pG.
  exact: dvdn_trans pG (exponent_dvdn G).
case/Cauchy: pG => // x Gx <-; exact: dvdn_exponent.
Qed.

Lemma abelemP : forall E,
  reflect (exists2 p, prime p & p.-abelem E) (abelem E).
Proof.
rewrite /p_abelem => E; apply: (iffP idP) => [abE | [p _]]; last by case/andP.
case: (andP abE) => _; move/pgroup_p; case/p_groupP => p pr_p pE.
by rewrite abE; exists p.
Qed.

Lemma p_abelemE : forall p E,
  prime p -> p.-abelem E = abelian E && (exponent E %| p).
Proof.
move=> p E pr_p; rewrite /p_abelem -andbA; congr (_ && _).
have e_E := exponent_dvdn E; apply/andP/idP => [[eE pE] | pE].
  case/p_natP: (pnat_dvd e_E pE) => // [[|k]] def_e; first by rewrite def_e.
  suff: (exponent E).-nat p by rewrite pnatE //; move/eqnP->.
  by apply: pnat_dvd eE; apply: dvdn_trans e_E; rewrite def_e dvdn_mulr.
have pgE: p.-group E by rewrite -pnat_exponent; exact: pnat_dvd (pnat_id _).
split=> //; case/primeP: pr_p => _ pr_p; move/pr_p: pE.
rewrite orbC; case/predU1P=> [-> // |].
by rewrite -dvdn1 -trivg_exponent; move/trivGP->; exact: pgroup1.
Qed.

Lemma p_abelemP : forall p E, prime p ->
  reflect (abelian E /\ forall x, x \in E -> x ^+ p = 1) (p.-abelem E).
Proof.
move=> p E pr_p; rewrite p_abelemE //.
by apply: (iffP andP) => [] [->]; move/exponentP.
Qed.

Lemma abelem_pgroup : forall p E, p.-abelem E -> p.-group E.
Proof. by move=> p E; case/andP. Qed.

Lemma abelem_Ohm1P : forall E,
  abelian E -> reflect ('Ohm_1(E) = E) (abelem E).
Proof.
move=> E abelE; apply: (iffP (abelemP E)) => [[p pr_p pAE] |].
  have pE: p.-group E by case/andP: pAE.
  apply/eqP; rewrite eqset_sub Ohm_subset (OhmE 1 pE) sub_gen //.
  apply/subsetP=> x Ex; rewrite inE Ex expn1 /=.
  by case/p_abelemP: pAE => // _ ->.
case pE: (p_group E); last first.
  by rewrite /Ohm pgroup_functor_1 ?pE // => E1; rewrite -E1 p_group1 in pE.
case/p_groupP: pE => p pr_p pE; rewrite (OhmE 1 pE).
rewrite gen_set_id => [defE |]; last first.
  apply/group_setP; split=> [|x y]; rewrite !inE ?(exp1gn, group1) //=.
  case/andP=> Ex; move/eqP=> xp; case/andP=> Ey; move/eqP=> yp.
  rewrite groupM // expMgn ?(xp, yp, mulg1) //=; exact: (centsP abelE).
exists p => //; apply/p_abelemP=> //; split=> // x.
by rewrite -defE inE expn1; case/andP=> _; move/eqP.
Qed.

Lemma pnElemE : forall p n G,
  prime p -> 'E_p^n(G) = [set E \in 'E_p(G) | #|E| == (p ^ n)%N].
Proof.
move=> p n G pr_p; apply/setP=> E; rewrite 3!inE -2!andbA; congr (_ && _).
case pE: (p.-abelem E) => //=; case/andP: pE => _; case/p_natP=> // k ->.
by move/pfactorK: pr_p => pK; rewrite pK (can_eq pK).
Qed.

Lemma Elem1P : forall G E,
  reflect (E \subset G /\ exists2 p, prime p & #|E| = p) (E \in 'E^1(G)).
Proof.
move=> G E; rewrite ['E^1(G)]big_mkord.
apply: (iffP (bigcupP _ _ _)) => [[[/= p _] _ pE]|[sEG [p pr_p pE]]].
  have pr_p: prime p by move: pE; rewrite 2!inE andbC lognE; case prime.
  move: pE; rewrite pnElemE // 2!inE expn1 -andbA; case/and3P=> sEG _.
  by move/eqP; split; last exists p.
have lt_p_G1: p < #|G|.+1 by rewrite ltnS dvdn_leq // -pE group_dvdn.
exists (Ordinal lt_p_G1); rewrite //= pnElemE // 2!inE sEG /= expn1 pE eqxx.
rewrite p_abelemE // -pE exponent_dvdn !andbT.
case: (@Cauchy p _ E) => // [|x Ex oxp]; first by rewrite pE.
suff <-: <[x]> = E by apply/centsP; apply: commute_cycle_com.
by apply/eqP; rewrite eqset_sub_card pE [#|_|]oxp cycle_h /=.
Qed.

End OhmProps.

