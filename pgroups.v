Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype paths connect finfun ssralg bigops finset prime.
Require Import groups action morphisms group_perm automorphism normal cyclic.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GroupScope.

(**********************************************************************)
(* Standard group notions and constructions based on the prime        *)
(* decomposition of the order of the group or its elements.           *)
(* -Predicates/definitions:                                           *)
(*   pgroup p P, pi_group pi H                                       *)
(*        <-> primes #|P| / #|H| is included in {p}/pi (p prime)      *)
(*   p_elt p x, pi_elt p x                                            *)
(*        <-> pgroup p <<[set x]>>, pi_group pi <<[set x]>>          *)
(*   sylow p G P, hall pi G H                                         *)
(*        <-> P/H is a p/pi subgroup of G,                            *)
(*            primes #|G : P| / #|G : H| disjoint from {p}/pi         *)
(*   'Syl_p(G), 'Hall_pi(G)                                           *)
(*        == set of the sylow p / hall pi subgroups of G              *)
(*   is_pgroup P, is_sylow G P, is_hall G H                          *)
(*        <-> pgroup p P, sylow p G P, hall pi G H for some p/pi     *)
(*   exponent G                                                       *)
(*        == \big[lcmn/1]_(x \in G) #[x].                             *)
(*   abelem p E                                                       *)
(*        <-> E is an elementary abelian p-group                      *)
(*   abelem_for p n E                                                 *)
(*        <-> E is an elementary abelian p-group of order p ^ n       *)
(*   is_abelem E                                                      *)
(*        <-> E is elementary abelian (abelem p E for some p)         *)
(*   max_abelem p G E                                                 *)
(*        <-> E is a maximal abelem p subgroup of G                   *)
(*   'E_p(G), 'E_p^n(G), 'E_p^*(G)                                    *)
(*        == set of p_elem (,.. of rank n, maximal ..) subgroups of G *)
(*   'm_p(G)                                                          *)
(*        == the p-rank of G (max of logn p #|E| for E in 'E_p(G))    *)
(*   'm(G)                                                            *)
(*        == the rank of G (max of 'r_p(G) for all p)                 *)
(*   basis G X                                                        *)
(*        <-> X is a basis for the abelian group G                    *)
(*   abel_type P                                                      *)
(*        == the abelian type of P, when P is an abelian p-group,     *)
(*           i.e., the sorted seq of #[x] for x in a basis X of P     *)
(*   homocyclic P                                                     *)
(*        == P is an abelian p-group whose abelian type is constant   *)
(*   'Ohm_n(P)                                                        *)
(*        == <<[set x \in P | x ^+ (pdiv #|P| ^ n) == 1]>>            *)
(*   'Mho^n(P)                                                        *)
(*        == the group generated by x ^+ (pdiv #|P| ^ n) for x in P   *)
(*   'O_pi(G)                                                         *)
(*        == the largest normal pi-subgroup of G                      *)
(*           (the first term in the upper pi-series of G)             *)
(*           (relevant lemmas quote Osub)                             *)
(*   'O_[p](G), 'O_(~ pi)(G), 'O_[~ p](G)                             *)
(*        == special cases of the above for {p}, pi', {p}' (resp.,    *)
(*           the first terms of the upper p, lower pi/p series)       *)
(*   'O_[~ p; q](G)                                                   *)
(*       == the inverse image of 'O_[q](G / 'O_[~ p](G))              *)
(*       (for p = q, which is the only case we consider, this is      *)
(*        the second term of the lower p-series of G).                *)
(*       (relevant lemmas quote Osub2)                                *)
(*   p_length_1 p G                                                   *)
(*        <-> sylow p 'O_[p](G / 'O_[~p](G)) (G / 'O_[~p](G))         *)
(*            (see below for the definition of 'O_pi(G))              *)
(* Note that notions are always defined on sets even though their     *)
(* name indicates "group" properties; the actual definition of the    *)
(* notion never tests for the group property, since this property     *)
(* will always be provided by a (canonical) group structure.          *)
(**********************************************************************)


(* More prime stuff, to be moved. *)

Section MorePrime.

Close Scope group_scope.

Implicit Types pi rho : pred nat.

Lemma coprime_has_primes : forall m n, m > 0 -> n > 0 ->
  coprime m n = ~~ has (mem (primes m)) (primes n).
Proof.
move=> m n m_pos n_pos; apply/eqnP/hasPn=> [mn1 p | no_p_mn].
  rewrite /= !mem_primes m_pos n_pos /=; case/andP=> pr_p p_n.
  have:= prime_gt1 pr_p; rewrite pr_p ltnNge -mn1 /=; apply: contra => p_m.
  by rewrite dvdn_leq ?ltn_0gcd ?m_pos // dvdn_gcd ?p_m.
case: (ltngtP (gcdn m n) 1) => //; first by rewrite ltnNge ltn_0gcd ?m_pos.
move/prime_pdiv; set p := pdiv _ => pr_p.
move/implyP: (no_p_mn p); rewrite /= !mem_primes m_pos n_pos pr_p /=.
by rewrite !(dvdn_trans (dvdn_pdiv _)) // (dvdn_gcdl, dvdn_gcdr).
Qed.

Hint Resolve ltn_0p_part.
Lemma ltn_0pi_part : forall pi n, 0 < pi_part pi n.
Proof.
by rewrite /pi_part => pi n; apply big_prop => // ? ?; rewrite ltn_0mul => ->.
Qed.
Hint Resolve ltn_0pi_part.

Lemma p_part_pi : forall p n, p_part p n = pi_part (pred1 p) n.
Proof.
move=> p n; rewrite /pi_part -big_filter unlock; set r := filter _ _.
have: size r = (p \in r).
  by rewrite mem_filter /= eqxx -count_filter count_pred1_uniq ?uniq_primes.
case rp: (p \in r); move: rp.
  by case: r => [|q []] //=; case/predU1P=> [->|//]; rewrite muln1.
by rewrite mem_filter /= eqxx /p_part lognE -mem_primes /= => ->; case: r.
Qed.

Definition pi_nat pi n := (n > 0) && all pi (primes n).

Lemma sub_pi_nat : forall pi rho n,
  subpred pi rho -> pi_nat pi n -> pi_nat rho n.
Proof.
rewrite /pi_nat => pi rho n subpi; case/andP=> -> pi_n.
apply/allP=> p; move/(allP pi_n); exact: subpi.
Qed.

Lemma eq_pi_nat : forall pi rho n,
  pi =1 rho -> pi_nat pi n = pi_nat rho n.
Proof. by move=> pi rho n eqpi; rewrite /pi_nat (eq_all eqpi). Qed.

Lemma pi_nat_predI : forall pi rho n,
  pi_nat (predI pi rho) n = pi_nat pi n && pi_nat rho n.
Proof. by move=> pi rho n; rewrite /pi_nat andbCA all_predI !andbA andbb. Qed.

Lemma pi_nat_1 : forall n, pi_nat (pred1 1) n = (n == 1).
Proof.
move=> [|[|n]] //; apply/allPn; exists (pdiv n.+2); rewrite ?primes_pdiv //.
by rewrite neq_ltn pdiv_gt1 orbT.
Qed.

Lemma pi_nat_mul : forall pi m n,
  pi_nat pi (m * n) = pi_nat pi m && pi_nat pi n.
Proof.
move=> pi m n; rewrite /pi_nat ltn_0mul andbCA -andbA andbCA.
case: posnP => // n_pos; case: posnP => //= m_pos.
apply/allP/andP=> [pi_mn | [pi_m pi_n] p].
  by split; apply/allP=> p m_p; apply: pi_mn; rewrite primes_mul // m_p ?orbT.
rewrite primes_mul //; case/orP; [exact: (allP pi_m) | exact: (allP pi_n)].
Qed.

Lemma pi_nat_part : forall pi n, pi_nat pi (pi_part pi n).
Proof.
move=> pi n; rewrite /pi_nat primes_pi_part ltn_0pi_part.
by apply/allP=> p; rewrite mem_filter; case/andP.
Qed.

Lemma pi_nat_pfactor : forall pi p n,
  prime p -> pi_nat pi (p ^ n) = (n == 0) || pi p.
Proof.
move=> pi p [|n] // pr_p; rewrite /pi_nat ltn_0exp ltn_0prime //=.
by rewrite primes_exp // primes_prime //= andbT.
Qed.

Lemma pi_nat_primes : forall n, n > 0 -> pi_nat (mem (primes n)) n.
Proof. rewrite /pi_nat => n ->; exact/allP. Qed.

Lemma pi_nat_dvdn : forall m n pi, m %| n -> pi_nat pi n -> pi_nat pi m.
Proof. by move=> m n pi; case/dvdnP=> q ->; rewrite pi_nat_mul; case/andP. Qed.

Lemma pi_nat_divn : forall m n pi, m %| n -> pi_nat pi n -> pi_nat pi (n %/ m).
Proof.
move=> m n // pi; case/dvdnP=> q ->; rewrite pi_nat_mul andbC; case/andP.
by case: m => // m _; rewrite divn_mull.
Qed.

Lemma coprime_pi_nat : forall m n,
  m > 0 -> n > 0 -> coprime m n = pi_nat (predC (mem (primes m))) n.
Proof.
by move=> m n m_pos n_pos; rewrite /pi_nat n_pos all_predC coprime_has_primes.
Qed.

Lemma part_pi_nat : forall pi n, pi_nat pi n -> pi_part pi n = n.
Proof.
move=> pi n; case/andP=> n_pos pi_n.
by rewrite /pi_part -big_filter (all_filterP pi_n) prod_p_parts.
Qed.

Lemma part_pi'_nat : forall pi n, pi_nat (predC pi) n -> pi_part pi n = 1.
Proof.
by move=> pi n; case/andP=> n_pos pi'_n; rewrite /pi_part big_hasC -?all_predC.
Qed.

Definition pnatP : forall p n,
  prime p -> reflect (exists k, n = p ^ k) (pi_nat (pred1 p) n).
Proof.
move=> p n pr_p; apply: (iffP idP) => [p_n | [k ->{n}]].
  by exists (logn p n); rewrite [p ^ _]p_part_pi part_pi_nat.
by rewrite pi_nat_pfactor //= eqxx orbT.
Qed.

End MorePrime.

Hint Resolve ltn_0p_part ltn_0pi_part.

Section MoreLaGrange.

(* Generalizing the LaGrange theorem. *)

Variables gT : finGroupType.
Implicit Types G H K : {group gT}.

Lemma LaGrangeI : forall G H, (#|G : H| * #|G :&: H|)%N = #|G|.
Proof.
move=> G H; pose C := 'C_(G | 'Msr)[H : {set _}]%G.
have ->: #|G : H| = #|G : C| by exact: card_orbit.
suff ->: G :&: H = C by rewrite mulnC LaGrange ?subsetIl.
congr (_ :&: _); apply/setP=> x; apply/idP/astab1P=> /= [Hx | <-].
  by rewrite rcosetE rcoset_id.
by rewrite rcosetE rcoset_refl.
Qed.

Lemma group_divnI : forall G H, #|G| %/ #|G :&: H| = #|G : H|.
Proof. by move=> G H; rewrite -(LaGrangeI G H) divn_mull ?ltn_0group. Qed.

Lemma group_divn_index : forall G H, #|G| %/ #|G : H| = #|G :&: H|.
Proof. by move=> G H; rewrite -(LaGrangeI G H) divn_mulr. Qed.

Lemma indexg_dvdn : forall G H, #|G : H| %| #|G|.
Proof. by move=> G H; rewrite -(LaGrangeI G H) dvdn_mulr. Qed.

Lemma group_indexI : forall G H, #|G : G :&: H| = #|G : H|.
Proof. by move=> G H; rewrite -group_divnI group_divn ?subsetIl. Qed.

Lemma group_index1 : forall G, #|G : 1| = #|G|.
Proof. by move=> G; rewrite -group_divn ?sub1G // cards1 divn1. Qed.

(* TODO: prove directly the orbit-stabilizer formula *)
(*  #|to x @: G| * #|C_(G | to)[x]| = #|G| *)
(* then derive the LaGrangeI theorem as above, and the LaGrange as a *)
(* special case; further derive the #|G * H| formula by partitioning. *)

Lemma dvdn_indexgS : forall G H K, H \subset K -> #|G : K| %| #|G : H|.
Proof.
move=> G H K sHK; rewrite -(@dvdn_pmul2r #|G :&: K|) ?ltn_0group // LaGrangeI.
by rewrite -(LaGrange (setIS G sHK)) mulnA LaGrangeI dvdn_mulr.
Qed.

Lemma dvdn_indexSg : forall G H K,
  H \subset K -> K \subset G -> #|K : H| %| #|G : H|.
Proof.
move=> G H K sHK sKG; rewrite -(@dvdn_pmul2l #|H|) ?ltn_0group //.
by rewrite !LaGrange ?(group_dvdn, subset_trans sHK).
Qed.

End MoreLaGrange.

Section PgroupDefs.
  
Variable gT : finGroupType.
Implicit Type pi : pred nat.
Implicit Types x y z : gT.
Implicit Types A B X : {set gT}.

Definition pi_group pi A := pi_nat pi #|A|.

Definition pgroup p A := pi_group (pred1 p) A.

Definition is_pgroup A := pgroup (pdiv #|A|) A.

Definition pi_elt pi x := pi_group pi <[x]>.

Definition p_elt p x := pgroup p <[x]>.

Definition hall pi A B := (B \subset A) && (#|B| == pi_part pi #|A|).

Definition Hall pi A := [set H : {group gT} | hall pi A H].

Definition sylow p := hall (pred1 p).

Definition Syl p A := [set P : {group gT} | sylow p A P].

Definition is_hall A B := (B \subset A) && coprime #|B| #|A : B|.

Definition is_sylow A B := sylow (pdiv #|B|) A B.

Definition hall_set pi A := [set G : {group gT} | hall pi A G].

Definition sylow_set p := hall_set (pred1 p).

Definition Osub pi A :=
  << \bigcup_(G : {group gT} | pi_group pi G && (G <| A)) G >>.

Definition Ohm i A := <<[set x \in A | x ^+ (pdiv #|A| ^ i) == 1]>>.

Definition Mho i A := << expgn^~ (pdiv #|A| ^ i)%N @: A >>.

Definition exponent A := \big[lcmn/1%N]_(x \in A) #[x].

Definition abelem p A := abelian A && (exponent A %| p).

Definition abelem_for p n A := abelem p A && (#|A| == p ^ n)%N.

Definition is_abelem A := abelem (pdiv #|A|) A.

Definition max_abelem p B A := A == [set x \in 'C_B(A) | x ^+ p == 1].

Definition Elem p A :=
  [set E : {group gT} | (E \subset A) && abelem p E].

Definition Elem_for p n A :=
  [set E : {group gT} | (E \subset A) && abelem_for p n E].

Definition Elem_max p A :=
  [set E : {group gT} | max_abelem p A E].

Definition p_rank p A := \max_(E \in Elem p A) logn p #|E|.

Definition rank A := \max_(p <- primes #|A|) p_rank p A.

(*
Definition basis A X :=
   (1 \notin X) && (\big[direct_product/1]_(x \in X) <[x]> == A).

Definition abelian_type A :=
  if pick (basis A) is Some X then
    sort leq (maps order (enum (mem X)))
  else [::].

Definition homocyclic A :=
  abelian A && is_pgroup A && seq.constant (abelian_type A).
*)

Canonical Structure Osub_group pi A := Eval hnf in [group of Osub pi A].
Canonical Structure Ohm_group i A := Eval hnf in [group of Ohm i A].
Canonical Structure Mho_group i A := Eval hnf in [group of Mho i A].

End PgroupDefs.

Notation "''O_' pi ( G )" := (Osub pi G)
  (at level 8, pi at level 2, format "''O_' pi ( G )") : group_scope.
Notation "''O_' pi ( G )" := (Osub_group pi G) : subgroup_scope.

Notation "''O_' ( ~ pi ) ( G )" := 'O_(predC pi)(G)
  (at level 8, format "''O_' ( ~  pi ) ( G )") : group_scope.
Notation "''O_' ( ~ pi ) ( G )" := 'O_(predC pi)(G)%G : subgroup_scope.

Notation "''O_' [ p ] ( G )" := 'O_(pred1 p)(G)
  (at level 8, format "''O_' [ p ] ( G )") : group_scope.
Notation "''O_' [ p ] ( G )" := 'O_(pred1 p)(G)%G : subgroup_scope.

Notation "''O_' [ ~ p ] ( G )" := 'O_(~ pred1 p)(G)
  (at level 8, format "''O_' [ ~  p ] ( G )") : group_scope.
Notation "''O_' [ ~ p ] ( G )" := 'O_(~ pred1 p)(G)%G : subgroup_scope.

Notation "''Ohm_' i ( G )" := (Ohm i G)
  (at level 8, i at level 2, format "''Ohm_' i ( G )") : group_scope.
Notation "''Ohm_' i ( G )" := (Ohm_group i G) : subgroup_scope.

Notation "''Mho^' i ( G )" := (Mho i G)
  (at level 8, i at level 2, format "''Mho^' i ( G )") : group_scope.
Notation "''Mho^' i ( G )" := (Mho_group i G) : subgroup_scope.

Notation "''E_' p ( G )" := (Elem p G)
  (at level 8, p at level 2, format "''E_' p ( G )") : group_scope.

Notation "''E_' p ^ n ( G )" := (Elem_for p n G)
  (at level 8, p, n at level 2, format "''E_' p ^ n ( G )") : group_scope.

Notation "''E_' p ^* ( G )" := (Elem_max p G)
  (at level 8, p at level 2, format "''E_' p ^* ( G )") : group_scope.

Notation "''Syl_' p ( G )" := (Syl p G)
  (at level 8, p at level 2, format "''Syl_' p ( G )") : group_scope.

Notation "''Hall_' pi ( G )" := (Hall pi G)
  (at level 8, pi at level 2, format "''Hall_' pi ( G )") : group_scope.

Section PlengthDefs.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Type G : {group gT}.

Definition Osub2 p q A :=
 A :&: coset_of 'O_[~ p](A) @*^-1 'O_[q](A / 'O_[~p](A)).

Definition p_length_1 p A := p \notin primes #|A : Osub2 p p A|.

Canonical Structure Osub2_group p q G := Eval hnf in [group of Osub2 p q G].

End PlengthDefs.

Notation "''O_' [ ~ p , q ] ( G )" := (Osub2 p q G)
  (at level 8, format "''O_' [ ~ p ,  q ] ( G )") : group_scope.
Notation "''O_' [ ~ p , q ] ( G )" := (Osub2_group p q G) : subgroup_scope.

Section PgroupProps.

Variable gT : finGroupType.
Implicit Type pi : pred nat.
Implicit Types x y z : gT.
Implicit Types A B C D : {set gT}.
Implicit Types G H K P Q : {group gT}.

Lemma pi_group1 : forall pi, @pi_group gT pi 1.
Proof. by move=> pi; rewrite /pi_group cards1. Qed.

Lemma pgroup1 : forall p, @pgroup gT p 1.
Proof. by move=> p; exact: pi_group1. Qed.

Lemma pgroup_is_pgroup : forall p P, pgroup p P -> is_pgroup P.
Proof.
move=> p P; rewrite /is_pgroup /pgroup /pdiv /pi_group /pi_nat ltn_0group /=.
by case: primes => //= q prP; case/andP; move/eqP->; rewrite eqxx.
Qed.

Lemma is_pgroupP : forall P, is_pgroup P -> exists2 p, prime p & pgroup p P.
Proof.
move=> P; case: (ltnP 1 #|P|); first by move/prime_pdiv; exists (pdiv #|P|).
rewrite -trivg_card; move/trivgP=> -> _; exists 2 => //; exact: pgroup1.
Qed.

Lemma hallE : forall pi G H,
  hall pi G H = [&& H \subset G, pi_group pi H & pi_nat (predC pi) #|G : H|].
Proof.
move=> pi G H; apply/andP/andP; case=> sHG.
  move/eqP=> hallH; split; rewrite -?group_divn // /pi_group.
  by rewrite -(@pi_partC pi #|G|) // hallH divn_mulr ?pi_nat_part.
case/andP=> piH copiH; split=> //.
rewrite -(LaGrange sHG) pi_part_mul ?LaGrange //.
by rewrite part_pi_nat ?part_pi'_nat ?muln1.
Qed.

Lemma hall_is_hall : forall pi G H, hall pi G H -> is_hall G H.
Proof.
move=> pi G H; rewrite hallE; case/and3P=> sHG; case/andP=> _ piH copiH.
rewrite /is_hall sHG; rewrite coprime_pi_nat //.
apply: sub_pi_nat copiH => p; apply: contra; exact: (allP piH).
Qed.

Lemma is_hall_primes : forall G H, is_hall G H -> hall (mem (primes #|H|)) G H.
Proof.
move=> G H; case/andP=> sHG coHG.
by rewrite hallE sHG /pi_group pi_nat_primes -?coprime_pi_nat.
Qed.

Lemma is_hall_hall : forall G H, is_hall G H -> exists pi, hall pi G H.
Proof.
move=> G H hallH; exists (mem (primes #|H|) : pred _); exact: is_hall_primes.
Qed.

Lemma sylowE : forall A B p,
  sylow p A B = (B \subset A) && (#|B| == p_part p #|A|).
Proof. by move=> A B p; congr (_ && _ ); rewrite -p_part_pi. Qed.

Lemma is_sylowE : forall G P, is_sylow G P = is_pgroup P && is_hall G P.
Proof.
move=> G P; apply/idP/andP=> [sylP|[pgP]].
  split; move: sylP; last exact: hall_is_hall.
  by rewrite [is_sylow G P]hallE; case/and3P.
move/is_hall_primes; rewrite hallE; case/and3P=> sPG _; case/andP=> _ q'GP.
rewrite [is_sylow G P]hallE; apply/and4P; split=> //.
apply/allP=> q pr_q; apply: contra (allP q'GP _ pr_q) => /=; move/eqP=> def_q.
move: pr_q; rewrite !mem_primes ltn_0group // {4}def_q dvdn_pdiv !andbT.
by case/andP.
Qed.

Lemma is_sylowP : forall G P,
  reflect (exists2 p, prime p & sylow p G P) (is_sylow G P).
Proof.
move=> G P; case (ltnP 1 #|P|) => [lt1P |].
  apply: (iffP idP) => [|[p pr_p sylP]].
    by exists (pdiv #|P|); first exact: prime_pdiv.
  suff def_p: p = pdiv #|P| by rewrite def_p in sylP.
  rewrite [sylow p G P]hallE in sylP; case/and3P: sylP=> _; case/andP=> _.
  by move/allP; rewrite -primes_pdiv in lt1P; move/(_ _ lt1P); move/eqnP.
rewrite -trivg_card; move/trivgP->.
rewrite /is_sylow sylowE sub1G /p_part lognE cards1; left.
pose p := pdiv #|G|.+1; have pr_p: prime p by rewrite prime_pdiv ?ltnS.
exists p; rewrite // sylowE sub1G cards1 /p_part lognE pr_p /= andbC.
have: p %| #|G| + 1 by rewrite addn1 dvdn_pdiv.
rewrite {1}/dvdn; case: dvdnP => // [] [q ->].
by rewrite modn_addl_mul modn_small ?prime_gt1.
Qed.

Lemma pi_groupS : forall pi G H, H \subset G -> pi_group pi G -> pi_group pi H.
Proof. move=> pi G H sHG; apply: pi_nat_dvdn; exact: group_dvdn. Qed.

Lemma pgroupS : forall p G H, H \subset G -> pgroup p G -> pgroup p H.
Proof. move=> p; exact: pi_groupS. Qed.

End PgroupProps.

Section Morphim.

Variables (aT rT : finGroupType) (D : {group aT}) (f : {morphism D >-> rT}).
Implicit Type pi : pred nat.
Implicit Types G H P : {group aT}.

Lemma card_morphim : forall G, #|f @* G| = #|D :&: G : 'ker f|.
Proof.
move=> G; rewrite -morphimIdom -group_indexI -card_quotient; last first.
  by apply: subset_trans (normI _ _); rewrite subsetI normG subIset ?norm_ker.
by apply: esym (isog_card _); rewrite first_isom_loc ?subsetIl.
Qed.

Lemma dvdn_morphim :  forall G, #|f @* G| %| #|G|.
Proof.
move=> G; rewrite card_morphim (dvdn_trans (indexg_dvdn _ _)) //.
by rewrite group_dvdn ?subsetIr.
Qed.

Lemma morphim_pi_group : forall pi G, pi_group pi G -> pi_group pi (f @* G).
Proof. move=> pi G; apply: pi_nat_dvdn; exact: dvdn_morphim. Qed.

Lemma dvdn_morphim_index : forall G H,
  G :&: H \subset D -> #|f @* G : f @* H| %| #|G : H|.
Proof.
move=> G H dGH; apply: (@dvdn_trans #|f @* G : f @* (G :&: H)|).
  by rewrite -group_indexI dvdn_indexgS ?morphimI.
have: 0 < #|f @* (G :&: H)| * #|'ker_(D :&: G) f|.
  by rewrite ltn_0mul !ltn_0group.
move/dvdn_pmul2r <-; rewrite mulnCA !mulnA LaGrange ?(morphimS, subsetIl) //.
rewrite 2!card_morphim LaGrangeI.
have: 'ker_(D :&: (G :&: H)) f \subset 'ker_(D :&: G) f.
  by rewrite setSI ?setIS ?subsetIl.
move/LaGrange <-; rewrite !mulnA dvdn_mulr // -mulnA LaGrangeI /=.
by rewrite (setIidPr dGH) LaGrangeI group_dvdn ?subsetIr.
Qed.

Lemma morphim_pgroup : forall p P, pgroup p P -> pgroup p (f @* P).
Proof. move=> p; exact: morphim_pi_group. Qed.

Lemma morphim_pi_index : forall pi G H,
  H \subset D -> pi_nat pi #|G : H| -> pi_nat pi #|f @* G : f @* H|.
Proof.
move=> pi G H dH; apply: pi_nat_dvdn; apply: dvdn_morphim_index.
by rewrite subIset // orbC dH.
Qed.

Lemma morphim_hall : forall pi G H,
  H \subset D -> hall pi G H -> hall pi (f @* G) (f @* H).
Proof.
move=> pi G H dH; rewrite !hallE; case/and3P=> sHG piH pi'GH.
by rewrite morphimS // morphim_pi_group // morphim_pi_index.
Qed.

Lemma morphim_is_hall : forall G H,
   H \subset D -> is_hall G H -> is_hall (f @* G) (f @* H).
Proof.
move=> G H dH; case/is_hall_hall=> pi hallH; apply: (@hall_is_hall _ pi).
exact: morphim_hall.
Qed.

Lemma morphim_sylow : forall p G P,
  P \subset D -> sylow p G P -> sylow p (f @* G) (f @* P).
Proof. move=> p; exact: morphim_hall. Qed.

Lemma morphim_is_pgroup : forall P, is_pgroup P -> is_pgroup (f @* P).
Proof. move=> P; move/morphim_pgroup; exact: pgroup_is_pgroup. Qed.

Lemma morphim_is_sylow : forall G P,
  P \subset D -> is_sylow G P -> is_sylow (f @* G) (f @* P).
Proof.
move=> G P dP; rewrite !is_sylowE; case/andP=> pP hallP.
by rewrite morphim_is_pgroup // morphim_is_hall.
Qed.

End Morphim.

Section OhmProps.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Type G : {group gT}.

Lemma char_Ohm : forall i G, 'Ohm_i(G) \char G.
Proof.
move=> i G; have sOmG: 'Ohm_i(G) \subset G.
  by rewrite gen_subG; apply/subsetP=> x; rewrite inE; case/andP.
apply/charP; split=> // f injf fG; apply/morphim_fixP => //.
rewrite sub_morphim_pre // gen_subG; apply/subsetP=> x; rewrite inE.
case/andP=> Gx oxp; rewrite !inE Gx mem_gen // inE eq_sym -{2}fG.
by rewrite mem_imset ?setIid //= -morphX // (eqP oxp) morph1.
Qed.

Lemma exponentP : forall G n,
  reflect (forall x, x \in G -> x ^+ n = 1) (exponent G %| n).
Proof.
move=> G n; apply: (iffP idP) => [eGn x Gx | eGn].
  apply/eqP; rewrite -order_dvd; apply: dvdn_trans eGn.
  have def1: 1%N = \big[lcmn/0]_(x <- [::1] | x \in G) #[x : gT].
    by rewrite unlock /= group1 order1.
  rewrite /exponent def1 -big_cat_nested big_cat /= -{}def1.
  rewrite lcmnC (bigD1 1) // lcmnA order1 -[lcmn 1 1](order1 gT) -bigD1 //=.
  rewrite (bigD1 x) //=.
  case: {+}(reducebig _ _ _ _ _) => [|m]; first by rewrite lcmn0.
  rewrite -(@dvdn_pmul2r (gcdn #[x] m.+1)) ?ltn_0gcd ?orbT //.
  by rewrite muln_lcm_gcd ?dvdn_pmul2l ?ltn_0order // dvdn_gcdr.
rewrite /exponent; apply big_prop=> [|p q pn qn|x Gx]; last 1 first.
- by rewrite order_dvd eGn.
- exact: dvd1n.
case: (posnP p) => [-> | p_pos]; first by rewrite lcm0n.
case: (posnP q) => [-> | q_pos]; first by rewrite lcmn0.
rewrite -(@dvdn_pmul2r (gcdn p q)) ?ltn_0gcd ?p_pos ?muln_lcm_gcd //.
case/dvdnP: pn qn => r -> qr; rewrite -mulnA mulnCA dvdn_pmul2l //.
case: (bezoutr p q_pos) => m _; move/(dvdn_mull r).
by rewrite muln_addr mulnCA dvdn_addl // dvdn_mull.
Qed.

Lemma is_abelem_Ohm1P : forall G,
  abelian G -> reflect ('Ohm_1(G) = G) (is_abelem G).
Proof.
move=> G abelG; pose p := pdiv #|G|; pose G1 := [set x \in G | x ^+ p == 1].
have gG1: group_set G1.
  apply/group_setP; split=> [|x y]; rewrite !inE ?(exp1gn, group1) //=.
  case/andP=> Gx; move/eqP=> xp; case/andP=> Gy; move/eqP=> yp.
  rewrite groupM // expMgn ?(xp, yp, mulg1) //=; exact: (centsP abelG).
have ->: 'Ohm_1(G) = G1.
  apply/eqP; rewrite eqset_sub -{1}[G1](genGid (Group gG1)) genS.
    apply/subsetP=> x; rewrite /= !inE; case/andP=> Gx.
      by move=> xp; rewrite mem_gen // inE Gx expn1.
    by apply/subsetP=> x; rewrite !inE; case/andP=> ->; rewrite expn1.
rewrite /is_abelem /abelem -/p abelG.
apply: (iffP (exponentP _ _)) => [elemG | <- x].
  apply/setP=> x; rewrite inE; case Gx: (x \in G) => //=.
  apply/eqP; exact: elemG.
by rewrite inE; case/andP=> _; move/eqP.
Qed.

End OhmProps.

Section OsubProps.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Types G H : {group gT}.

Lemma Osub_max : forall pi G, pi_group pi 'O_pi(G) && ('O_pi(G) <| G).
Proof.
move=> pi G; rewrite /'O_pi(G).
apply big_prop => [| A B | H]; last by rewrite genGid.
  by rewrite /(_ <| _) gen0 pi_group1 /pi_group normaliser1 sub1G subsetT.
case/and3P=> piA sAG nAG; case/and3P=> piB sBG nBG.
rewrite -mulgenE -mulgen_idl -mulgen_idr.
apply/and3P; split; last 2 [by rewrite gen_subG subUset sAG].
  have gen_pos: 0 < #|<<_ : {set gT}>>| := pos_card_group _.
  rewrite /pi_group norm_mulgenE ?(subset_trans sAG) //.
  have: pi_nat pi (#|<<A>>| * #|<<B>>|) by rewrite pi_nat_mul //; exact/andP.
  by rewrite -card_mulG pi_nat_mul //; case/andP.
by apply: subset_trans (norm_mulgen _ _); rewrite subsetI nAG.
Qed.

Lemma pi_Osub : forall pi G, pi_group pi 'O_pi(G).
Proof. by move=> pi G; case/andP: (Osub_max pi G). Qed.

Lemma Osub_normal : forall pi G, 'O_pi(G) <| G.
Proof. by move=> pi G; case/andP: (Osub_max pi G). Qed.

Lemma subset_Osub : forall pi G H,
  pi_group pi H -> H <| G -> H \subset 'O_pi(G).
Proof.
move=> pi G H piH nHG; apply/subsetP=> x Hx; apply: mem_gen; apply/bigcupP.
by exists H; rewrite // piH.
Qed.

Lemma char_Osub : forall pi G, 'O_pi(G) \char G.
Proof.
move=> pi G.
have sOG: 'O_pi(G) \subset G by case/andP: (Osub_normal pi G).
apply/charP; split=> //= f injf fG; apply/morphim_fixP=> //.
apply: subset_Osub; first by rewrite morphim_pi_group ?pi_Osub.
by rewrite -{3}fG  morphim_normal ?Osub_normal.
Qed.

End OsubProps.

