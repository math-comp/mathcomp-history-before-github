Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype paths finfun ssralg bigops finset prime.
Require Import groups action morphisms group_perm automorphism normal cyclic.

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GroupScope.

(**********************************************************************)
(* Standard group notions and constructions based on the prime        *)
(* decomposition of the order of the group or its elements.           *)
(* -Predicates/definitions:                                           *)
(*   pi.-group P                                                      *)
(*        <-> pi.-nat #|P| (pi can be a prime p)                      *)
(*   pi.-elt pi x                                                     *)
(*        <-> pgroup p <[x]>                                          *)
(*   pi.-Hall(G) H                                                    *)
(*        <-> H is a Hall pi-subgroup of G (so #|H| = #|G|`_pi)       *)
(*   p.-Sylow(G) P                                                    *)
(*        <-> P is a Sylow p-subgroup of G (i.e., p.-Hall(G) P)       *)
(*   'Syl_p(G)                                                        *)
(*        == set of the p-Sylow subgroups of G                        *)
(*   p_group P, Sylow G P, Hall G H                                   *)
(*        <-> p.-group P, p.-Sylow(G) P, pi.-Hall(G) H for some p/pi  *)
(*   exponent G                                                       *)
(*        == \big[lcmn/1]_(x \in G) #[x].                             *)
(*   p.-abelem E                                                      *)
(*        <-> E is an elementary abelian p-group                      *)
(*   elementary_abelian E                                             *)
(*        <-> E is elementary abelian (abelem p E for some p)         *)
(*   'E_p(G), 'E_p^n(G), 'E_p^*(G), 'E^n(G)                           *)
(*        == the set of abelem p subgroups of G                       *)
(*           (resp., p-abelem of order p ^ n (<=> of rank n),         *)
(*            maximal p-abelem, elementary_abelian of rank n)         *)
(*   'm_p(G)                                                          *)
(*        == the p-rank of G (max of logn p #|E| for E in 'E_p(G))    *)
(*   'm(G)                                                            *)
(*        == the rank of G (max of 'r_p(G) for all p)                 *)
(*   basis G X                                                        *)
(*        <-> X is a basis for the abelian group G                    *)
(*   abel_type P                                                      *)
(*        == the abelian type of P, when P is an abelian p-group,     *)
(*           i.e., the sorted seq of #[x] for x in a basis X of P     *)
(*   homocyclic P                                                     *)
(*        == P is an abelian p-group whose abelian type is constant   *)
(*   'Ohm_n(P)                                                        *)
(*        == the group generated by the x \in P s.t. x ^+ (p ^ n) = 1 *)
(*           if P is p-group; the trivial group otherwise.            *)
(*   'Mho^n(P)                                                        *)
(*        == the group generated by the x ^+ (p ^ n) for x \in P      *)
(*           if P is p-group; the trivial group otherwise.            *)
(*   'O_pi(G)                                                         *)
(*        == the pi-core (the largest normal pi-subgroup) of G        *)
(*           (= the first term in the upper pi-series of G)           *)
(*           (relevant lemmas quote core)                             *)
(*   'O_{pi2, pi1}(G)                                                 *)
(*       == the pi1, pi2 -core of G, such that                        *)
(*          'O_{pi2, pi1}(G) / 'O_pi2(G) = 'O_pi1(G / 'O_pi2(G))      *)
(*     with 'O_pi2(G) <| 'O_{pi2, pi1}(G) <| G                        *)
(*   'O_{pi3, pi2, pi1}(G)                                            *)
(*       == the pi1, pi2, pi3 -core of G, similarly                   *)
(*   p.-length_1 p G                                                   *)
(*        <-> G = 'O_{p^', p, p^'}(G)                                 *)
(* Note that notions are always defined on sets even though their     *)
(* name indicates "group" properties; the actual definition of the    *)
(* notion never tests for the group property, since this property     *)
(* will always be provided by a (canonical) group structure.          *)
(**********************************************************************)

Section PigroupDefs.

(* We need to stage two sections because we want to quantify over pi *)
(* first.                                                            *)

Variable pi : nat_pred.
Variable gT : finGroupType.
Implicit Types A B : {set gT}.

Definition pi_group A := pi.-nat #|A|.

Definition pi_elt (x : gT) := pi.-nat #[x].

Definition Hall A B := (B \subset A) && coprime #|B| #|A : B|.

Definition piHall A B := [&& B \subset A, pi_group B & pi^'.-nat #|A : B|].

Definition p_core A :=
  << \bigcup_(G : {group gT} | pi_group G && (G <| A)) G >>.

Canonical Structure p_core_group A := Eval hnf in [group of p_core A].

End PigroupDefs.

Notation "pi .-group" := (@pi_group pi _)
  (at level 2, format "pi .-group") : group_scope.

Notation "pi .-elt" := (@pi_elt pi _)
  (at level 2, format "pi .-elt") : group_scope.

Notation "pi .-Hall ( G )" := (piHall pi G)
  (at level 8, format "pi .-Hall ( G )") : group_scope.

Notation "p .-Sylow ( G )" := (nat_pred_of_nat p).-Hall(G)
  (at level 8, format "p .-Sylow ( G )") : group_scope.

Prenex Implicits Hall.

Notation "''O_' pi ( G )" := (p_core pi G)
  (at level 8, pi at level 2, format "''O_' pi ( G )") : group_scope.
Notation "''O_' pi ( G )" := (p_core_group pi G) : subgroup_scope.

Section PcoreMod.

Variables (gT : finGroupType) (A : {set gT}) (pi : nat_pred) (B : {set gT}).

Definition p_core_mod := coset_of A @*^-1 'O_pi(B / A).
Canonical Structure p_core_mod_group := Eval hnf in [group of p_core_mod].

End PcoreMod.

(* Coq's n-ary notation facility is too brain-dead to be used here. *)
(* We need to repeat A in the notation to allow the group sructure  *)
(* to be inferred; a canonical functor structure might fix this.    *)
Notation "''O_{' p1 , p2 } ( A )" := (p_core_mod 'O_p1(A) p2 A)
  (at level 8, format "''O_{' p1 ,  p2 } ( A )") : group_scope.
Notation "''O_{' p1 , p2 , p3 } ( A )" := (p_core_mod 'O_{p1, p2}(A) p3 A)
  (at level 8, format "''O_{' p1 ,  p2 ,  p3 } ( A )") : group_scope.
Notation "''O_{' p1 , p2 } ( A )" :=
  (p_core_mod_group 'O_p1(A) p2 A) : subgroup_scope.
Notation "''O_{' p1 , p2 , p3 } ( A )" :=
  (p_core_mod_group 'O_{p1, p2}(A) p3 A) : subgroup_scope.

Section PgroupFunctor.

Implicit Type gT rT : finGroupType.

Variable F : forall gT, nat -> {set gT} -> {set gT}.
Hypothesis sF : forall p gT (G : {group gT}), F p G \subset G.
Hypothesis funF : forall p gT rT (G : {group gT}) (f : {morphism G >-> rT}),
  f @* (F p G) \subset F p (f @* G).

Section defs.

Variables (gT : finGroupType) (A : {set gT}).

Definition p_group := (pdiv #|A|).-group A.

Definition pgroup_functor := <<if p_group then F (pdiv #|A|) A else 1>>.

End defs.

Lemma pgroup_functor_1 : forall gT (G : {group gT}),
  ~~ p_group G -> pgroup_functor G = 1.
Proof. by move=> gT G npG; rewrite /pgroup_functor -if_neg npG genGid. Qed.

Lemma pgroup_functor_sub : forall gT (G : {group gT}),
  pgroup_functor G \subset G.
Proof. by move=> gT G; rewrite gen_subG; case: ifP; rewrite ?sub1G. Qed.

Lemma pgroup_functor1 : forall gT, pgroup_functor 1 = 1 :> {set gT}.
Proof. move=> gT; apply/trivgP; exact: pgroup_functor_sub. Qed.

Lemma pgroup_functor_p : forall (p : nat) gT (G : {group gT}),
  p.-group G -> pgroup_functor G = <<F p G>>.
Proof.
move=> p gT G pG; case: (leqP #|G| 1).
  rewrite -trivg_card; move/trivGP=> ->; apply/eqP.
  by rewrite pgroup_functor1 eqset_sub sub1G gen_subG sF.
move/prime_pdiv=> pr_p.
have def_p: pdiv #|G| = p by apply/eqP; exact: (pi_natP _ _ pG) (dvdn_pdiv _).
by rewrite /pgroup_functor /p_group def_p pG.
Qed.

Lemma morphim_pgroup_functor : forall gT rT
    (G : {group gT}) (f : {morphism G >-> rT}),
  f @* (pgroup_functor G) \subset pgroup_functor (f @* G).
Proof.
move=> gT rT G f; case pG: (p_group G); last first.
  by rewrite pgroup_functor_1 ?pG // morphim1 sub1G.
rewrite {1}/pgroup_functor pG morphim_gen //.
rewrite (@pgroup_functor_p (pdiv #|G|)) ?genS ?funF //.
by apply: p_nat_dvdn pG; exact: dvdn_morphim.
Qed.

End PgroupFunctor.

Section PgroupDefs.

Variables n p : nat.
Variable gT : finGroupType.
Implicit Types A B X : {set gT}.

Definition Syl A := [set P : {group gT} | p.-Sylow(A) P].

Definition Sylow A B := p_group B && Hall A B.

Definition p_length_1 A := 'O_{p^', p, p^'}(A) == A.

Definition Ohm_basis p A := [set x \in A | x ^+ (p ^ n) == 1].

Definition Mho_basis p A := (fun x => x ^+ (p ^ n)) @: A.

Definition exponent A := \big[lcmn/1%N]_(x \in A) #[x].

Definition abelem p A := abelian A && (exponent A %| p).

Definition elementary_abelian A := abelem (pdiv #|A|) A.

Definition Elem p A :=
  [set E : {group gT} | (E \subset A) && abelem p E].

Definition Elem_order p n A :=
  [set E : {group gT} | (E \subset A) && abelem p E && (#|E| == p ^ n)%N].

Definition Elem_rank n A := \bigcup_(p <- primes #|A|) Elem_order p n A.

Definition Elem_max p A :=
  [set E : {group gT} | [max E | (E \subset A) && abelem p E]].

Definition p_rank p A := \max_(E \in Elem p A) logn p #|E|.

Definition rank A := \max_(p <- primes #|A|) p_rank p A.

(*
Definition basis A X :=
   (1 \notin X) && (\big[direct_product/1]_(x \in X) <[x]> == A).


Definition abelian_type A :=
  if pick (basis A) is Some X then
    sort leq (maps order (enum (mem X)))
  else [::].

Definition homocyclic A :=
  abelian A && is_pgroup A && seq.constant (abelian_type A).
*)

End PgroupDefs.

Prenex Implicits p_group Sylow exponent rank.

Notation "''Syl_' p ( G )" := (Syl p G)
  (at level 8, p at level 2, format "''Syl_' p ( G )") : group_scope.

Notation "p .-length_1" := (@p_length_1 p _)
  (at level 2, format "p .-length_1") : group_scope.

Definition Ohm n := pgroup_functor (Ohm_basis n).
Canonical Structure Ohm_group n gT A := Eval hnf in [group of @Ohm n gT A].
Notation "''Ohm_' n ( G )" := (Ohm n G)
  (at level 8, n at level 2, format "''Ohm_' n ( G )") : group_scope.
Notation "''Ohm_' n ( G )" := (Ohm_group n G) : subgroup_scope.

Definition Mho n := pgroup_functor (Mho_basis n).
Canonical Structure Mho_group n gT A := Eval hnf in [group of @Mho n gT A].
Notation "''Mho^' n ( G )" := (Mho n G)
  (at level 8, n at level 2, format "''Mho^' n ( G )") : group_scope.
Notation "''Mho^' n ( G )" := (Mho_group n G) : subgroup_scope.

Notation "p .-abelem" := (abelem p)
  (at level 2, format "p .-abelem") : group_scope.

Notation "''E_' p ( G )" := (Elem p G)
  (at level 8, p at level 2, format "''E_' p ( G )") : group_scope.

Notation "''E_' p ^ n ( G )" := (Elem_order p n G)
  (at level 8, p, n at level 2, format "''E_' p ^ n ( G )") : group_scope.

Notation "''E' ^ n ( G )" := (Elem_rank n G)
  (at level 8, n at level 2, format "''E' ^ n ( G )") : group_scope.

Notation "''E_' p ^* ( G )" := (Elem_max p G)
  (at level 8, p at level 2, format "''E_' p ^* ( G )") : group_scope.

Section PgroupProps.

Variable gT : finGroupType.
Implicit Type pi : nat_pred.
Implicit Type p : nat.
Implicit Types x y z : gT.
Implicit Types A B C D : {set gT}.
Implicit Types G H K P Q : {group gT}.

Lemma pgroupP : forall pi G,
  reflect (forall p, prime p -> p %| #|G| -> p \in pi) (pi.-group G).
Proof. move=> pi G; exact: pi_natP. Qed.

Lemma pi_indexP : forall pi G H,
  reflect (forall p, prime p -> p %| #|G : H| -> p \in pi) (pi.-nat #|G : H|).
Proof. move=> pi G H; exact: pi_natP. Qed.

Lemma pgroup1 : forall pi, pi.-group (1 : {set gT}).
Proof. by move=> pi; rewrite /pi_group cards1. Qed.

Lemma pgroupS : forall pi G H, H \subset G -> pi.-group G -> pi.-group H.
Proof. move=> pi G H sHG; apply: p_nat_dvdn; exact: group_dvdn. Qed.

Lemma p_group_p : forall p P, p.-group P -> p_group P.
Proof.
move=> p P pgP; case: (leqP #|P| 1).
  rewrite -trivg_card; move/trivgP->; exact: pgroup1.
move/prime_pdiv=> pr_q; have:= pgroupP _ _ pgP _ pr_q (dvdn_pdiv _).
by rewrite /p_group; move/eqnP->.
Qed.

Lemma p_groupP : forall P, p_group P -> exists2 p, prime p & p.-group P.
Proof.
move=> P; case: (ltnP 1 #|P|); first by move/prime_pdiv; exists (pdiv #|P|).
rewrite -trivg_card; move/trivgP=> -> _; exists 2 => //; exact: pgroup1.
Qed.

Lemma card_Hall : forall pi G H, pi.-Hall(G) H -> #|H| = #|G|`_pi.
Proof.
move=> pi G H; case/and3P=> sHG piH pi'H.
rewrite -(LaGrange sHG) muln_part ?LaGrange //.
by rewrite part_p_nat // part_p'_nat ?muln1.
Qed.

Lemma Hall_sub : forall pi A B, pi.-Hall(A) B -> B \subset A.
Proof. by move=> pi A B; case/andP. Qed.

Lemma Hall_pi : forall pi A B, pi.-Hall(A) B -> pi.-group B.
Proof. by move=> pi A B; case/and3P. Qed.

Lemma piHallP : forall pi G H,
  reflect (H \subset G /\ #|H| = #|G|`_pi) (pi.-Hall(G) H). 
Proof.
move=> pi G H; apply: (iffP idP) => [piH | [sHG oH]].
  split; [exact: Hall_sub piH | exact: card_Hall].
rewrite /piHall sHG -group_divn // /pi_group oH.
by rewrite -{2}(@partnC pi #|G|) ?divn_mulr ?p_nat_part.
Qed.

Lemma piHallE : forall pi G H,
  pi.-Hall(G) H = (H \subset G) && (#|H| == #|G|`_pi).
Proof. by move=> pi G H; apply/piHallP/andP=> [] [->]; move/eqP. Qed.

Lemma pi_Hall : forall pi A B, pi.-Hall(A) B -> Hall A B.
Proof.
move=> pi A B; case/and3P=> sBA piB pi'B.
by rewrite /Hall sBA (p_nat_coprime piB).
Qed.

Lemma Hall_pi_of : forall G H, Hall G H -> (pi_of #|H|).-Hall(G) H.
Proof.
move=> G H; case/andP=> sHG coHG.
by rewrite /piHall sHG /pi_group p_nat_primes -?coprime_primes'.
Qed.

Lemma HallP : forall G H, Hall G H -> exists pi, pi.-Hall(G) H.
Proof. move=> G H HallH; exists (pi_of #|H|); exact: Hall_pi_of. Qed.

Lemma p_Sylow : forall p G P, p.-Sylow(G) P -> Sylow G P.
Proof.
by move=> p G P pP; rewrite /Sylow (p_group_p (Hall_pi pP)) (pi_Hall pP).
Qed.

Lemma Hall1 : forall G, Hall G 1.
Proof. by move=> G; rewrite /Hall sub1G cards1 coprime1n. Qed.

Lemma p_group1 : @p_group gT 1.
Proof. by rewrite (@p_group_p 2) ?pgroup1. Qed.

Lemma Sylow1 : forall G, Sylow G 1.
Proof. by move=> G; rewrite /Sylow p_group1 Hall1. Qed.

Lemma pi_of_exp : forall p n, n > 0 -> pi_of (p ^ n) = pi_of p.
Proof. by move=> p n n_pos; rewrite /pi_of primes_exp. Qed.

Lemma pi_of_prime : forall p, prime p -> pi_of p =i (p : nat_pred).
Proof. by move=> p pr_p q; rewrite /pi_of primes_prime // mem_seq1. Qed.

Lemma eq_piHall : forall pi1 pi2 A B,
  pi1 =i pi2 -> pi1.-Hall(A) B = pi2.-Hall(A) B.
Proof.
move=> pi1 pi2 A B eq_pi; congr [&& _, _ & _]; apply: eq_p_nat => // q.
congr (~~ _); exact: eq_pi.
Qed.

Lemma p'_natE : forall p n, prime p -> n > 0 -> p^'.-nat n = ~~ (p %| n).
Proof.
move=> p n pr_p n_pos; rewrite -prime_coprime //.
rewrite coprime_primes' // ?ltn_0prime //; apply: eq_p_nat => q.
by rewrite primes_prime // !inE /= mem_seq1.
Qed.

Lemma SylowP : forall G P,
  reflect (exists2 p, prime p & p.-Sylow(G) P) (Sylow G P).
Proof.
move=> G P; apply: (iffP idP) => [| [p _]]; last exact: p_Sylow.
case/andP; case/p_groupP=> p p_pr; case/p_natP=> // [[P1 _ | n oP]].
  have{p p_pr P1} ->: P = 1%G by apply/trivGP; rewrite trivg_card P1.
  pose p := pdiv #|G|.+1; have pr_p: prime p by rewrite prime_pdiv ?ltnS.
  exists p; rewrite // piHallE sub1G cards1 part_p'_nat //.
  apply/pgroupP=> q pr_q qG; apply/eqnP=> def_q.
  have: p %| #|G| + 1 by rewrite addn1 dvdn_pdiv.
  by rewrite dvdn_addr -def_q // euclid1.
move/Hall_pi_of; rewrite oP pi_of_exp // (eq_piHall _ _ (pi_of_prime _)) //.
by exists p.
Qed.

End PgroupProps.

Section ModP.

Variable (gT : finGroupType) (sT : finType).

Variable to : {action gT &-> sT}.

(***********************************************************************)
(*                                                                     *)
(*           The mod p lemma                                           *)
(*                                                                     *)
(***********************************************************************)

Lemma pgroup_fix_mod : forall p (G : {group gT}) (S : {set sT}),
   prime p -> p.-group G -> [acts (G | to) on S] ->
   #|S| %% p = #|'C_S(G | to)| %% p.
Proof.
move=> p G S prime_p; case/p_natP => // n cardG GactS; apply/eqP.
rewrite -(cardsID 'C(G | to)) eqn_mod_dvd (leq_addr, addKn) //.
set S1 := S :\: _; have: [acts (G | to) on S1].
  apply/actsP=> a Ga x; rewrite !in_setD (actsP GactS) //; congr (~~ _ && _).
  by apply: actsP Ga x; rewrite norm_act_fix ?normG.
move/acts_sum_card_orbit <-.
apply big_prop => // [m1 m2|X]; first exact: dvdn_add.
case/imsetP=> x; case/setDP=> _ nfx ->{X}.
have:= dvdn_orbit to G x; rewrite cardG.
case/dvdn_pfactor=> [//|[_|m _ ->]]; last exact: dvdn_mulr.
move/card_orbit1=> fix_x; case/afixP: nfx => a Ga; apply/set1P.
by rewrite -fix_x mem_imset.
Qed.

End ModP.

Section Morphim.

Variables (aT rT : finGroupType) (D : {group aT}) (f : {morphism D >-> rT}).
Implicit Type pi : nat_pred.
Implicit Types G H P : {group aT}.

Lemma morphim_pgroup : forall pi G, pi.-group G -> pi.-group (f @* G).
Proof. move=> pi G; apply: p_nat_dvdn; exact: dvdn_morphim. Qed.

Lemma morphim_pi_index : forall pi G H,
  H \subset D -> pi.-nat #|G : H| -> pi.-nat #|f @* G : f @* H|.
Proof.
move=> pi G H dH; apply: p_nat_dvdn; apply: dvdn_morphim_index.
by rewrite subIset // orbC dH.
Qed.

Lemma morphim_piHall : forall pi G H,
  H \subset D -> pi.-Hall(G) H -> pi.-Hall(f @* G) (f @* H).
Proof.
move=> pi G H dH; case/and3P=> sHG piH pi'GH.
by rewrite /piHall morphimS // morphim_pgroup // morphim_pi_index.
Qed.

Lemma morphim_Hall : forall G H,
   H \subset D -> Hall G H -> Hall (f @* G) (f @* H).
Proof.
move=> G H dH; case/HallP=> pi piH; apply: (@pi_Hall _ pi).
exact: morphim_piHall.
Qed.

Lemma morphim_pSylow : forall p G P,
  P \subset D -> p.-Sylow(G) P -> p.-Sylow(f @* G) (f @* P).
Proof. move=> p; exact: morphim_piHall. Qed.

Lemma morphim_p_group : forall P, p_group P -> p_group (f @* P).
Proof. move=> P; move/morphim_pgroup; exact: p_group_p. Qed.

Lemma morphim_Sylow : forall G P,
  P \subset D -> Sylow G P -> Sylow (f @* G) (f @* P).
Proof.
move=> G P dP; case/andP=> pP hallP.
by rewrite /Sylow morphim_p_group // morphim_Hall.
Qed.

End Morphim.

Section PiCoreProps.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Types G H : {group gT}.

Lemma core_max : forall pi G, pi.-group 'O_pi(G) && ('O_pi(G) <| G).
Proof.
move=> pi G; rewrite /'O_pi(G).
apply big_prop => [| A B | H]; last by rewrite genGid.
  by rewrite /(_ <| _) gen0 pgroup1 /pi_group normaliser1 sub1G subsetT.
case/and3P=> piA sAG nAG; case/and3P=> piB sBG nBG.
rewrite -mulgenE -mulgen_idl -mulgen_idr.
apply/and3P; split; last 2 [by rewrite gen_subG subUset sAG].
  have gen_pos: 0 < #|<<_ : {set gT}>>| := pos_card_group _.
  rewrite /pi_group norm_mulgenE ?(subset_trans sAG) //.
  have: pi.-nat (#|<<A>>| * #|<<B>>|)%N by rewrite p_nat_mul //; exact/andP.
  by rewrite -card_mulG p_nat_mul //; case/andP.
by apply: subset_trans (norm_mulgen _ _); rewrite subsetI nAG.
Qed.

Lemma pgroup_core : forall pi G, pi.-group 'O_pi(G).
Proof. by move=> pi G; case/andP: (core_max pi G). Qed.

Lemma core_normal : forall pi G, 'O_pi(G) <| G.
Proof. by move=> pi G; case/andP: (core_max pi G). Qed.

Lemma subset_core : forall pi G H, pi.-group H -> H <| G -> H \subset 'O_pi(G).
Proof.
move=> pi G H piH nHG; apply/subsetP=> x Hx; apply: mem_gen; apply/bigcupP.
by exists H; rewrite // piH.
Qed.

Lemma char_core : forall pi G, 'O_pi(G) \char G.
Proof.
move=> pi G.
have sOG: 'O_pi(G) \subset G by case/andP: (core_normal pi G).
apply/charP; split=> //= f injf fG; apply/morphim_fixP=> //.
apply: subset_core; first by rewrite morphim_pgroup ?pgroup_core.
by rewrite -{3}fG  morphim_normal ?core_normal.
Qed.

Lemma Cauchy : forall p G, prime p -> p %| #|G| -> {x | x \in G & #[x] = p}.
Proof.
move=> p G pr_p; elim: {G}_.+1 {-2}G (ltnSn #|G|) => // n IHn G; rewrite ltnS.
pose xpG := [pred x \in G | #[x] == p] => leGn pG.
case: (pickP xpG) => [x|no_x]; first by case/andP=> Gx; move/eqP; exists x.
have{pG n leGn IHn} pZ: p %| #|'C_G(G)|.
  have:= pG; rewrite -(cardsID 'C(G)) dvdn_addl //.
  have: [acts (G | 'J) on G :\: 'C(G)]; last move/acts_sum_card_orbit <-.
    by apply/actsP=> x Gx y; rewrite !inE -!mem_conjgV -centJ conjGid ?groupV.
  apply big_prop => // [|C]; first exact: dvdn_add.
  case/imsetP=> x; case/setDP=> Gx nCx ->{C}; rewrite card_orbit conjg_astab1.
  move: pG; rewrite -(LaGrange (subsetIl G 'C[x]%G)) euclid //; case/orP => //.
  case/IHn=> [|y]; last first.
    by case/setIP=> Gy _; move/eqP=> oyp; case/andP: (no_x y).
  apply: leq_trans leGn; apply: proper_card; rewrite properE subsetIl.
  by rewrite subsetI subset_refl /= -cent_set1 centsC sub1set.
suff: predC1 p p by case/eqP.
have: p^'.-group 'O_p^'(G) by exact: pgroup_core.
move/pgroupP; apply=> //; apply: dvdn_trans pZ (group_dvdn _).
apply/subsetP=> x; case/setIP=> Cx Gx.
rewrite -sub1set -gen_subG subset_core //; last first.
  rewrite /(_ <| _) cycle_h // (subset_trans _ (norm_gen _)) //.
  by rewrite -cent_set1 centsC sub1set.
apply/pgroupP=> q _ p_x; apply/eqP=> def_q; rewrite {q}def_q in p_x.
case/dvdnP: p_x => m ox; case/idP: (no_x (x ^+ m)) => /=.
have m_pos: 0 < m by rewrite -(ltn_pmul2r (ltn_0prime pr_p)) -ox ltn_0order.
by rewrite /= groupX //= order_gcd // [#[x]]ox gcdnC gcdn_mulr divn_mulr.
Qed.

End PiCoreProps.

Section OhmProps.

Section bases.

Variables (n p : nat) (gT rT : finGroupType).
Variables (G : {group gT}) (f : {morphism G >-> rT}).

Lemma Ohm_basis_sub : Ohm_basis n p G \subset G.
Proof. by apply/subsetP=> x; rewrite inE; case/andP. Qed.

Lemma Mho_basis_sub : Mho_basis n p G \subset G.
Proof. apply/subsetP=> y; case/imsetP=> x Gx ->; exact: groupX. Qed.

Lemma morphim_Ohm_basis :
  f @* (Ohm_basis n p G) \subset Ohm_basis n p (f @* G).
Proof.
apply/subsetP=> y; case/morphimP=> x _; rewrite inE; case/andP=> Gx oxpn ->.
by rewrite inE morphimEdom mem_imset //= -morphX // (eqP oxpn) morph1.
Qed.

Lemma morphim_Mho_basis : f @* (Mho_basis n p G) = Mho_basis n p (f @* G).
Proof.
rewrite morphimEdom morphimEsub ?Mho_basis_sub // /Mho_basis -!imset_comp.
by apply: dfequal_imset => x Gx; rewrite /= morphX.
Qed.

End bases.

Section generic.

Variables (n : nat) (gT : finGroupType).
Implicit Type rT : finGroupType.
Implicit Type G : {group gT}.

Hint Resolve Ohm_basis_sub Mho_basis_sub.

Lemma Ohm_subset : forall G, 'Ohm_n(G) \subset G.
Proof. exact: pgroup_functor_sub. Qed.

Lemma Mho_subset : forall G, 'Mho^n(G) \subset G.
Proof. exact: pgroup_functor_sub. Qed.

Hint Resolve Ohm_subset Mho_subset.

Lemma morphim_Ohm : forall rT G (f : {morphism G >-> rT}),
  f @* 'Ohm_n(G) \subset 'Ohm_n(f @* G).
Proof. by apply: morphim_pgroup_functor => //; exact: morphim_Ohm_basis. Qed.

Lemma morphim_Mho : forall rT G (f : {morphism G >-> rT}),
  f @* 'Mho^n(G) \subset 'Mho^n(f @* G).
Proof.
by apply: morphim_pgroup_functor => // p aT arT G f; rewrite morphim_Mho_basis.
Qed.

Lemma OhmE : forall (p : nat) G, p.-group G -> 'Ohm_n(G) = <<Ohm_basis n p G>>.
Proof. move=> p; exact: pgroup_functor_p. Qed.

Lemma MhoE : forall (p : nat) G, p.-group G -> 'Mho^n(G) = <<Mho_basis n p G>>.
Proof. move=> p; exact: pgroup_functor_p. Qed.

Lemma morphim_Mho_eq : forall rT G (f : {morphism G >-> rT}),
  p_group G -> f @* 'Mho^n(G) = 'Mho^n(f @* G).
Proof.
move=> rT G f; case/p_groupP=> p _ pG; rewrite (MhoE pG) morphim_gen //.
by rewrite morphim_Mho_basis -pgroup_functor_p // morphim_pgroup.
Qed.

(* Francois, this is the generic proof -- GG *)
Lemma char_Ohm : forall G, 'Ohm_n(G) \char G.
Proof.
move=> G; apply/charP; split=> //= f injf defG; apply/eqP.
rewrite eqset_sub_card /= -{4}defG morphim_Ohm card_morphim ker_injm //=.
by rewrite group_index1 /= (setIidPr _).
Qed.

Lemma char_Mho : forall G, 'Mho^n(G) \char G.
Proof.
move=> G; apply/charP; split=> //= f injf defG; apply/eqP.
rewrite eqset_sub_card /= -{4}defG morphim_Mho card_morphim ker_injm //=.
by rewrite group_index1 /= (setIidPr _).
Qed.

End generic.

Variable gT : finGroupType.
Implicit Type A : {set gT}.
Implicit Type G H E : {group gT}.
Implicit Type pi : nat_pred.

Lemma dvdn_exponent : forall x G, x \in G -> #[x] %| exponent G.
Proof. by move=> x G Gx; rewrite /exponent (bigD1 x) //= dvdn_lcml. Qed.

Lemma exponentP : forall G n,
  reflect (forall x, x \in G -> x ^+ n = 1) (exponent G %| n).
Proof.
move=> G n; apply: (iffP idP) => [eGn x Gx | eGn].
  apply/eqP; rewrite -order_dvd; apply: dvdn_trans eGn; exact: dvdn_exponent.
rewrite /exponent; apply big_prop=> [|p q|x Gx]; first exact: dvd1n.
  exact: dvdn_lcm.
by rewrite order_dvd eGn.
Qed.

Lemma trivg_exponent : forall G, trivg G = (exponent G %| 1).
Proof.
move=> G.
by apply/subsetP/exponentP=> trG x; move/trG; rewrite expg1; move/set1P.
Qed.

Lemma exponent1 : exponent (1 : {set gT}) = 1%N.
Proof. by apply/eqP; rewrite -dvdn1 -trivg_exponent trivg1. Qed.

Lemma exponent_dvdn : forall G, exponent G %| #|G|.
Proof.
by move=> G; apply/exponentP=> s Gx; apply/eqP; rewrite -order_dvd order_dvd_g.
Qed.

Lemma ltn_0exponent : forall G, 0 < exponent G.
Proof. move=> G; exact: ltn_0dvd (exponent_dvdn G). Qed.
Hint Resolve ltn_0exponent.

Lemma pi_exponent : forall pi G, pi.-nat (exponent G) = pi.-group G.
Proof.
move=> pi G; congr (_ && _); first by rewrite ltn_0group ltn_0exponent.
apply: eq_all_r=> p; rewrite !mem_primes ltn_0group ltn_0exponent /=.
case pr_p: (prime p) => //=; apply/idP/idP=> pG.
  exact: dvdn_trans pG (exponent_dvdn G).
case/Cauchy: pG => // x Gx <-; exact: dvdn_exponent.
Qed.

Lemma pgroup_abelem : forall p E, prime p -> p.-abelem E -> p.-group E.
Proof.
move=> p E pr_p; case/andP=> _ pE; rewrite -pi_exponent.
by apply: p_nat_dvdn pE _; rewrite p_nat_prime //= inE /=.
Qed.

Lemma abelemP : forall E,
  reflect (exists2 p, prime p & p.-abelem E) (elementary_abelian E).
Proof.
rewrite /elementary_abelian => E; case: (leqP #|E| 1).
  rewrite -trivg_card; move/trivgP->.
  by rewrite /abelem /abelian sub1G exponent1 cards1; left; exists 2.
move/prime_pdiv; set q := pdiv _ => pr_q; apply: (iffP idP); first by exists q.
case=> p pr_p pE; move/pgroupP: (pgroup_abelem pr_p pE).
by move/(_ q pr_q (dvdn_pdiv _)); move/eqnP->.
Qed.

Lemma abelem_Ohm1P : forall E,
  abelian E -> reflect ('Ohm_1(E) = E) (elementary_abelian E).
Proof.
move=> E abelE; apply: (iffP (abelemP E)) => [[p pr_p pAE] |].
  have pE: p.-group E by exact: pgroup_abelem.
  apply/eqP; rewrite eqset_sub Ohm_subset (OhmE 1 pE) sub_gen //.
  apply/subsetP=> x Ex; rewrite inE Ex expn1.
  by case/andP: pAE => _; move/exponentP=> -> /=.
case pE: (p_group E); last first.
  by rewrite /Ohm pgroup_functor_1 ?pE // => E1; rewrite -E1 p_group1 in pE.
case/p_groupP: pE => p pr_p pE; rewrite (OhmE 1 pE).
have gE1: group_set (Ohm_basis 1 p E).
  apply/group_setP; split=> [|x y]; rewrite !inE ?(exp1gn, group1) //=.
  case/andP=> Ex; move/eqP=> xp; case/andP=> Ey; move/eqP=> yp.
  rewrite groupM // expMgn ?(xp, yp, mulg1) //=; exact: (centsP abelE).
rewrite (genGid (Group gE1)) /= => def_E.
exists p; rewrite // /abelem abelE; apply/exponentP=> x.
by rewrite -def_E inE expn1; case/andP=> _; move/eqP.
Qed.

Lemma mem_Elem1 : forall G E,
  reflect (E \subset G /\ exists2 p, prime p & #|E| = p) (E \in 'E^1(G)).
Proof.
move=> G E; rewrite ['E^1(G)](big_sub 0) big_mkord.
apply: (iffP (bigcupP _ _ _)) => [/= [i _]|[sEG [p pr_p pE]]].
  set p := sub 0 _ i; have: p \in primes #|G| by rewrite mem_sub.
  rewrite inE -andbA expn1 mem_primes; case/andP=> pr_p _.
  by case/and3P; split=> //; exists p; last exact/eqP.
have pG: p \in primes #|G|.
  by rewrite mem_primes pr_p ltn_0group -pE group_dvdn.
have:= pG; rewrite -index_mem => lt_i; exists (Ordinal lt_i) => //=.
rewrite sub_index // inE sEG pE expn1 eqxx /= -andbA -pE exponent_dvdn !andbT.
case/primeP: pr_p => lt1p pr_p.
have: ~~ trivg E by rewrite trivg_card -ltnNge pE.
case/subsetPn=> x Ex nx1.
suff <-: <[x]> = E by apply/centsP; apply: commute_cycle_com.
apply/eqP; rewrite eqset_sub_card gen_subG sub1set Ex.
have:= order_dvd_g Ex; rewrite pE; move/pr_p; rewrite eqn_leq -trivg_card.
rewrite [trivg _]gen_subG sub1set (negPf nx1) /=; move/eqP=> <-; exact: leqnn.
Qed.

End OhmProps.

