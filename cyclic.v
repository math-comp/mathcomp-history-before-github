(***********************************************************************)
(* (c) Copyright Microsoft Corporation and Inria. All rights reserved. *)
(*                                                                     *)
(***********************************************************************)
(***********************************************************************)
(*                                                                     *)
(*  Properties of cyclic groups                                        *)
(*                                                                     *)
(***********************************************************************)
(* Definitions:                                                        *)
(* From groups.v:                                                      *)
(*   <[x]>         == the cycle (cyclic group) generated by x          *)
(*   #[x]          == the order of x, i.e., the cardinal of <[x]>.     *)
(* In this file:                                                       *)
(*   cyclic G      <=> G is a cyclic group.                            *)
(*   generator G x <=> x is a generator of the (cyclic) group G.       *)
(*   Zpm x         == the isomorphism between the additive group of    *)
(*                    integers mod #[x], and the group <[x]>           *)
(*   cyclem x n    == the endomorphism y |-> y ^+ n of <[x]>           *)
(*   Zp_unitm x    == the isomorphism from the multiplicative group of *)
(*                    the units of the ring of integers mod #[x], with *)
(*                    the group Aut <[x]> of automorphisms of <[x]>.   *)
(*                    (Zp_unitm x maps u to cyclem x u)                *)
(* Basic results for these notions, plus the classical result that     *)
(* any finite group isomorphic to a subggroup of a field is cycle,     *)
(* and the corollary that Aut G is cyclic when G is of prime order.    *)
(***********************************************************************)
Require Import ssreflect ssrbool ssrfun eqtype ssrnat.
Require Import seq fintype div prime ssralg poly.
Require Import finset groups morphisms automorphism normal perm zmodp.

(* Require Import paths connect bigops. *)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

(***********************************************************************)
(*                                                                     *)
(*  Cyclic group                                                       *)
(*                                                                     *)
(***********************************************************************)

Import GroupScope.

Section Cyclic.

Variable gT : finGroupType.
Implicit Types a x y : gT.
Implicit Types A B : {set gT}.
Implicit Types G H : {group gT}.

Definition cyclic A := existsb x, A == <[x]>.

Lemma cyclicP : forall A, reflect (exists x, A = <[x]>) (cyclic A).
Proof. move=> A; apply: (iffP existsP) => [] [x]; exists x; exact/eqP. Qed.

Lemma cycle_cyclic : forall x, cyclic <[x]>.
Proof. by move=> x; apply/cyclicP; exists x. Qed.

Lemma cycle1 : <[1]> = 1 :> {set gT}.
Proof. by apply/eqP; rewrite eqEsubset gen_subG !sub1G. Qed.

Lemma cyclic1 : cyclic [1 gT].
Proof. by rewrite -cycle1 cycle_cyclic. Qed.

Lemma cycle_id : forall a, a \in <[a]>.
Proof. by move=> a; rewrite mem_gen // set11. Qed.

Lemma cycle_subG : forall a H, (<[a]> \subset H) = (a \in H).
Proof. by move=> a H; rewrite gen_subG sub1set. Qed.

Lemma mem_cycle : forall a m, a ^+ m \in <[a]>.
Proof. by move=> a m; rewrite groupX // cycle_id. Qed.

Definition Zpm n a (i : 'I_n) := a ^+ i.

Lemma ZpmM : forall (n : pos_nat) a, a ^+ n = 1 ->
  {in Zp n &, {morph Zpm a : x y / x * y}}.
Proof.
rewrite /Zpm => n a an_1 [i _] [j _] _ _ /=; rewrite -expgn_add.
by rewrite {2}(divn_eq (i + j) n) expgn_add mulnC expgn_mul an_1 exp1gn mul1g.
Qed.

Lemma order1 : #[1 : gT] = 1%N.
Proof. by rewrite /order cycle1 cards1. Qed.

Lemma order_inf : forall a n, a ^+ n.+1 == 1 -> #[a] <= n.+1.
Proof.
move=> a [|n]; move/eqP; first by rewrite expg1 => ->; rewrite order1.
move/ZpmM=> zpM; rewrite -[n.+2]card_ord -cardsT.
apply: leq_trans (subset_leq_card _) (leq_imset_card (Morphism zpM) _).
rewrite -morphimEdom gen_subG sub1set /= morphimEdom /=.
apply/imsetP; exists (inord 1 : 'I_n.+2); first exact: in_setT.
by rewrite /Zpm inordK // expg1.
Qed.

Lemma Zpm_inj : forall a, injective (@Zpm #[a] a).
Proof.
move=> a i j; wlog ltij : i j / i < j.
  by case (ltngtP i j); [|symmetry|move/val_inj]; auto.
move/eqP; rewrite eq_mulVg1 /Zpm -(subnK ltij) addSnnS expgn_add mulKg.
move/order_inf; rewrite -leq_subS // subSS leqNgt; case/negP.
exact: leq_ltn_trans (leq_subr i j) _.
Qed.

Lemma Zpm_imset :  forall a, @Zpm #[a] a @: setT = <[a]>.
Proof.
move=> a; apply/eqP; rewrite eqEcard andbC.
rewrite (card_imset _ (@Zpm_inj a)) cardsT card_ord leqnn.
by apply/subsetP=> x; case/imsetP=> i _ ->; rewrite mem_cycle.
Qed.

Lemma cyclePmin : forall a b,
  reflect (exists2 m, m < #[a] & a ^+ m = b) (b \in <[a]>).
Proof.
move=> a b; rewrite -Zpm_imset.
apply: (iffP imsetP) => [[m] | [m ltma <-]]; first by exists (m : nat).
by exists (Ordinal ltma); rewrite ?inE.
Qed.

Lemma cycleP : forall a b, reflect (exists n, a ^+ n = b) (b \in <[a]>).
Proof.
move=> a b; apply: (iffP idP) => [|[n <-]]; last exact: mem_cycle.
by case/cyclePmin=> n; exists n.
Qed.

Lemma expg_order : forall a, a ^+ #[a] = 1.
Proof.
move=> a; have: a^-1 \in <[a]> by rewrite groupV cycle_id.
case/cyclePmin=> i; rewrite leq_eqVlt=> ltia a_i.
have{a_i} a_i1: a ^+ i.+1 = 1 by rewrite expgS a_i mulgV.
case/predU1P: ltia => [<- //| lti1a].
by have:= @Zpm_inj a (Ordinal lti1a) ord0 a_i1.
Qed.

Canonical Structure Zpm_morphism a := Morphism (ZpmM (expg_order a)).

Lemma injm_Zpm : forall a, 'injm (@Zpm #[a] a).
Proof. move=> a; apply/injmP; apply: in2W; exact: Zpm_inj. Qed.

Lemma Zp_isom : forall a, isom (Zp #[a]) <[a]> (Zpm a).
Proof.
move=> a; apply/isomP; split; last by rewrite morphimEdom Zpm_imset.
apply/injmP; apply: in2W; exact: Zpm_inj.
Qed.

Lemma Zp_isog : forall a, isog (Zp #[a]) <[a]>.
Proof. move=> a; exact: isom_isog (Zp_isom a). Qed.

Lemma cycle_decomp : forall a b,
  b \in <[a]> -> {m : nat | m < #[a] & a ^+ m = b}.
Proof.
move=> a b; rewrite -Zpm_imset [@imset _]unlock inE.
by case/diinv_exists=> [[m ltm]]; rewrite !inE /=; move/eqP; exists m.
Qed.

(***********************************************************************)
(*                                                                     *)
(*        Order Properties (1/2)                                       *)
(*                                                                     *)
(***********************************************************************)

Lemma cycleJ : forall a b, <[a ^ b]> = <[a]> :^ b.
Proof. by move=> a b; rewrite -genJ conjg_set1. Qed.

Lemma orderJ : forall a b, #[a ^ b] = #[a].
Proof. by move=> a b; rewrite /order cycleJ cardJg. Qed.

Lemma expg_mod_order : forall a k, a ^+ (k %% #[a]) = a ^+ k. 
Proof.
move=> a k; rewrite {2}(divn_eq k #[a]) expgn_add mulnC expgn_mul.
by rewrite expg_order exp1gn mul1g.
Qed.

(***********************************************************************)
(*                                                                     *)
(*        Central and direct product of cycles                         *)
(*                                                                     *)
(***********************************************************************)

Lemma cents_cycle : forall a b, commute a b -> <[a]> \subset 'C(<[b]>).
Proof.
move=> a b cab; rewrite gen_subG centsC cent_set1 cycle_subG; exact/cent1P.
Qed.

Lemma cycle_abelian : forall a, abelian <[a]>.
Proof. move=> a; exact: cents_cycle. Qed.

Lemma cyclic_abelian : forall A, cyclic A -> abelian A.
Proof. move=> A; case/cyclicP=> a ->; exact: cycle_abelian. Qed.

Lemma cycleMsub : forall a b,
  commute a b -> coprime #[a] #[b] -> <[a]> \subset <[a * b]>.
Proof.
move=> a b cab co_ab; apply/subsetP=> x; case/cycleP=> k <-{x}.
apply/cycleP; exists (chinese #[a] #[b] k 0).
rewrite expMgn // -expg_mod_order chinese_modl // expg_mod_order.
by rewrite /chinese addn0 -mulnA mulnCA expgn_mul expg_order exp1gn mulg1.
Qed.

Lemma cycleM : forall a b,
  commute a b -> coprime #[a] #[b] -> <[a * b]> = <[a]> * <[b]>.
Proof.
move=> a b cab co_ab; apply/eqP.
rewrite eqEsubset -(cent_mulgenEl (cents_cycle cab)).
rewrite mulgen_subG {3}cab !cycleMsub // 1?coprime_sym //.
by rewrite -genM_mulgen cycle_subG mem_gen // mem_imset2 ?cycle_id.
Qed.

(***********************************************************************)
(*                                                                     *)
(*        Order properties  (2/2)                                      *)
(*                                                                     *)
(***********************************************************************)

Lemma order_dvdn : forall a n, (#[a] %| n) = (a ^+ n == 1).
Proof.
move=> a n; rewrite -expg_mod_order -(expg0 a); apply/eqP/eqP=> [-> //|].
by have lt0a: 0 < #[a] by []; case/(@Zpm_inj a (inZp lt0a n) (Zp0 lt0a)).
Qed.

Lemma order_eq1 : forall a, (#[a] == 1%N) = (a == 1).
Proof. by move=> a; rewrite -dvdn1 order_dvdn expg1. Qed.

Lemma cycle_eq1 : forall a, (<[a]> == 1) = (a == 1).
Proof. by move=> a; rewrite -order_eq1 trivg_card1. Qed.

Lemma order_dvdG : forall (H : {group gT}) a, a \in H -> #[a] %| #|H|.
Proof. by move=> H a Ha; apply: cardSg; rewrite cycle_subG. Qed.

Lemma orderXdvd : forall a n, #[a ^+ n] %| #[a].
Proof. move=> a n; apply: order_dvdG; exact: mem_cycle. Qed.

Lemma orderXgcd : forall a n, #[a ^+ n] = #[a] %/ gcdn #[a] n.
Proof.
move=> a n; apply/eqP; rewrite eqn_dvd; apply/andP; split.
  rewrite order_dvdn -expgn_mul -gcdn_divnC //.
  by rewrite expgn_mul expg_order exp1gn.
case: (posnP n) => [-> | n_pos]; first by rewrite gcdn0 divnn ltn_0order dvd1n.
rewrite -(dvdn_pmul2r n_pos) divn_mulAC ?dvdn_gcdl // dvdn_lcm.
by rewrite order_dvdn mulnC expgn_mul expg_order eqxx dvdn_mulr.
Qed.

Lemma orderXdiv : forall a n, n %| #[a] -> #[a ^+ n] = #[a] %/ n.
Proof.
by move=> a n; case/dvdnP=> q defq; rewrite orderXgcd {2}defq gcdnC gcdn_mull.
Qed.

Lemma orderM : forall a b : gT,
  commute a b -> coprime #[a] #[b] -> #[a * b] = (#[a] * #[b])%N.
Proof. by move=> a b Hcom Hcop; rewrite -coprime_cardMg -?cycleM. Qed.

Lemma eq_expg_mod_order : forall x m n,
  (x ^+ m == x ^+ n) = (m == n %[mod #[x]]).
Proof.
move=> x m n; wlog le_nm: m n / n <= m.
  by move=> IH; case/orP: (leq_total m n); move/IH; rewrite // eq_sym => ->.
rewrite eqn_mod_dvd // -{1}(subnK le_nm) addnC expgn_add eq_mulgV1 mulgK.
by rewrite order_dvdn.
Qed.


(***********************************************************************)
(*                                                                     *)
(*        Generator                                                    *)
(*                                                                     *)
(***********************************************************************)

Definition generator (A : {set gT}) a := A == <[a]>.

Lemma generator_cycle : forall a, generator <[a]> a.
Proof. by move=> a; exact: eqxx. Qed.

Lemma cycle_generator : forall a x, generator <[a]> x -> x \in <[a]>.
Proof. move=> a x; move/(<[a]> =P _)->; exact: cycle_id. Qed.

Lemma generator_order : forall a b,
  generator <[a]> b -> #[a] = #[b].
Proof. by rewrite /order => a b; move/(<[a]> =P _)->. Qed.

Lemma cycleX : forall a n, <[a ^+ n]> \subset <[a]>.
Proof. move=> a n; rewrite cycle_subG; exact: mem_cycle. Qed.

Lemma cycleV : forall a, <[a^-1]> = <[a]>.
Proof.
move=> a; symmetry; apply/eqP; rewrite eqEsubset.
by rewrite !cycle_subG // -2!groupV invgK !cycle_id. 
Qed.

Lemma orderV : forall x, #[x^-1] = #[x].
Proof. by move=> x; rewrite /order cycleV. Qed.

End Cyclic.

(* Just for fun Euler's theorem *)

Theorem Euler: forall a n: pos_nat, coprime a n -> a ^ phi n  = 1 %[mod n ].
Proof.
move=> a n Cop.
have Ha': coprime n (inZp (valP n) a) by rewrite coprime_sym coprime_modl.
have Hp1: (ZpUnit Ha') ^+ (phi n) = 1.
  apply/eqP; rewrite -order_dvdn -card_Zp_units.
  by apply: cardSg; rewrite cycle_subG inE.
move/val_eqP: (@Zp_units_expgn n (ZpUnit Ha') (phi n)).
by rewrite /= modn_exp Hp1; move/eqP<-.
Qed.

Section CyclicSubGroup.

Variable gT : finGroupType.

(*  G. 1.3.1 (i) *)

Lemma cycle_sub_group : forall (a : gT) m, m %| #[a] ->
  [set H : {group gT} | (H \subset <[a]>) && (#|H| == m)]
     = [set <[a ^+ (#[a] %/ m)]>%G].
Proof.
move=> a m Hdiv.
have Hpos: 0 < m by apply (ltn_0dvd (ltn_0order a) Hdiv).
have Hcardm: #|<[a ^+ (#[a] %/ m)]>| == m.
  rewrite [#|_|]orderXgcd -(divn_pmul2r Hpos) muln_gcdl divnK // gcdnC.
  by rewrite gcdn_mulr mulKn.
apply/eqP; rewrite eqEsubset sub1set inE /= cycleX Hcardm !andbT.
apply/subsetP=> X; rewrite in_set1 inE -val_eqE /= eqEcard (eqP Hcardm).
case/andP=> sXa; move/eqP=> oX; rewrite oX leqnn andbT.
apply/subsetP=> x Xx; case/cycleP: (subsetP sXa _ Xx) => k def_x.
have: (x ^+ m == 1)%g by rewrite -oX -order_dvdn cardSg // gen_subG sub1set.
rewrite -def_x -expgn_mul -order_dvdn -[#[a]](LaGrange sXa) -oX mulnC.
rewrite dvdn_pmul2r // mulnK //; case/dvdnP=> i ->{def_x k}.
by rewrite mulnC expgn_mul groupX // cycle_id.
Qed.

Lemma cycle_subgroup_char : forall a (H : {group gT}),
  H \subset <[a]> -> H \char <[a]>.
Proof.
move=> a H sHa; apply: lone_subgroup_char => // J sJa isoJH.
have dvHa: #|H| %| #[a] by exact: cardSg.
have{dvHa} Huniq := esym (cycle_sub_group dvHa).
move/setP: Huniq => Huniq; move: (Huniq H) (Huniq J); rewrite !inE /=.
by rewrite sHa sJa (isog_card isoJH) eqxx; do 2!move/eqP <-.
Qed.

End CyclicSubGroup.

Section MorphicImage.

Variables aT rT : finGroupType.
Variables (D : {group aT}) (f : {morphism D >-> rT}) (x : aT).
Hypothesis Dx : x \in D.

Lemma morphim_cycle : f @* <[x]> = <[f x]>.
Proof. by rewrite morphim_gen (sub1set, morphim_set1). Qed.

Lemma morph_order : #[f x] %| #[x].
Proof. by rewrite order_dvdn -morphX // expg_order morph1. Qed.

Lemma morph_generator : forall A, generator A x -> generator (f @* A) (f x).
Proof. by move=> A; move/(A =P _)->; rewrite /generator morphim_cycle. Qed.

End MorphicImage.

Section CyclicProps.

Variables gT : finGroupType. 
Implicit Types G H K : {group gT}.
Implicit Types aT rT : finGroupType.

Lemma cyclicS : forall G H, H \subset G -> cyclic G -> cyclic H. 
Proof.
move=> G H HsubG; case/cyclicP=> x gex; apply/cyclicP.
exists (x ^+ (#[x] %/ #|H|)); apply: congr_group; apply/set1P.
by rewrite -cycle_sub_group /order -gex ?cardSg // inE HsubG eqxx.
Qed.

Lemma cyclicJ:  forall G x, cyclic (G :^ x) = cyclic G.
Proof.
move=> G x; apply/cyclicP/cyclicP=> [[y] | [y ->]].
  by move/(canRL (conjsgK x)); rewrite -cycleJ; exists (y ^ x^-1).
by exists (y ^ x); rewrite cycleJ.
Qed.

Lemma morphim_cyclic :  forall rT G H (f : {morphism G >-> rT}),
  cyclic H -> cyclic (f @* H).
Proof.
move=> rT G H f cH; wlog sHG: H cH / H \subset G.
  by rewrite -morphimIdom; apply; rewrite (cyclicS _ cH, subsetIl) ?subsetIr.
case/cyclicP: cH sHG => x ->; rewrite gen_subG sub1set => Gx.
by apply/cyclicP; exists (f x); rewrite morphim_cycle.
Qed.

Lemma quotient_cycle : forall x H, x \in 'N(H) -> <[x]> / H = <[coset H x]>.
Proof. move=> x H; exact: morphim_cycle. Qed.

Lemma quotient_cyclic : forall G H, cyclic G -> cyclic (G / H).
Proof. move=> G H; exact: morphim_cyclic. Qed.

Lemma quotient_generator : forall x G H,
  x \in 'N(H) -> generator G x -> generator (G / H) (coset H x).
Proof. by move=> x G H Nx; apply: morph_generator. Qed.

Lemma prime_cyclic : forall G, prime #|G| -> cyclic G.
Proof.
move=> G pG; case: (pickP (mem G^#)) => [x Hx| Hx]; last first.
  by move: pG; rewrite (cardsD1 1 G) group1 (eq_card0 Hx).
move: (Hx); rewrite /= in_setD1; case/andP => xD1; rewrite -cycle_subG=> xIG.
case/primeP: pG => _; move/(_ _ (cardSg xIG)); case/orP;  move/eqP.
  by rewrite (cardsD1 1) (cardsD1 x) group1 in_setD1 xD1 cycle_id.
move=> CxG; apply/cyclicP; exists x.
by apply/eqP; rewrite eq_sym eqEcard // CxG leqnn andbT.
Qed.

Lemma cyclic_small : forall G, #|G| <= 3 -> cyclic G.
Proof.
move=> G; rewrite 4!(ltnS, leq_eqVlt) -trivg_card_le1 orbA orbC.
case/predU1P=> [->|oG]; first exact: cyclic1.
by apply: prime_cyclic; case/pred2P: oG => ->.
Qed.

End CyclicProps.

Section IsoCyclic.

Variables gT rT : finGroupType.
Implicit Types G H : {group gT}.
Implicit Types M : {group rT}.

Lemma injm_cyclic :  forall G H (f : {morphism G >-> rT}),
  'injm f -> H \subset G -> cyclic (f @* H) = cyclic H.
Proof.
move=> G H f injf sHG; apply/idP/idP; last exact: morphim_cyclic.
rewrite -{2}(morphim_invm injf sHG); exact: morphim_cyclic.
Qed.

Lemma isog_cyclic :forall G M, G \isog M -> cyclic G = cyclic M.
Proof. by move=> G M; case/isogP=> f injf <-; rewrite injm_cyclic. Qed.

Lemma isog_cyclic_card : forall G M,
  cyclic G -> isog G M = cyclic M && (#|M| == #|G|).
Proof.
move=> G H cycG; apply/idP/idP=> [isoGM | ].
  by rewrite (isog_card isoGM) -(isog_cyclic isoGM) cycG /=.
case/cyclicP: cycG => x ->{G}; case/andP; case/cyclicP=> y ->{M} oy.
apply: isog_trans (isog_symr _) (Zp_isog y).
by rewrite ((order_pos_nat y =P order_pos_nat x) _) // Zp_isog.
Qed.

Lemma injm_generator : forall G H (f : {morphism G >-> rT}) x,
    'injm f -> x \in G -> H \subset G ->
  generator (f @* H) (f x) = generator H x.
Proof.
move=> G H f x injf Gx sHG; apply/idP/idP; last exact: morph_generator.
rewrite -{2}(morphim_invm injf sHG) -{2}(invmE injf Gx).
apply: morph_generator; exact: mem_morphim.
Qed.

End IsoCyclic.

(* A classic application to finite fields. The proof is slightly more *)
(* involved than it should be, because we're too early in the library *)
(* to use the structure theorem of abelian groups or p-constituents.  *)

Lemma fin_field_mul_group_cyclic :
  forall (gT : finGroupType) (G : {group gT}) (F : Field.field) (f : gT -> F),
    {in G &, {morph f : u v / u * v >-> (u * v)%R}} ->
    {in G, forall x, f x = 1%R <-> x = 1} ->
  cyclic G.
Proof.
move=> gT G F f fM f1P; have f1 : f 1 = 1%R by exact/f1P.
have fX: forall n, {in G, {morph f : u / u ^+ n >-> (u ^+ n)%R}}.
  by move=> n x Gx; elim: n => //= n <-; rewrite -fM ?groupX.
have f0: forall x, x \in G -> f x <> 0%R.
  move=> x Gx fx0; case: (@Ring.nonzero1r F).
  rewrite -f1 -(expg_order x) fX // fx0.
  by rewrite -(prednK (ltn_0order _)) /= Ring.mul0r.
have fV: {in G, {morph f : u / u^-1 >-> u^-1%R}}.
  move=> x Gx; apply: (mulfI (f0 x Gx)).
  by rewrite -fM ?groupV // mulVg mulfV //; apply: f0.
have injf: {in G &, injective f}.
  move=> x y Gx Gy /= eq_fxy; apply/eqP; rewrite eq_mulgV1; apply/eqP.
  by apply/f1P; rewrite ?fM ?fV ?groupM ?groupV // eq_fxy mulVf //; apply: f0.
have: exists H : {group _}, cyclic H && (H \subset G). 
  by exists [1 gT]%G; rewrite sub1G cyclic1.
case/ex_maxgroup=> H; case/maxgroupP; case/andP=> cycH; rewrite subEproper.
case/predU1P=> [<- //|]; case/andP=> sHG sGH maxH; set n := #|H|.
have defH: H :=: [set x \in G | #[x] %| n].
  apply/eqP; rewrite eqEcard; apply/andP; split.
    by apply/subsetP=> x Hx; rewrite inE (subsetP _ x Hx) ?cardSg ?cycle_subG.
  pose P : polynomial F := (\X ^+ n - \C 1)%R.
  have szP: size P = n.+1.
    by rewrite size_addl size_polyX_n // size_opp size_poly1 ltnS /n.
  rewrite -ltnS -szP cardE -(size_maps f) max_poly_roots //.
  - by rewrite size_poly0_eq szP.
  - rewrite uniq_maps_in ?uniq_enum //; apply: sub_in2 injf => x.
    by rewrite mem_enum inE; case/andP.
  apply/allP=> fx; case/mapsP=> x; rewrite mem_enum /= inE order_dvdn.
  case/andP=> Gx xn1 <-{fx}.
  by rewrite !(eval_poly_lin, eval_polyX_n) -fX // (eqP xn1) f1 Ring.subrr.
have [x def_x] := cyclicP H cycH; case/subsetPn: sGH => y Hy.
case/negP; rewrite defH inE Hy; apply/dvdn_partP=> // p.
rewrite mem_primes; case/and3P=> pr_p _ py.
rewrite p_part pfactor_dvdn // ?ltn_0group //.
set ky := logn p _; set kx := logn p n; rewrite leqNgt; apply/negP=> ltk.
set yp := y ^+ (#[y] %/ p ^ kx.+1); set xp' := x ^+ (n`_p).
have oyp : #[yp] = (p ^ kx.+1)%N.
  rewrite orderXgcd -[#[y]](partnC p) // p_part -/ky -(subnK ltk).
  rewrite expn_add -mulnA mulKn ?ltn_0exp ?ltn_0prime //.
  by rewrite gcdnC gcdn_mull mulnK // ltn_0mul ltn_0part ltn_0exp ?ltn_0prime.
have oypp : #[yp ^+ p] = n`_p.
  by rewrite orderXgcd oyp expnS gcdnC gcdn_mulr p_part mulKn ?ltn_0prime.
have oxp' : #[xp'] = n`_p^'.
  by rewrite orderXgcd -[#[x]](partnC p) // gcdnC /n def_x gcdn_mulr mulKn.
case Hyp: (yp \in H).
  by have:= order_dvdG Hyp; rewrite oyp pfactor_dvdn // ltnn.
have Gx: x \in G by rewrite -cycle_subG -def_x.
have yxpM: <[yp * xp']> = <[yp]> * <[xp']>.
  apply: cycleM.
    apply: injf; rewrite ?groupM ?fM ?groupX //; exact: Ring.mulrC. 
  rewrite oyp oxp'; apply: pnat_coprime (pnat_part _ _).
  by rewrite pnat_exp pnat_id.
case/negP: Hyp; rewrite -(maxH <[yp * xp']>%G).
- by rewrite -cycle_subG /= yxpM mulG_subl.
- by rewrite cycle_cyclic cycle_subG groupM ?groupX.
rewrite /= yxpM -((<[yp ^+ p]> * <[xp']> =P H) _) ?mulSg ?cycleX //.
rewrite eqEcard coprime_cardMg {1}[#|<[_]>|]oypp [#|<[_]>|]oxp'; last first.
  exact: coprime_partC.
rewrite /n partnC // mul_subG //= cycle_subG.
  by rewrite defH inE !groupX // oypp dvdn_part.
by rewrite def_x groupX ?cycle_id.
Qed.

(***********************************************************************)
(*                                                                     *)
(*       Automorphisms of cyclic groups                                *)
(*                                                                     *)
(***********************************************************************)

Section CyclicAutomorphism.

Variable gT : finGroupType.

Section CycleAutomorphism.

Variable a : gT.

Section CycleMorphism.

Variable n : nat.

Definition cyclem of gT := fun x : gT => x ^+ n.

Lemma cyclemM : {in <[a]> & , {morph cyclem a : x y / x * y}}.
Proof. move=> x y ax ay; apply: expMgn; exact: (centsP (cycle_abelian a)). Qed.

Canonical Structure cyclem_morphism := Morphism cyclemM.

End CycleMorphism.

Section ZpUnitMorphism.

Variable u : Zp_unit #[a].

Lemma injm_cyclem : 'injm (cyclem u a).
Proof.
apply/subsetP=> x; case/setIdP=> ax; rewrite !inE -order_dvdn.
rewrite -order_eq1 -dvdn1; move/eqnP: (valP u) => /= <-.
by rewrite dvdn_gcd order_dvdG.
Qed.

Lemma cyclem_dom : cyclem u a @* <[a]> = <[a]>.
Proof.
apply/morphim_fixP=> //; first exact: injm_cyclem.
by rewrite morphim_cycle ?cycle_id ?cycleX.
Qed.

Definition Zp_unitm := aut injm_cyclem cyclem_dom.

End ZpUnitMorphism.

Lemma Zp_unitmM : {in Zp_units #[a] &, {morph Zp_unitm : u v / u * v}}.
Proof.
move=> u v _ _; apply: (eq_Aut (Aut_aut _ _)) => [|x a_x].
  by rewrite groupM ?Aut_aut.
rewrite permM !autE ?groupX //= /cyclem -expgn_mul.
by rewrite -expg_mod_order modn_dvdm ?expg_mod_order // order_dvdG.
Qed.

Canonical Structure Zp_unit_morphism := Morphism Zp_unitmM.

Lemma injm_Zp_unitm : 'injm Zp_unitm.
Proof.
apply/subsetP=> u; case/morphpreP=> _; move/set1P=> /= um1.
have{um1}: Zp_unitm u a == Zp_unitm 1 a by rewrite um1 morph1.
by rewrite !autE ?cycle_id // eq_expg_mod_order !modZp inE.
Qed.

Lemma generator_coprime : forall m, generator <[a]> (a ^+ m) = coprime #[a] m.
Proof.
move=> m; rewrite /generator eq_sym eqEcard cycleX -/#[a] [#|_|]orderXgcd /=.
apply/idP/idP=> [le_a_am|co_am]; last by rewrite (eqnP co_am) divn1.
have am_pos: 0 < gcdn #[a] m by rewrite ltn_0gcd ltn_0order.
by rewrite /coprime eqn_leq am_pos andbT -(@leq_pmul2l #[a]) ?muln1 -?leq_divr.
Qed.

Lemma morphim_Zp_unitm : Zp_unitm @* Zp_units #[a] = Aut <[a]>.
Proof.
rewrite morphimEdom; apply/setP=> f; apply/imsetP/idP=> [[u _ ->] | Af].
  exact: Aut_aut.
pose n := invm (injm_Zpm a) (f a).
have a_fa: <[a]> = <[f a]>.
  by rewrite -(autmE Af) -morphim_cycle ?autm_dom ?cycle_id.
have def_n: a ^+ n = f a.
  by rewrite -/(Zpm a n) invmK // morphimEdom Zpm_imset a_fa cycle_id.
have co_a_n : coprime #[a] n by rewrite -generator_coprime def_n; exact/eqP.
exists (ZpUnit co_a_n); rewrite ?inE //.
apply: eq_Aut (Af) (Aut_aut _ _) _ => x ax.
rewrite autE //= /cyclem; case/cycleP: ax => k <-{x}.
by rewrite -(autmE Af) morphX ?cycle_id //= autmE -def_n -!expgn_mul mulnC.
Qed.

Lemma Zp_unit_isom : isom (Zp_units #[a]) (Aut <[a]>) Zp_unitm.
Proof. by apply/isomP; rewrite ?injm_Zp_unitm ?morphim_Zp_unitm. Qed.

Lemma Zp_unit_isog : isog (Zp_units #[a]) (Aut <[a]>).
Proof. exact: isom_isog Zp_unit_isom. Qed.

Lemma card_Aut_cycle : #|Aut <[a]>| = phi #[a].
Proof. by rewrite -(isog_card Zp_unit_isog) card_Zp_units. Qed.

Lemma phi_gen : phi #[a] = #|[set x | generator <[a]> x]|.
Proof.
rewrite -(card_injm (injm_invm (injm_Zpm a))).
  rewrite -card_Zp_units cardsE card_sub morphim_invmE; apply: eq_card => d.
  by rewrite !inE /= -generator_coprime.
rewrite /= morphimEdom Zpm_imset.
by apply/subsetP=> x; rewrite inE; exact: cycle_generator.
Qed.

Lemma Aut_cycle_abelian : abelian (Aut <[a]>).
Proof. by rewrite -morphim_Zp_unitm morphim_abelian ?Zp_units_abelian. Qed.

Lemma Aut_prime_cycle_cyclic : prime #[a] -> cyclic (Aut <[a]>).
Proof.
move=> pr_a; pose ff f := invm injm_Zp_unitm f : Fp_field pr_a.
apply: (@fin_field_mul_group_cyclic _ _ _ ff) => [f g Af Ag | f Af].
  by apply: val_inj; rewrite /ff morphM ?morphim_Zp_unitm.
split => [ff1 |->]; last by apply: val_inj; rewrite /ff morph1.
apply: (injm1 (injm_invm injm_Zp_unitm)); first by rewrite /= morphim_Zp_unitm.
by do 2!apply: val_inj; move/(congr1 val): ff1.
Qed.

End CycleAutomorphism.

Variable G : {group gT}.

Lemma Aut_cyclic_abelian : cyclic G -> abelian (Aut G).
Proof. case/cyclicP=> x ->; exact: Aut_cycle_abelian. Qed.

Lemma card_Aut_cyclic : cyclic G -> #|Aut G| = phi #|G|.
Proof. case/cyclicP=> x ->; exact: card_Aut_cycle. Qed.

Lemma Aut_prime_cyclic : prime #|G| -> cyclic (Aut G).
Proof.
move=> pr_G; case/cyclicP: (prime_cyclic pr_G) (pr_G) => x ->.
exact: Aut_prime_cycle_cyclic.
Qed.

End CyclicAutomorphism.
