\section{Small scale reflection}\label{sec:ssr}

The \ssr{} extension \cite{ssr} offers new syntax features for the
proof shell and a set of libraries making use of \emph{small scale
  reflection} in various respects. This layer above the standard
\Coq{} system provides a convenient framework for dealing with
structures equipped with a decidable equality. In this section, 
we comment on  the fundamental definitions present in the library and
how modularity is carried out throughout the development.

\subsection{Proof shell}\label{ssec:shell}

Proof scripts written with the \ssr{} extension have a very different
flavour than the ones developed using standard \Coq{} tactics. We are not 
going to present the proof shell extensively but only describe some 
simple features, that, we believe, have the most impact on productivity.
A script is a linear structure composed of tactics. Each tactic ends with
a period. 
An example of such a script is the following
\begin{lstlisting}
move=> x a H; apply: etrans (cardUI _ _).
  case: (a x); last by rewrite /= card0 card1.
  by rewrite [_ + x]addnC.
by rewrite {1}mem_filter /setI.
\end{lstlisting}
All the frequent bookkeeping operations that consists in moving, splitting, 
generalising formulae from (or to) the context are regrouped in 
a single tactic \C{move}.
For example, the tactic \C{move=> x a H} on the first line moves (introduces)
two constants \C{x} and \C{a} and an assumption \C{H} from the goal to the
context.

It is recommended practise to use indentation to display the control
structure of a proof. To further structure scripts, \ssr{}
supplies a \C{by} tactical to explicitly close off tactics. 
When replaying scripts, we then have the nice property that
an error immediately occurs when a closed tactic fails to prove its subgoal.
When composing tactics, the two tacticals \C{first} and
\C{last} let the user restrict the application of a tactic to only the
first or the last subgoal generated by the previous command. This
covers the frequent cases where a tactic generates two subgoals one of
which can be easily disposed of.  In practice, these two tacticals are
so effective at increasing the linearity of our scripts that, in fact,
we very rarely need more than two levels of indentation.

Finally, the \C{rewrite} tactic in \ssr{} provides a concise syntax
that allows a single command to perform a combination of conditional
rewriting, folding and unfolding of definitions, and simplification,
on selected patterns and even specific occurrences.
This makes rewriting much more user-friendly 
and contributes to shift the proof style towards equational reasoning.
In the standard library of \Coq, the \C{rewrite} tactic is roughly
used the same number of times as the \C{apply} tactic.
In our development for group theory, \C{rewrite} is used three times more than
\C{apply} --- despite the fact that, on average, each \ssr{} \C{rewrite}
stands for three \Coq{} \C{rewrite}s.

\subsection{Views}\label{ssec:ssr}

The \Coq{} system is based on an intuitionistic type theory, the Calculus
of Inductive Constructions \cite{werner,paulin}. In such a formalism, there is 
a distinction between logical propositions and boolean values.

On the one hand, logical propositions are objects
of \emph{sort} \C{Prop} which is the carrier of intuitionistic
reasoning. Logical connectives in \C{Prop} are \emph{types}, which give precise
information on the structure of their proofs; this information is
automatically exploited by \Coq{} tactics. For example, \Coq{} knows that a
proof of \C{A \\/ B} is either a proof of \C{A} or a proof of \C{B}.
The tactics \C{left} and \C{right} change the goal \C{A \\/ B}
to \C{A} and \C{B}, respectively; dually, the tactic \C{case} reduces the goal
\C{A \\/ B => G} to two subgoals \C{A => G} and \C{B => G}.

On the other hand, \C{bool} is an inductive \emph{datatype}
with two constructors \C{true} and \C{false}.
Logical connectives on \C{bool} are computable \emph{functions}, defined by
their truth tables, using case analysis:
\begin{lstlisting}
Definition (b$_1$ || b$_2$) := if b$_1$ then true else b$_2$.
\end{lstlisting}
Properties of such connectives are also established using case
analysis: the tactic \C{by case: b} solves the goal \C{b \|\| negb b = true}
by replacing \C{b} first by \C{true} and then by \C{false}; in either case,
the resulting subgoal reduces by computation to the trivial
\C{true = true}.

Thus, \C{Prop} and \C{bool} are truly complementary: the former supports robust natural deduction, the latter allows brute-force evaluation.
% Boolean predicates of the \Coq{} system support the preferred mode of
% classical reasoning, which is the computation of truth values
% tables. Reasoning in the \C{Prop} sort is mainly performed in a
% natural deduction style.
\ssr{} supplies
a generic mechanism to have the best of the two worlds and move freely 
from a propositional version of a
decidable predicate to its boolean version.

First, booleans are injected into propositions 
using the coercion mechanism:
\begin{lstlisting}
Coercion is_true (b: bool) := b = true.
\end{lstlisting}
This allows any boolean formula~\C{b} to be used in a context
where {\sc Coq} would expect a proposition, e.g., after \C{Lemma ... : }.
It is then interpreted as \C{(is_true b)}, i.e.,
the  proposition \C{b = true}. Coercions are elided by the prettyprinter,
so they are essentially transparent to the user.
Then, the inductive predicate \C{reflect}
is used to relate propositions and booleans
\begin{lstlisting}
Inductive reflect (P: Prop): bool -> Type :=
  | Reflect_true: P => reflect P true
  | Reflect_false: ~P => reflect P false.
\end{lstlisting}
The statement \C{(reflect P b)} asserts that \C{(is\_true b)}
and \C{P} are logically equivalent propositions. In the following, we use
the notation \C{P <-> b} for \C{(reflect P b)}.

For instance, the following lemma:
\begin{lstlisting}
Lemma andP: forall b$_1$ b$_2$, (b$_1$ /\ b$_2$) <-> (b$_1$ && b$_2$).
\end{lstlisting}
relates the boolean conjunction \C{\&\&} to
the logical one \lstinline[basicstyle=\footnotesize]+/\+. 
Note that in \C{andP}, \C{b$_1$} and \C{b$_2$} are two boolean variables and
the proposition \lstinline[basicstyle=\footnotesize]+b$_1$ /\ b$_2$+ hides two coercions.
The conjunction of \C{b$_1$} and \C{b$_2$} can then be viewed
as \C{b$_1$ /\\ b$_2$}  or as \C{b$_1$ && b$_2$}. 
A naming convention in \ssr{} is to postfix the name of view lemmas with \C{P}.
For example, \C{orP} relates  \C{\|\|} and \C{\\/}, \C{negP} relates  \C{negb} and \C{\~}.

Views are integrated to the proof language.
If we are to prove a goal of the form \C{(b$_1$ /\\ b$_2$) => G},
the tactic \C{case=> E$_1$  \ \ \  E$_2$} changes the goal to \C{G}
adding to the context the two assumptions
\C{E$_1$: b$_1$} and \C{E$_2$: b$_2$}.
To handle a goal of the form \\ \C{(b$_1$ \&\& b$_2$) => G}, we can simply annotate the tactic to specify an intermediate change of view: \C{case/andP=> E$_1$ \ \ \ \  E$_2$}.

Suppose now that our goal is \C{b$_1$ \&\& b$_2$}.
In order to split this goal into two subgoals, we use a combination of
two tactics: \C{apply/andP; split}.
The first tactic performs the change of view so that the 
second tactic can do the splitting. Note that if we happen to
have in the context an assumption \C{H: b$_1$},
instead of performing the splitting, the tactic
\C{rewrite H /=}, i.e., rewriting with \C{H} followed by  a simplification,
can directly be used to transform the goal \C{b$_1$ \&\& b$_2$} into \C{b$_2$}.


Views also provide a convenient way to choose between 
several (logical) characterisations of the same (computational)
definition, by having a view lemma per interpretation.
A trivial example is the ternary boolean conjunction.
If we have a goal of the form
\lstinline[basicstyle=\footnotesize]+b$_1$ && (b$_2$ && b$_3$) => G+,
applying the tactic \lstinline[basicstyle=\footnotesize]+case/andP+ leads to the
goal \lstinline[basicstyle=\footnotesize]+b$_1$ => b$_2$ && b$_3$ => G+.
We can also define an alternative view with
\begin{lstlisting}
Inductive and3 (P Q R : Prop) : Prop := And3 of P & Q & R.

Lemma and3P: forall b$_1$ b$_2$ b$_3$, (and3 b$_1$ b$_2$ b$_3$) <-> (b$_1$ && (b$_2$ && b$_3$)). 
\end{lstlisting}
Now, the tactic \lstinline[basicstyle=\footnotesize]+case/and3P+  directly transforms the goal
\lstinline[basicstyle=\footnotesize]+b$_1$ && (b$_2$ && b$_3$) => G+ into \lstinline[basicstyle=\footnotesize]+b$_1$ => b$_2$ => b$_3$ => G+.


\subsection{Libraries}\label{ssec:lib}


In our formalisation of finite groups, we reused the base libraries
initially  developed for the
formal proof of the \FCT. These libraries build a hierarchy of
structures using nested dependent record types. This technique is
standard in type-theoretic formalisations of abstract algebra \cite{bailey}.
At the bottom of this hierarchy, the structure \C{eqType} deals with
types with decidable equality.
\begin{lstlisting}
Structure eqType : Type := EqType {
    sort :> Type; 
  _ == _ :  sort -> sort -> bool; 
     eqP :  forall x y, (x = y) <-> (x == y)
}.
\end{lstlisting}
\noindent
The \C{:>} symbol declares \C{sort} as a coercion from an \C{eqType} to its
carrier type. It is the standard technique to get subtyping. If \C{d}
is an object of type \C{eqType}, then an object \C{x} can have the type
\C{x : d}, thanks to the \C{sort} coercion. The complete judgement is
in fact \C{x : sort d}. Moreover, if \C{x} and \C{y} are of type \C{sort d},
the term \C{x == y} is understood as the
projection of \C{d} on its second field, applied to \C{x} and \C{y}.
The implicit \C{d} parameter is both inferred and hidden from the user.

In the type theory of \Coq{}, the only relation we can freely rewrite with 
is the primitive (Leibniz) equality. When another
equivalence relation is the intended notion of equality on a given
type, the user usually needs to use the setoid
workaround \cite{BarCap}. Unfortunately, setoid rewriting does not have 
the same power as primitive rewriting.
An \C{eqType} structure provides not only a computable
equality \C{==} but also a proof \C{eqP} that this equality reflects the
Leibniz one;
the \C{eqP} view thus promotes \C{==} to a \emph{rewritable} relation.


A non parametric inductive type can usually be turned
into an \C{eqType} by choosing for \C{==} the function that
checks structural equality.
This is the case for booleans and natural numbers for
which we define the two {\it canonical structures} \C{bool_eqType} and \C{nat_eqType}.
Canonical structures are used when solving equations involving 
implicit arguments. Namely, if the type
checker needs to infer an \C{eqType} structure with \C{sort}
\C{nat}, it will automatically choose the \C{nat\_eqType}
structure. By enlarging the set of implicit arguments \Coq{} can infer,
canonical structures make hierarchical structures widely applicable.

A key property of \C{eqType} structures is that
they enjoy proof-irrelevance for the
equality proofs of their elements: every equality proof is
convertible to a reflected boolean test.

\begin{lstlisting}
Lemma eq_irrelevance: forall (d: eqType) (x y: d) (E: x = y) (E': x = y), E = E'.
\end{lstlisting}

%and in particular for the \C{bool\_eqType} structure:
%
%\begin{lstlisting}
%Lemma bool_irrelevance : forall (x y : bool) (E E' : x = y), E = E'.
%\end{lstlisting}
%

An \C{eqType} structure only defines a domain, in which sets take their elements. Sets are 
then represented by their characteristic function 
\begin{lstlisting}
Definition set (d: eqType) := d -> bool.
\end{lstlisting}
and defining set operations like $\cup$ and $\cap$
is done by providing the corresponding boolean functions.

The next step consists in building lists, elements of type \C{seq d}, 
whose elements belong to the parametric \C{eqType} structure \C{d}. The decidability of equality
on \C{d} is needed when defining the basic operations on
lists like membership \C{\\in} and look-up \C{index}. Then, membership
is used for defining a coercion from list to set, such
that \C{(l x)} is automatically coerced into \C{x \\in l}.

Lists are the cornerstone of the definition of finite types.  A
\C{finType} structure provides an enumeration of its \C{sort}: a
sequence in which each element of type \C{sort} occurs exactly once.
Note that \C{sort} must also have an \C{eqType} structure.

\begin{lstlisting}
Structure finType : Type := FinType {
  sort :> eqType;
  enum :  seq sort;
  enumP :  forall x, count (set1 x) enum = 1
}.
\end{lstlisting}
where \C{(set1 x)} is the set that contains only \C{x} and 
\C{(count f l}) computes the number of elements
\C{y} of the list \C{l} for which \C{(f y)} is true.

Finite sets are then sets whose domain has a \C{finType}
structure. The library provides many \C{set} operations.  For example,
given \C{A} a finite set, \C{(card A}) represents the cardinality of
\C{A}.  All these operations come along with their basic
properties. For example, we have:
\begin{lstlisting}
Lemma cardUI : forall (d: finType) (A B: set d), 
  card (A $\cup$ B) + card (A $\cap$ B) = card A + card B.
Lemma card_image : forall (d d': finType) (f: d -> d') (A: set d), 
     injective f => card (image f A) = card A.
\end{lstlisting}
