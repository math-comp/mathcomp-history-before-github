\section{Small scale reflection}\label{sec:ssr}

The \ssr{} extension \cite{ssr} offers new syntax features for the
proof shell and a bunch of libraries making use of \emph{small scale
  reflection} in various respects. This layer above the standard
\Coq{} system provides a convenient framework for dealing with
structures equipped with a decidable equality. In this section, 
we comment the fundamental definitions present in the library and
how modularity is carried out throughout the development.

\subsection{Proof shell}\label{ssec:shell}

Proof scripts written with the \ssr{} extension have a very different
flavour than the ones developed using standard \Coq{} tactics. We are not 
going to present the proof shell extensively but only describe some 
simple features, that, we believe, have a positive impact on productivity.
A  script is a linear structure composed of tactics. Each tactic ends with
a period. 
An example of such a script is the following
\begin{lstlisting}
move=> x a H; apply: etrans (cardUI _ _).
  case: (a x); last by rewrite /= card0 card1.
  by rewrite [_ + x]addnC.
by rewrite {1}mem_filter /setI.
\end{lstlisting}
All the frequent bookkeeping operations that consists in moving, splitting, 
generalising formulas from (or to) the context are regrouped in 
a single tactic \C{move}, making these operations more intuitive.
For example, the fact that arguments of the \C{move} at the first line of the example of
script are after the arrow indicates that the three arguments are the name to associate
to three formulas to move from the conclusion to the context.

Good practise recommends to outline the underlying structure
of the proof by indenting. To further structure scripts, \ssr{}
first proposes a tactical \C{by}
to explicitly tag closing tactics. 
When replaying scripts, we then have the nice property that
an error immediately occurs when a closing tactic fails to prove its subgoal. 
Second, when composing tactics, 
the two tacticals \C{first} and \C{last} let the user restrict the application of
a tactic to only the first or the last subgoal generated by the previous
command. It covers the frequents cases where a tactic generates 
two subgoals one of which can be easily discarded.
In practice, these two tactics 
are so effective at increasing the linearity of our scripts that,
in fact, it is very rare than more than two levels of indentation are needed.

Finally, the \C{rewrite} tactic in \ssr{} comes with a concise syntax to accommodate
in a single command
all the possible combinations of conditional rewriting, unfolding of definition,
simplifying, rewriting selecting specific occurrences, rewriting selecting
specific patterns, to name only some of them. Rewriting is then really convivial 
and contributes to a change of proof style more based on equational reasoning. 
In the standard library of \Coq, the \C{rewrite} tactic is roughly used the same number of times
than the tactic  \C{apply}.
In our development for group theory, \C{rewrite} is used three times more than
\C{apply} --- despite the fact that, on average, each \ssr{} \C{rewrite}
stands for three \Coq{} \C{rewrite}s.

\subsection{Views}\label{ssec:ssr}

The \Coq{} system is based on an intuitionistic type theory, the Calculus
of Inductive Constructions \cite{werner,paulin}. There is 
a distinction between logical propositions and boolean values.
On the one hand, logical propositions are objects
of \emph{sort} \C{Prop}, which is the carrier of intuitionistic
reasoning. On the other hand, \C{bool} is an
inductive datatype with two constructors \C{true} and \C{false}, for
which the term \\
\quad\C{fun b -> if b returns (b \|\| negb b = true) then refl_equal true
else refl_equal true}\\
is a proof of \C{forall b: bool, b \|\| negb b = true}. 
This proof does a dependent case analysis on {\tt b} and
returns in each case a proof of \C{true = true}, the term
\C{(refl_equal true)}, thanks to the fact that boolean functions are
computable.

Boolean predicates of the Coq system support the preferred mode of
classical reasoning, which is the computation of truth values
tables. Reasoning in the \C{Prop} sort is mainly performed in a
natural deduction style.
 The small scale reflection proposes 
a generic mechanism to have the best of the two worlds and move freely 
from a propositional version of a
decidable predicate to its boolean version.
For this, booleans are injected into propositions 
using the coercion mechanism:
\begin{lstlisting}
Coercion is_true (b: bool) := b = true.
\end{lstlisting}
Now, every time the {\sc Coq} system expects a proposition but receives a boolean \C{b}, 
it will automatically coerce it into the proposition \C{(is_true b)}, i.e
the  proposition \C{b = true}. Coercions are also omitted by the prettyprinter,
so everything is completely transparent to the user.
Then, the inductive predicate \C{reflect}
is used to relate propositions and booleans
\begin{lstlisting}
Inductive reflect (P: Prop): bool -> Type :=
  |  Reflect_true: P => reflect P true
  | Reflect_false: ~P => reflect P false.
\end{lstlisting}
The statement \C{(reflect b P)} indicates that \C{(is\_true b)}
and \C{P} are two logically equivalent propositions. In the following, we use
the notation \C{b <-> P} for \C{(reflect b P)}.
For instance, the following lemma:
\begin{lstlisting}
Lemma andP: forall b$_1$ b$_2$, (b$_1$ /\ b$_2$) <-> (b$_1$ && b$_2$).
\end{lstlisting}
relates the boolean conjunction \C{\&\&} and
the logical one \lstinline[basicstyle=\footnotesize]+/\+. 
Note that in \C{andP}, \C{b$_1$} and \C{b$_2$} are two boolean variables and
the proposition \lstinline[basicstyle=\footnotesize]+b$_1$ /\ b$_2$+ hides two coercions.
The conjunction of \C{b$_1$} and \C{b$_2$} can then be viewed
as \C{b$_1$ /\\ b$_2$}  or as \C{b$_1$ && b$_2$}. 
A naming convention in \ssr{} is to postfix the name of view lemmas with \C{P}.
For example, \C{orP} relates  \C{\|\|} and \C{\\/}, \C{negP} relates  \C{negb} and \C{\~}.

Views are integrated to the proof language.
If we are to prove a goal of the form \C{(b$_1$ /\\ b$_2$) -> G},
the tactic \C{case => E$_1$  \ \ \  E$_2$} changes the goal to \C{G}
adding to the context the two assumptions
\C{E$_1$: b$_1$} and \C{E$_2$: b$_2$}.
If the goal is of the form \C{(b$_1$ \&\& b$_2$) -> G} instead, we simply need
to change the tactic to  \C{case/andP=> E$_1$ \ \ \ \  E$_2$} to perform
the necessary intermediate change of view.

Suppose now that our goal is \C{b$_1$ \&\& b$_2$}.
In order to split this goal into two subgoals, we use a combination of
two tactics: \C{apply/andP; split}.
The first tactic performs the change of view so that the 
second tactic can do the splitting. Note that if we happen to
have in the context an assumption \C{H: b$_1$},
instead of performing the splitting, the tactic
\C{rewrite H /=}, i.e., rewriting with \C{H} followed by  a simplification,
can directly be used to transform the goal \C{b$_1$ \&\& b$_2$} into \C{b$_2$}.


Views also provide a convenient way to swap between 
several (logical) characterisations of the same (computational)
definition, having  a view lemma per interpretation.
A trivial example is the ternary boolean conjunction.
If we have a goal of the form \lstinline[basicstyle=\footnotesize]+b$_1$ && (b$_2$ && b$_3$) -> G+,
applying the tactic \lstinline[basicstyle=\footnotesize]+case/andP+ leads to the
goal \lstinline[basicstyle=\footnotesize]+b$_1$ -> b$_2$ && b$_3$ -> G+.
We can also define an alternative view with
\begin{lstlisting}
Inductive and3 (P Q R: Prop): Prop := And3: P -> Q -> R -> (and3 P Q R).

Lemma and3P: forall b$_1$ b$_2$ b$_3$, (and3 b$_1$ b$_2$ b$_3$) <-> (b$_1$ && (b$_2$ && b$_3$)). 
\end{lstlisting}
Now, the tactic \lstinline[basicstyle=\footnotesize]+case/and3P+  directly transforms the goal
\lstinline[basicstyle=\footnotesize]+b$_1$ && (b$_2$ && b$_3$) -> G+ into \lstinline[basicstyle=\footnotesize]+b$_1$ -> b$_2$ -> b$_3$ -> G+.


\subsection{Libraries}\label{ssec:lib}


In our formalisation of finite groups, we reused the base libraries
initially  developed for the
formal proof of the \FCT . They consist in a hierarchy of
structures and a substantial toolbox to work with finite types.
At the bottom of this hierarchy, the structure \C{eqType} deals with
types with decidable equality.
\begin{lstlisting}
Structure eqType : Type := EqType {
    sort :> Type; 
  _ == _ :  sort -> sort -> bool; 
     eqP :  forall x y, (x = y) <-> (x == y)
}.
\end{lstlisting}
\noindent
The \C{:>} symbol declares \C{sort} as a coercion from an \C{eqType} to its
carrier type. It is the standard technique to get subtyping,
an object of type \C{eqType} can then be viewed as an object of type \C{Type}.
In the type theory of \Coq{}, the only relation we can rewrite with 
is the primitive (Leibniz) equality. When another
equivalence relation is the intended notion of equality on a given
type, the user usually needs to use the setoid
workaround \cite{BarCap}. Unfortunately, setoid rewriting does not have 
the same power as primitive rewriting.
An \C{eqType} structure not only assumes the existence of a decidable
equality \C{==} but also \C{eqP} injects this equality into the
Leibniz one, thus promoting it to a \emph{rewritable} relation.


Any non parametric inductive type can be turned
into an \C{eqType} choosing for \C{==} the function that
checks structural equality.
This is the case for booleans and natural numbers for which a \C{bool_eqType} 
and \C{nat_eqType} are defined as {\it canonical structures}. Canonical
structures are used when solving equations involving 
implicit arguments. Namely, if the type
checker needs to infer an \C{eqType} structure on the type
\C{nat}, it will automatically choose as a default choice the \C{nat\_eqType}
type. By enlarging the set of implicit arguments \Coq{}
can infer, canonical structures ease the handling of the
hierarchy of structures.

A key property of \C{eqType} structures is that
they enjoy proof-irrelevance for the
equality proofs of their elements: every equality proof is
convertible to a reflected boolean test.

\begin{lstlisting}
Lemma eq_irrelevance: forall (d: eqType) (x y: d) (E: x = y) (E': x = y), E = E'.
\end{lstlisting}

%and in particular for the \C{bool\_eqType} structure:
%
%\begin{lstlisting}
%Lemma bool_irrelevance : forall (x y : bool) (E E' : x = y), E = E'.
%\end{lstlisting}
%

An \C{eqType} structure only defines a domain, in which sets take their elements. Sets are 
then represented by their characteristic function 
\begin{lstlisting}
Definition set (d: eqType) := d -> bool.
\end{lstlisting}
and defining set operations like $\cup$ and $\cap$
is done by providing the corresponding boolean functions.

The next step consists in building lists, elements of type \C{seq d}, 
whose elements belong to the parametric \C{eqType} structure \C{d}. The decidability of equality
on \C{d} is needed when defining the basic operations on
lists like membership \C{\\in} and look-up \C{index}. Then, membership
is used for defining a coercion from list to set, such
that \C{(l x)} is automatically coerced into \C{x \\in l}.

Lists are the cornerstone of the definition of finite types. 
A \C{finType} structure is composed of a list of
elements of an \C{eqType} structure, each element being unique.

\begin{lstlisting}
Structure finType : Type := FinType {
  sort :> eqType;
  enum :  seq  sort;
  enumP :  forall x, count (set1 x) enum = 1
}.
\end{lstlisting}
where \C{(set1 x)} is the set that contains only \C{x} and 
\C{(count f l}) computes the number of elements
\C{y} of the list \C{l} for which \C{(f y)} is true.

Finite sets are then sets taken in a \C{finType} domain. In the library,
the basic operations are provided.
For example, given \C{A} a finite set, \C{(card A}) represents the cardinality of \C{A}.
All these operations come along with their basic properties. For example, we have:
\begin{lstlisting}
Lemma cardUI : forall (d: finType) (A B: set d), 
  card (A $\cup$ B) + card (A $\cap$ B) = card A + card B.
Lemma card_image : forall (d d': finType) (f: d -> d') (A: set d), 
     injective f => card (image f A) = card A.
\end{lstlisting}
