Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div.
Require Import fintype bigops prime binomial finset ssralg.
Require Import groups morphisms normal automorphism commutators zmodp.
Require Import gprod cyclic center pgroups nilpotent sylow maximal.
Require Import matrix mxrepresentation BGsection1 BGsection2.

(******************************************************************************)
(* This file should contain the useful material in B & G, appendices A and B, *)
(* i.e., the proof of the p-stability properties and the ZJ-Theorem (or as it *)
(* were, the ZL-theorem.                                                      *)
(*  Definitions, drawn from Gorenstein, Chapter 8, and B & G, Appendix B:     *)
(*     p.-constrained G <-> the p',p core of G contains the centralisers of   *)
(*                          all its Sylow p-subgroups. This always holds for  *)
(*                          p-solvable (hence for solvable) groups, which is  *)
(*                          always the case in the Odd Order Theorem proof.   *)
(*          p.-stable G <-> a rather group theoretic generalization of the    *)
(*                          Hall-Higman type condition that in a faithful     *)
(*                          p-modular linear representation of G no p-element *)
(*                          has a quadratic minimal polynomial, to groups G   *)
(*                          with a non-trivial p-core.                        *)
(* p.-abelian_constrained <-> the p',p core of G contains all the normal      *)
(*                          abelian subgroups of the Sylow p-subgroups of G.  *)
(*                          It is via this property and the ZJ theorem (or    *)
(*                          rather its ZL^* substitute) that the p-stability  *)
(*                          of groups of odd order is exploited in the proof  *)
(*                          of the Odd Order Theorem.                         *)
(*        'L(G), 'L^*(G) == the Puig subgroups: the lower and upper limits    *)
(*                          of the sequence of subgroups of G defined by the  *)
(*                          recurrence :                                      *)
(*                           L_{i+1} = the group generated by the abelian     *)
(*                                     subgroups of G normalised by L_i       *)
(*                          We only define the notation for L_i locally, to   *)
(*                          avoid confusion with the lower central series.    *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Open Local Scope ring_scope.
Import GroupScope GRing.Theory.

Section Definitions.

Variables (gT : finGroupType) (p : nat) (G : {set gT}).
Implicit Types P A : {group gT}.

Definition p_constrained :=
  forall P, p.-Sylow('O_{p^',p}(G)) P -> 'C_G(P) \subset 'O_{p^',p}(G).

Definition p_abelian_constrained :=
  forall P A, p.-Sylow(G) P -> abelian A -> A <| P -> A \subset 'O_{p^',p}(G).

Definition p_stable :=
  forall P A,
     p.-subgroup(G) P -> 'O_p^'(G) * P <| G ->
     p.-subgroup('N_G(P)) A -> [~: P, A, A] = 1 ->
  A / 'C_G(P) \subset 'O_p('N_G(P) / 'C_G(P)).

End Definitions.

Notation "p .-constrained" := (p_constrained p)
  (at level 2, format "p .-constrained") : group_scope.
Notation "p .-abelian_constrained" := (p_abelian_constrained p)
  (at level 2, format "p .-abelian_constrained") : group_scope.
Notation "p .-stable" := (p_stable p)
  (at level 2, format "p .-stable") : group_scope.

Section Constrained.

Variables (gT : finGroupType) (p : nat) (G : {group gT}).

Lemma solvable_p_constrained : solvable G -> p.-constrained G.
Proof.
move=> solG P sylP; have [sPO pP _] := and3P sylP; pose K := 'O_p^'(G).
have nKG: G \subset 'N(K) by rewrite normal_norm ?pcore_normal.
have nKC: 'C_G(P) \subset 'N(K) by rewrite subIset ?nKG.
rewrite -(quotientSGK nKC) //; last first.
  by rewrite /= -pseries1 (pseries_sub_catl [::_]).
apply: subset_trans (quotient_subcent _ _ _) _ ;rewrite /= -/K.
suffices ->: P / K = 'O_p(G / K).
  rewrite quotient_pseries2 -Fitting_quotient_p'core -/K.
  by rewrite cent_sub_Fitting ?morphim_sol.
apply/eqP; rewrite eqEcard -(part_pnat (pcore_pgroup _ _)).
have sylPK: p.-Sylow('O_p(G / K)) (P / K).
  rewrite -quotient_pseries2 morphim_pHall //.
  exact: subset_trans (subset_trans sPO (pseries_sub _ _)) nKG.
by rewrite -(card_Hall sylPK) leqnn -quotient_pseries2 quotientS.
Qed.

(* This is Gorenstein, Proposition 8.1.3 *)
Lemma p_stable_abelian_constrained :
  p.-constrained G -> p.-stable G -> p.-abelian_constrained G.
Proof.
move=> constrG stabG P A sylP cAA; case/andP=> sAP nAP.
have [sPG pP _] := and3P sylP; have sAG := subset_trans sAP sPG.
set K2 := 'O_{p^', p}(G); pose K1 := 'O_p^'(G); pose Q := P :&: K2.
have sQG: Q \subset G by rewrite subIset ?sPG.
have nK1G: G \subset 'N(K1) by rewrite normal_norm ?pcore_normal.
have nsK2G: K2 <| G := pseries_normal _ _; have [sK2G nK2G] := andP nsK2G.
have sylQ: p.-Sylow(K2) Q by rewrite /Q setIC (pSylow_normalI nsK2G).
have defK2: K1 * Q = K2.
  have sK12: K1 \subset K2 by rewrite /K1 -pseries1 (pseries_sub_catl [::_]).
  apply/eqP; rewrite eqEsubset mulG_subG /= sK12 subsetIr /=.
  rewrite -quotientSK ?(subset_trans sK2G) //= quotientIG //= -/K1 -/K2.
  rewrite subsetI subxx andbT quotient_pseries2.
  by rewrite pcore_sub_Hall // morphim_pHall // ?(subset_trans sPG).
have{cAA} rQAA_1: [~: Q, A, A] = 1.
  by apply/commG1P; apply: subset_trans cAA; rewrite commg_subr subIset // nAP.
have nK2A := subset_trans sAG nK2G.
have sAN: A \subset 'N_G(Q) by rewrite subsetI sAG normsI // normsG.
have{stabG rQAA_1 defK2 sQG} stabA: A / 'C_G(Q) \subset 'O_p('N_G(Q) / 'C_G(Q)).
  apply: stabG; rewrite //= -/Q /psubgroup ?sAN ?(pgroupS sAP) //.
    by rewrite sQG (pgroupS (subsetIl _ _)).
  by rewrite defK2 pseries_normal.
rewrite -quotient_sub1 //= -/K2 -(setIidPr sAN).
have nK2N: 'N_G(Q) \subset 'N(K2) by rewrite subIset ?nK2G.
rewrite -[_ / _](morphim_restrm nK2N); set qK2 := restrm _ _.
have{constrG} fqKp: 'ker (coset 'C_G(Q)) \subset 'ker qK2.
  by rewrite ker_restrm !ker_coset subsetI subcent_sub constrG.
rewrite -(morphim_factm fqKp (subcent_norm _ _)) -(quotientE A _).
apply: subset_trans {stabA}(morphimS _ stabA) (subset_trans (pcore_resp _ _) _).
rewrite morphim_factm morphim_restrm setIid -quotientE.
rewrite /= -quotient_mulgr /= -/K2 (Frattini_arg _ sylQ) ?pseries_normal //.
by rewrite -quotient_pseries //= (pseries_rcons_id [::_]) trivg_quotient.
Qed.

End Constrained.

Section BGappendixA.

Implicit Type gT : finGroupType.
Implicit Type p : nat.

Import MatrixGenField.

(* This is B & G, Theorem A.4(c) (in Appendix A, not section 16!). We follow  *)
(* both B & G and Gorenstein in using the general form of the p-stable        *)
(* property. We could simplify the property because the conditions under      *)
(* which we prove p-stability are inherited by sections (morphic image in our *)
(* framework), and restrict to the case where P is normal in G. (Clearly the  *)
(* 'O_p^'(G) * P <| G premise plays no part in the proof.)                    *)
Lemma odd_p_stable : forall gT p (G : {group gT}), odd #|G| -> p.-stable G.
Proof.
move=> gT p; move: gT.
pose p_xp gT (E : {group gT}) x := p.-elt x && (x \in 'C([~: E, [set x]])).
suffices: forall gT (E : {group gT}) x y, let G := <<[set x; y]>> in
  [&& odd #|G|, p.-group E & G \subset 'N(E)] ->
  p_xp gT E x && p_xp gT E y -> p.-group (G / 'C(E)).
- move=> IH gT G oddG P A; case/andP=> sPG pP _; case/andP=> sANG pA cRA.
  apply/subsetP=> Cx; case/morphimP=> x Nx Ax ->{Cx}.
  have NGx := subsetP sANG x Ax.
  apply: Baer_Suzuki => [|Cy]; first exact: mem_quotient.
  case/morphimP=> y Ny NGy ->{Cy}; rewrite -morphJ // -!morphim_set1 ?groupJ //.
  rewrite -morphimU -morphim_gen ?subUset ?sub1set ?Nx ?groupJ //= -quotientE.
  set G1 := <<_>>; rewrite /pgroup -(isog_card (second_isog _)); last first.
    by rewrite mulgen_subG !sub1set Nx groupJ.
  case/setIP: NGx => Gx {Nx}Nx; case/setIP: NGy => Gy {Ny}Ny.
  have sG1G: G1 \subset G by rewrite mulgen_subG !sub1set groupJ ?andbT.
  have nPG1: G1 \subset 'N(P) by rewrite mulgen_subG !sub1set groupJ ?andbT.
  rewrite -setIA setICA (setIidPr sG1G).
  rewrite (isog_card (second_isog _)) ?norms_cent //.
  apply: IH => //; first by rewrite pP nPG1 (oddSg sG1G).
  rewrite /p_xp -{2}(normP Ny) -conjg_set1 -conjsRg centJ memJ_conjg.
  rewrite p_eltJ andbb (mem_p_elt pA) // -sub1set centsC (sameP commG1P trivgP).
  by rewrite -cRA !commgSS ?sub1set.
move=> gT E; move: {2}_.+1 (ltnSn #|E|) => n; elim: n => // n IHn in gT E *.
rewrite ltnS => leEn x y G; case/and3P=> oddG pE nEG.
case/and3P; case/andP => p_x cRx p_y cRy.
have [Gx Gy]: x \in G /\ y \in G.
  by apply/andP; rewrite -!sub1set -subUset subset_gen.
apply/idPn=> p'Gc; case/pgroupP: (p'Gc) => q q_pr qGc; apply/idPn => p'q.
have [Q sylQ] := Sylow_exists q [group of G].
have [sQG qQ]: Q \subset G /\ q.-group Q by case/and3P: sylQ.
have{qQ p'q} p'Q: p^'.-group Q by apply: sub_in_pnat qQ => q' _; move/eqnP->.
have{q q_pr sylQ qGc} ncEQ: ~~ (Q \subset 'C(E)).
  apply: contraL qGc => cEQ; rewrite -p'natE // -partn_eq1 //.
  have nCQ: Q \subset 'N('C(E)) by exact: subset_trans (normG _).
  have sylQc: q.-Sylow(G / 'C(E)) (Q / 'C(E)) by rewrite morphim_pSylow.
  by rewrite -(card_Hall sylQc) -trivg_card1 (sameP eqP trivgP) quotient_sub1.
have solE: solvable E := pgroup_sol pE.
have ntE: E :!=: 1 by apply: contra ncEQ; move/eqP->; rewrite cents1.
have{Q ncEQ p'Q sQG} minE_EG: minnormal E (E <*> G).
  apply/mingroupP; split=> [|D]; rewrite mulgen_subG ?ntE ?normG //.
  case/and3P=> ntD nDE nDG sDE; have nDGi := subsetP nDG.
  apply/eqP; rewrite eqEcard sDE leqNgt; apply: contra ncEQ => ltDE.
  have nDQ: Q \subset 'N(D) by rewrite (subset_trans sQG).
  have cDQ: Q \subset 'C(D).
    rewrite -quotient_sub1 ?norms_cent // ?[_ / _]card1_trivg //.
    apply: pnat_1 (morphim_pgroup _ p'Q); apply: pgroupS (quotientS _ sQG) _.
    apply: (IHn _ D (leq_trans ltDE leEn)); first by rewrite oddG (pgroupS sDE).
    rewrite /p_xp p_x p_y /=; apply/andP.
    by split; [move: cRx | move: cRy]; apply: subsetP; rewrite centS ?commSg.
  apply: (stable_factor_cent cDQ) solE; rewrite ?(pnat_coprime pE) //.
  apply/and3P; split; rewrite // -quotient_cents2 // centsC.
  rewrite -quotient_sub1 ?norms_cent ?quotient_norms ?(subset_trans sQG) //=.
  rewrite [(_ / _) / _]card1_trivg //=.
  apply: pnat_1 (morphim_pgroup _ (morphim_pgroup _ p'Q)).
  apply: pgroupS (quotientS _ (quotientS _ sQG)) _.
  have defGq: G / D = <<[set coset D x; coset D y]>>.
    by rewrite quotient_gen -1?gen_subG ?quotientU ?quotient_set1 ?nDGi.
  rewrite /= defGq IHn ?(leq_trans _ leEn) ?ltn_quotient // -?defGq.
    by rewrite quotient_odd // quotient_pgroup // quotient_norms.
  rewrite /p_xp -!sub1set !morph_p_elt -?quotient_set1 ?nDGi //=.
  by rewrite -!quotientR ?quotient_cents ?sub1set ?nDGi.
have abelE: p.-abelem E.
  by apply/andP; case: (minnormal_solvable minE_EG _ solE).
have cEE: abelian E by case/andP: abelE; case/andP.
have{minE_EG} minE: minnormal E G.
  case/mingroupP: minE_EG => _ minE; apply/mingroupP; rewrite ntE.
  split=> // D ntD sDE; apply: minE => //; rewrite mulgen_subG cents_norm //.
  by rewrite centsC (subset_trans sDE).
have nCG: G \subset 'N('C_G(E)) by rewrite normsI ?normG ?norms_cent.
suffices{p'Gc} pG'c: p.-group (G / 'C_G(E))^`(1).
  have [Pc sylPc sGc'Pc]:= Sylow_superset (der_sub _ _) pG'c.
  have nsPc: Pc <| G / 'C_G(E) by rewrite sub_der1_normal ?(pHall_sub sylPc).
  case/negP: p'Gc; rewrite /pgroup -(isog_card (second_isog _)) ?norms_cent //.
  rewrite setIC; apply: pgroupS (pHall_pgroup sylPc) => /=.
  rewrite sub_quotient_pre // mulgen_subG !sub1set !(subsetP nCG, inE) //=.
  by rewrite !(mem_normal_Hall sylPc) ?mem_quotient ?morph_p_elt ?(subsetP nCG).
have defC := rker_abelem abelE ntE nEG; rewrite /= -/G in defC.
set rG := abelem_repr _ _ _ in defC.
case ncxy: (rG x *m rG y == rG y *m rG x).
  have Cxy: [~ x, y] \in 'C_G(E).
    rewrite -defC inE groupR //= !repr_mxM ?groupM ?groupV // mul1mx -/rG.
    by rewrite (eqP ncxy) -!repr_mxM ?groupM ?groupV // mulKg mulVg repr_mx1.
  rewrite [_^`(1)](commG1P _) ?pgroup1 //= quotient_gen -gen_subG //= -/G.
  rewrite !gen_subG centsC gen_subG quotient_cents2r ?gen_subG //= -/G. 
  rewrite /commg_set imset2Ul !imset2_set1l !imsetU !imset_set1.
  by rewrite !subUset andbC !sub1set !commgg group1 /= -invg_comm groupV Cxy.
pose Ax : 'M(E) := rG x - 1; pose Ay : 'M(E) := rG y - 1.
have Ax2: Ax *m Ax = 0.
  apply/row_matrixP=> i; apply/eqP; rewrite row_mul mulmx_subr mulmx1.
  rewrite row0 subr_eq0 -(inj_eq (@rVabelem_inj _ _ _ abelE ntE)).
  rewrite rVabelemJ // conjgE -(centP cRx) ?mulKg //.
  rewrite linear_sub /= addrC row1 rowE rVabelemD rVabelemN rVabelemJ //=.
  by rewrite mem_commg ?set11 ?mem_rVabelem.
have Ay2: Ay *m Ay = 0.
  apply/row_matrixP=> i; apply/eqP; rewrite row_mul mulmx_subr mulmx1.
  rewrite row0 subr_eq0 -(inj_eq (@rVabelem_inj _ _ _ abelE ntE)).
  rewrite rVabelemJ // conjgE -(centP cRy) ?mulKg //.
  rewrite linear_sub /= addrC row1 rowE rVabelemD rVabelemN rVabelemJ //=.
  by rewrite mem_commg ?set11 ?mem_rVabelem.
pose A := Ax *m Ay + Ay *m Ax.
have cAG: centgmx rG A.
  rewrite /centgmx gen_subG subUset !sub1set !inE Gx Gy /=; apply/andP.
  rewrite -[rG x](subrK 1%R) -[rG y](subrK 1%R) -/Ax -/Ay.
  rewrite 2!(mulmx_addl _ 1 A) 2!(mulmx_addr A _ 1) !mulmx1 !mul1mx.
  rewrite !(inj_eq (@addIr _ A)) ![_ *m A]mulmx_addr ![A *m _]mulmx_addl.
  by rewrite -!mulmxA Ax2 Ay2 !mulmx0 !mulmxA Ax2 Ay2 !mul0mx !addr0 !add0r.
have irrG: mx_irreducible rG by exact/abelem_mx_irrP.
pose rAG := gen_repr irrG cAG; pose inFA := in_gen irrG cAG.
pose valFA := @val_gen _ _ _ _ _ _ irrG cAG.
set dA := gen_dim A in rAG inFA valFA.
rewrite -(rker_abelem abelE ntE nEG) -/rG -(rker_gen irrG cAG) -/rAG.
have dA_gt0: dA > 0 by rewrite (gen_dim_gt0 irrG cAG).
have irrAG: mx_irreducible rAG by exact: gen_mx_irr.
have: dA <= 2.
  case Ax0: (Ax == 0).
    by rewrite subr_eq0 in Ax0; case/eqP: ncxy; rewrite (eqP Ax0) mulmx1 mul1mx.
  case/rowV0Pn: Ax0 => v; case/subsetmxP => u def_v nzv.
  pose U := col_mx v (v *m Ay); pose UA := <<inFA _ U>>%MR.
  pose rvalFA := @rowval_gen _ _ _ _ _ _ irrG cAG.
  have Umod: submodmx rAG UA.
    rewrite /submodmx gen_subG subUset !sub1set !inE Gx Gy /= andbC.
    apply/andP; split; rewrite (eqmxMr _ (eqmx_gen _)) -in_genJ // eqmx_gen.
      rewrite subsetmx_in_gen // -[rG y](subrK 1%R) -/Ay mulmx_addr mulmx1.
      rewrite subsetmx_add // mul_col_mx -mulmxA Ay2 mulmx0.
      by rewrite -!eqmx_gsum gsummx0 gsummxSr.
    rewrite -[rG x](subrK 1%R) -/Ax mulmx_addr mulmx1 in_genD mul_col_mx.
    pose A' := A; rewrite -mulmxA -[Ay *m Ax](addKr (Ax *m Ay)) -/A mulmx_addr.
    rewrite -mulmxN mulmxA {1 2}def_v -(mulmxA u) Ax2 mulmx0 mul0mx add0r.
    rewrite -(mul0mx _ A') -mul_col_mx -[A'](mxval_groot irrG cAG).
    rewrite -[_ 0 v](in_genK irrG cAG) -val_genZ val_genK.
    rewrite subsetmx_add ?subsetmx_scale ?subsetmx_in_gen //.
    by rewrite -!eqmx_gsum gsum0mx gsummxSl.
  have nzU: UA != 0.
    rewrite -mxrank_eq0 eqmx_gen mxrank_eq0; apply/eqP.
    move/(canRL ((in_genK _ _) _)); rewrite val_gen0; apply/eqP.
    by rewrite -subsetmx0 -eqmx_gsum gsummx_sub subsetmx0 negb_and nzv.
  case/mx_irrP: irrAG => _; move/(_ UA Umod nzU); move/eqnP <-.
  by rewrite eqmx_gen rank_leq_row.
rewrite leq_eqVlt ltnS leq_eqVlt ltnNge dA_gt0 orbF orbC; case/pred2P=> def_dA.
  rewrite [_^`(1)](commG1P _) ?pgroup1 // quotient_cents2r // gen_subG.
  apply/subsetP=> zt; case/imset2P=> z t Gz Gt ->{zt}.
  rewrite !inE groupR //= mul1mx; have Gtz := groupM Gt Gz.
  rewrite -(inj_eq (can_inj (mulKmx (repr_mx_unit rAG Gtz)))) mulmx1.
  rewrite [eq_op]lock -repr_mxM ?groupR ?groupM // -commgC !repr_mxM // -lock.
  apply/eqP; move: (rAG z) (rAG t); rewrite /= -/dA def_dA => Az At.
  by rewrite [Az]mx11_scalar scalar_mxC.
move: (kquo_repr _) (kquo_mx_faithful rAG) => /=; set K := rker _.
rewrite def_dA => r2G; move/der1_odd_GL2_charf; move/implyP.
rewrite quotient_odd //= -/G; apply: etrans; apply: eq_pgroup => p'.
rewrite (fieldM_char (genRM _ _)) (charf_eq (char_Fp _)) //.
by case: (pgroup_1Vpr pE) (ntE) => [-> | [] //]; rewrite eqxx.
Qed.

End BGappendixA.

