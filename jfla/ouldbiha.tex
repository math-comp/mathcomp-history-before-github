\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}

\newcommand{\coq}{{\sc Coq}}
\newcommand{\ssr}{{\sc SSReflect}}

\title{ Formalisation des mathématiques : une preuve du théorème de Cayley-Hamilton $^*$ }

\author{Sidi Ould Biha $^1$}

\titlehead{Formalisation des mathématiques}%  a droite (page impaire)

\authorhead{Ould Biha}% a gauche (page paire)

\affiliation{\begin{tabular}{rr} 
\\ 1:  Inria de Sophia-Antipolis,
\\     2004, route des Lucioles - B.P. 93 06902 Sophia Antipolis Cedex, France
\\     {\tt Sidi.Ould\_biha@sophia.inria.fr} 
\\ $^*$:  Ce travail a été possible grâce au financement du laboratoire commun Microsoft-Inria
\\     {\tt http://www.msr-inria.inria.fr}
\end{tabular}}

\begin{document}
\setcounter{page}{1}
\maketitle

{\abstract 
Le théorème de Cayley-Hamilton est l'un des principaux théorèmes de l'algèbre linéaire. Dans cet article, nous présentons une première formalisation dans un assistant à la preuve de ce théorème. Cette formalisation a été développée dans Coq en utilisant son extension \ssr{} développée par G. Gonthier. Ce travail repose sur des développements sur les matrices, les polynômes et les opérations indexées. Il rentre dans le cadre des travaux de formalisation du théorème de Feit-Thompson sur les groupes solvables. }
% Ici commence votre texte

\section{Introduction}
Les systèmes de preuves formelles peuvent être d'une grande utilité dans la vérification et la validation de preuves mathématiques, surtout lorsque ces preuves sont complexes et longues. Les travaux récents, comme la preuve formelle du théorème des 4 couleurs~\cite{4colproof} ou celle du théorème des nombres premiers~\cite{primeth}, montrent que ces systèmes ont atteint un niveau de maturité leur permettant de s'attaquer à des problèmes mathématiques non triviaux. Le travail de formalisation de preuves mathématiques faisant intervenir une large variété d'objets mathématiques nécessite l'adoption d'une approche semblable au génie logiciel. La formalisation de telles théories peut être vue comme un développement faisant intervenir différentes composantes : définitions et preuves mathématiques.
\paragraph*{}
Une liste des 100 plus grands théorèmes mathématiques~\cite{100ths} a été constituée par Paul et Jack Abad. Cette liste prend en compte la place du théorème dans la littérature mathématique, la qualité de sa preuve et l'importance du résultat qu'il introduit. F. Wiedijk maintient une liste~\cite{100th} qui recense les formalisations de ces théorèmes dans différents systèmes de preuves formelles. Le théorème de Cayley-Hamilton est l'un des théorèmes présents dans cette liste. Ce papier présente à notre connaissance, la première formalisation de ce théorème. Le fait qu'il n'avait pas été jusqu'à ce jour formalisé peut s'expliquer par le fait qu'il fait intervenir de nombreux objets et propriétés mathématiques de nature différente (algèbre linéaire, multilinéaire, combinatoire, ..). Ces objets ne sont pas uniquement utilisés de façon indépendante, au contraire ils s'emboîtent les uns avec les autres. Ce travail de formalisation du théorème de Cayley-Hamilton est utilisé dans le cadre des travaux de formalisation du théorème de Feit-Thompson sur les groupes d'ordre impair. L'objectif n'est pas seulement de formaliser Cayley-Hamilton mais d'organiser la preuve en bibliothèques réutilisables. 
\paragraph*{}
L'article est organisé comme suit. Dans la section 2, nous présentons l'énoncé et la preuve du théorème de Cayley-Hamilton. Dans la section 3, nous présentons brièvement \ssr{}, l'extension de \coq{} développée par G. Gonthier pour la preuve du théorème des 4 couleurs, et plate-forme de notre développement. Enfin, dans la section 4, nous présentons le développement qui a été nécessaire pour arriver à la formalisation du théorème de Cayley-Hamilton. 

\section{Le théorème de Cayley-Hamilton}
Le théorème de Cayley-Hamilton, qui porte le nom des mathématiciens Arthur Cayley(1821-1895) et William Hamilton(1805-1865), est un résultat important de l'algèbre linéaire. Il peut être énoncé de la façon suivante : 
\begin{center}
 \textit{Toute matrice carrée sur un anneau commutatif annule son polynôme caractéristique.}
\end{center}
Plus formellement, soient $R$ un anneau commutatif et $A$ une matrice carrée sur $R$. Alors, le polynôme caractéristique de $A$, défini par : $p_{A}(x) = \det{(xI_{n} - A)}$, s'annule en A.
\newline
Le théorème peut être énoncé différemment en considérant les endomorphismes d'espace vectoriel. Dans ce cas il n'est plus question d'anneau commutatif mais de corps.
\paragraph*{}
Le théorème de Cayley-Hamilton est utilisé pour faire des calculs sur les matrices carrées (ou les endomorphismes) : calcul de la matrice inverse ou calcul des valeurs propres. Un corolaire de ce théorème est le résultat selon lequel, le polynôme minimal d'une matrice donnée est un diviseur de son polynôme caractéristique. 
\paragraph*{}
La preuve du théorème de Cayley-Hamilton présentée dans ~\cite{algebra} découle de la formule de Cramer. En notant  $^t{{\rm com} B} $ la transposée de la co-matrice de $B$, la règle de Cramer est :
\begin{equation}
  \label{Cramer}
 B * {}^t{{\rm com} B} = {}^t{{\rm com} B} * B =\det{B} * I_{n}
\end{equation}
En appliquant la formule (\ref{Cramer}) à la matrice $(xI_{n} - A) \in M_{n}(R[x])$, nous obtenons :
\begin{equation}
  \label{Cramer-mx_poly}
 {}^t{{\rm com} (xI_{n} - A)} * (xI_{n} - A) =\det{(xI_{n} - A)} * I_{n} = p_{A}(x) * I_{n}
\end{equation}
L'anneau $ M_{n}(R[x])$ des matrices de polynômes est aussi celui des polynômes à coefficients matriciels $(M_{n}(R))[X]$. L'égalité (\ref{Cramer-mx_poly}) s'écrit ainsi dans $(M_{n}(R))[X] $  : 
\begin{equation}
  \label{proof_start}
   {}^t{{\rm com} (xI_{n} - A)} * (X - A) = p_{A}(X)
\end{equation}
Ceci montre que $(X - A)$ est facteur de $p_{A}(X)$ dans $(M_{n}(R))[X] $ et donc $ p_{A}(A) = O_{n} $.
\paragraph*{}
Formaliser une preuve mathématique dans un assistant à la preuve consiste à développer cette preuve pour qu'elle soit compréhensible pour un ordinateur. Pour arriver à cet objectif deux difficultés sont à surmonter. En premier lieu, il faut expliciter les parties de la preuve qui sont implicites ou ``triviales'' pour un mathématicien. Paradoxalement, l'implémentation sur ordinateur de ces parties, qui n'apparaissent pas dans la preuve, est la tâche la plus complexe du travail de formalisation. En second lieu, il faut avoir des énoncés compréhensibles pour un mathématicien. L'intérêt n'est pas simplement de faire des preuves sur ordinateurs mais il faut que les énoncés de ces preuves soient le plus proche possible de ceux utilisés dans la littérature mathématique. Ceci facilitera la réutilisation de ces preuves dans d'autres développements. 
\paragraph*{}
Dans le cas du théorème de Cayley-Hamilton et en considérant la preuve ci-dessus plusieurs problèmes se posent lors de sa formalisation. Dire que $M_{n}(R[x])$ est identique à $(M_{n}(R))[x]$ équivaut algébriquement à dire qu'il existe un isomorphisme d'anneau entre eux. En effet, toute matrice de polynômes peut s'écrire, de façon unique comme la somme de puissances en $x$ multipliées par des matrices, c'est-à-dire un polynôme à coefficients matriciels. Par exemple :
\begin{equation}
 \label{morphism}
 \left(
  \begin{array}{ c c }
     x^{2} + 1 & x - 2 \\
     - x + 3 & 2x - 4
  \end{array} \right)
=
 x^{2}\left(
  \begin{array}{ c c }
     1 & 0 \\
     0 & 0
  \end{array} \right) + 
x\left(
  \begin{array}{ c c }
     0 & 1 \\
     -1 & 2
  \end{array} \right) + 
\left(
  \begin{array}{ c c }
     1 & -2 \\
     3 & -4
  \end{array} \right)
\end{equation}
La formalisation de cette isomorphisme correspond à l'écriture de la fonction de transformation décrite dans l'exemple ci-dessus. Les propriétés de ce morphisme que nous noterons $\phi$ sont utilisées implicitement dans la preuve. En effet, dans (\ref{Cramer-mx_poly}) les membres de l'égalité sont des matrices de polynômes. L'application de $\phi$ aux parties gauche et droite de (\ref{Cramer-mx_poly}) nous donne : 
\[   \phi ( {}^t{{\rm com} (xI_{n} - A)} * (xI_{n} - A)) = \phi ( p_{A}(x) * I_{n}) \]
Les propriétés de morphisme de $\phi$ sont alors utilisées pour obtenir :
\[       \phi ( {}^t{{\rm com} (xI_{n} - A)}) * \phi (xI_{n} - A)  = \phi ( p_{A}(x) * I_{n}) \]
La formule (\ref{proof_start}) correspond explicitement à l'égalité ci-dessus.

\section{ \ssr }
\ssr~\cite{ssrman,modgrp} (pour \textit{Small Scale Reflection} ou réflection à petite échelle) est une extension de \coq{}~\cite{coqart} qui introduit de nouvelles tactiques et des bibliothèques \coq{} adaptées pour travailler sur des types avec une égalité décidable et équivalente à l'égalité structurelle de \coq{} (égalité de Leibniz). Cette extension a été initialement développée par G. Gonthier dans le cadre de sa preuve du théorème des 4 couleurs. Un développement~\cite{modgrp} sur la théorie des groupes finis a été fait au dessus de \ssr. Il comprend, entre autres, une formalisation du théorème de Sylow et du lemme de Cauchy-Frobenuis.\newline
Dans cette section, nous présentons en premier lieu la méthode de \ssr{} pour réfléchir entre les prédicats booléens dans la logique de \coq{}. Nous introduisons par la suite le langage de tactique de \ssr. Enfin, nous présentons quelques bibliothèques \coq{} de \ssr{} que nous avons utilisées dans notre développement. Des informations plus détaillées sur \ssr{} et précisément son langage de tactique peuvent être obtenues dans~\cite{ssrman}.
\subsection*{Réflection}
Dans le système de preuve \coq{} la logique par défaut est intuitionniste. Dans cette logique, les propositions logiques et les valeurs booléennes sont distinctes. \ssr{} permet de combiner le meilleur des deux visions et passer de la version propositionnelle d'un prédicat décidable vers la version booléenne. La version propositionnelle permet d'avoir des preuves structurées alors que la version booléenne permet de faire des calculs. Pour ce faire, le type booléen est injecté dans celui des propositions par une coercion : 
\begin{verbatim}
Coercion is_true (b: bool) := b = true.
\end{verbatim}
Ainsi, et de façon transparente pour l'utilisateur, lorsque \coq{} attend un objet de type \texttt{Prop} et reçoit une valeur \texttt{b} de type \texttt{bool}, il la traduira automatiquement en la proposition \texttt{(is\_true b)}, qui correspond à la proposition \texttt{b $=$ true}.\newline
Le prédicat inductif \texttt{reflect} donne une équivalence pratique et confortable entre les propositions décidables et les booléens :
\begin{verbatim}
Inductive reflect (P: Prop): bool -> Type :=
  | Reflect_true: P => reflect P true
  | Reflect_false: ~P => reflect P false.
\end{verbatim}

La proposition \texttt{(reflect P b)} indique que \texttt{P} est équivalent à \texttt{(is\_true b)}. Par exemple, l'équivalence entre la conjonction booléenne \texttt{\&\&} et celle propositionnelle \verb|/\| est donnée par le lemme suivant : 
\begin{verbatim}
Lemma andP: forall a b:bool, reflect (a /\ b) (a && b).
\end{verbatim}
Des lemmes de même nature que \texttt{andP} sont définis lorsque nous voulons avoir l'équivalence entre la représentation calculatoire d'une fonction (pouvant être calculée) donnée et sa représentation logique. Plus de détails sur l'utilisation de \texttt{reflect} sont disponibles dans la documentation de \ssr{}~\cite{ssrman}.

\subsection*{Langage de tactiques}
Les scripts de preuve écrits avec \ssr{} diffèrent de ceux écrits dans \coq{} standard. Le langage de tactique de \ssr{} permet de faciliter les opérations d'interprétation et le développement des scripts. En pratique, les scripts de preuve écrits avec \ssr{} se révèlent plus concis que ceux écrits dans \coq{} standard. \newline
Toutes les opérations fréquentes qui consistent à déplacer ou généraliser depuis ou vers le contexte courant des formules sont regroupées dans la tactique \verb|move|. Par exemple la tactique ``\verb|move: (H1 a)|''  permet de placer dans le but courant une instance de l'hypothèse \verb|H1| pour la variable \verb|a|. Un autre exemple est la tactique ``\verb|move=> x y H2|'' qui correspond à l'introduction des variables \verb|x| et \verb|y|, et d'une nouvelle hypothèse \verb|H2| dans le contexte courant. La tactique \verb|move: (H1 a) => H2 x y| correspond à la combinaison des deux exemples précédents dans une seule et unique tactique.\newline
La tactique \verb|rewrite| permet de combiner toutes les opérations de réécriture conditionnelle, de dépliage de définition, de simplification et de réécriture pour une occurrence ou un pattern donné. Ces opérations peuvent être utilisées ensemble ou séparément. Par exemple la tactique \verb|rewrite /def H1 ?H2 !H3 {2}[_ * _]H4 /=| permet de déplier la définition \verb|def|, de récrire avec l'hypothèse \verb|H1|, de récrire zéro ou plusieurs fois avec l'hypothèse \verb|H2|, de récrire au moins une fois avec l'hypothèse \verb|H3|, de récrire dans la seconde occurrence du pattern \verb|[_ * _]| avec l'hypothèse \verb|H4| et de simplifier le but courant.\newline
Le mécanisme de réflection entre les propositions décidables et les booléens décrit plus haut est intégré au nouveau langage de tactique. Par exemple, étant donné un contexte avec une proposition \verb|H| de type \verb|a && b|, la tactique \verb|move/andP : H => H| applique le lemme \verb|andP| à \verb|H| et introduit dans le contexte une hypothèse \verb|H| de type \verb|a /\ b|. En revanche, lorsque le but est de la forme \verb|a && b|, la tactique \verb|apply/andP| change le but par \verb|a /\ b|. Enfin, lorsque le but est de la forme \verb|(a && b) -> G|, la tactique \verb|case/andP => H1 H2| change le but en \verb|G| et introduit deux hypothèses \verb|H1 : a| et \verb|H2 : b|.

\subsection*{Structures }
Des bibliothèques de base sont définies dans \ssr. C'est une hiérarchie de structure pour travailler avec les théories décidables et en particulier les types finis. La structure \verb|eqType| définit les types munis d'une égalité décidable et équivalente à celle de Leibniz.
\begin{verbatim}
Structure eqType : Type := EqType {
  sort :> Type; 
  _ == _ :  sort -> sort -> bool; 
  eqP :  forall x y, reflect (x = y) (x == y)
}.
\end{verbatim} 
Le symbole \verb|: >|  déclare \verb|sort| comme une coercion d'un \verb|eqType| vers son type porteur. C'est une forme d'héritage. La structure \verb|eqType| ne suppose pas seulement l'existence d'une égalité décidable \verb|==|, en plus elle injecte cette égalité vers celle de Leibniz avec le proposition \verb|eqP|. Nous pouvons ainsi profiter de la puissance de réécriture de Coq. \newline
Une propriété majeure des structures d'\verb|eqType| est qu'elles donnent la propriété de la \textit{proof-irrelevance} pour les preuves d'égalités de leurs éléments. Ainsi il n'y a qu'une seule preuve de l'égalité pour chaque paire d'objets égaux.
\begin{verbatim}
Lemma eq_irrelevance: forall (d: eqType) (x y: d) (E: x = y) (E': x = y), E = E'.
\end{verbatim} 
\paragraph*{}
Un ensemble sur une structure d'\verb|eqType| est représenté par sa fonction caractéristique : 
\begin{verbatim}
Definition set (d: eqType) := d -> bool.
\end{verbatim} 
Une propriété booléenne sur un \verb|eqType| correspond donc à l'ensemble des éléments qui la satisfont. Avec cette définition les opérations ensemblistes comme l'intersection ou le complémentaire se définissent avec les fonctions booléennes correspondantes.
\begin{verbatim}
Definition setI (a b : set d) : set d := fun x => a x && b x.
Definition setC (a : set d) : set d := fun x => ~~ a x.
\end{verbatim}
\paragraph*{}
Il est utile d'avoir un type des listes sur un \verb|eqType d| pour pouvoir définir plus naturellement des opérations qui se basent sur un test booléen comme la recherche d'un élément dans une liste. Le type des listes sur un \verb|eqType d| se définit de façon inductive par :
\begin{verbatim}
Inductive seq : Type := Seq0 | Adds (x : d) (s : seq).
\end{verbatim} 
\verb|Adds| et \verb|Seq0| correspondent respectivement aux constructeurs \verb|cons| et \verb|nil| du type standard \verb|list| de \coq.   Le type \verb|seq d| définit les listes sur un \verb|eqType d|. Sur ce nouveau type de liste des fonctions sont définies pour manipuler et raisonner sur ses éléments. La fonction \texttt{foldr} correspond dans \ssr{} à l'opération \textit{fold} utilisée en programmation fonctionnelle. Elle est définie par récurrence sur une liste. L'opération d'extraction d'un élément d'une liste est donnée par la fonction \verb|sub|. Par exemple \verb|sub x0 s i| retourne l'élément d'indice \texttt{i} de la liste \texttt{s}, si \texttt{i} est strictement inférieur à la longueur de la liste, et \texttt{x0} dans le cas contraire. La fonction \verb|mkseq| permet de construire une liste de longueur donnée à partir d'une fonction sur les entiers. Par exemple, \verb|mkseq f n| correspond à la liste \verb|[(f 0), (f 1), ..., (f n-1)]|.
\paragraph*{}
Un type fini peut être vu comme un ensemble fini. Il peut alors être représenté par une liste de tous ses éléments. La définition du type liste sur un \verb|eqType| est à la base de celle des types finis. La structure \verb|finType| se compose d'une liste sur un \verb|eqType| et de la preuve qu'aucun élément de cette liste n'apparaît plus d'une fois.
\begin{verbatim}
Structure finType : Type := FinType {
  sort :> eqType;
  enum :  seq  sort;
  enumP :  forall x, count (set1 x) enum = 1
}.
\end{verbatim} 
Dans cette définition \verb|(set1 x)| est l'ensemble singleton ${x}$ et \verb|(count f l)| calcule le nombre d'éléments \verb|y| de la liste \verb|l| pour lesquels \verb|(f y)| est vraie. Le paramètre \verb|enum| correspond à la liste des éléments du type fini. Par exemple pour un \verb|finType d|, (\verb|enum d|) retourne la liste des éléments de \verb|d|.
\paragraph*{}
Pour représenter les types finis des éléments de l'intervalle \(0..n-1\), la bibliothèque \ssr{} fournit une famille de types nommée \verb|ordinal| dont les éléments sont des paires composées d'un nombre entier \(p\) et d'une preuve que \(p\) est inférieur à \(n\). Comme cette preuve est basée sur un test booléen, la propriété d'irrelevance s'applique et les éléments de ce type sont uniquement caractérisés par la composante \(p\). La notation \verb|I_(n)| désigne le type \verb|ordinal n|.

\section{Formalisations \coq}
Dans ce travail de formalisation du théorème de Cayley-Hamilton, nous utilisons des bibliothèques sur les opérations indexées et les déterminants. Ces bibliothèques ont été développées par Y. Bertot et G. Gonthier dans le cadre du projet ``Mathematical Components''. La bibliothèque sur les polynômes fournit une formalisation des propriétés algébriques des polynômes, du morphisme d'évaluation et du théorème du reste. La définition de l'isomorphisme entre l'anneau des matrices de polynômes et celui des polynômes de matrices est l'étape ultime de la formalisation du théorème de Cayley-Hamilton.

\subsection{Les opérations indexées} 
Dans la définition des opérations sur les matrices, par exemple la multiplication ou le calcul du déterminant, les opérations indexées (somme et produit) sont fréquentes. Factoriser la preuve de propriétés générales sur les sommes et produits indexés permet de réduire considérablement la longueur et la complexité des preuves et d'avoir des énoncés plus lisibles. Une bibliothèque pour les opérations indexées n'est pas seulement utile dans le développement sur la théorie des matrices, elle pourra l'être aussi dans des développements plus généraux que l'algèbre linéaire.
\paragraph{}
Une opération indexée est la généralisation de la définition d'une opération binaire aux éléments d'une suite finie. Dans le cas particulier de l'addition, c'est la somme de tous les éléments d'une suite donnée. L'opération indexée est définie par :
\begin{verbatim}
Definition reducebig R I op nil (r : seq I) P F : R :=
  foldr (fun i x => if P i then op (F i : R) x else x) nil r.
\end{verbatim}
La fonction \verb|reducebig| a comme paramètres un type quelconque \verb|R|, un \verb|eqType I|, une opération binaire \verb|op| sur \verb|R|, un élément \verb|nil| de \verb|R| correspondant à l'ensemble vide, une liste \verb|r| sur \verb|I|, une propriété caractéristique \verb|P| sur \verb|I| (une fonction de \verb|I| vers \verb|bool| : un ensemble sur \verb|I|) et une fonction \verb|F| de \verb|I| vers \verb|R|. Le résultat de \verb|reducebig| correspond schématiquement à :
\[ F ~ p_{1} ~ op ~ F ~ p_{2} ~ op ~ \cdots ~ op ~ F ~ p_{n} ~ op ~ nil,  \] 
Les $p_{i}$ sont les éléments de la liste $r$ pour lesquels la propriété $P$ est vraie : les éléments de l'ensemble $P$. L'utilisation de \verb|reducebig| est plus naturelle lorsque l'opération est associative et commutative et lorsque \verb|nil| est l'élément neutre de cette opération. En d'autres termes, lorsque \verb|(R, op, nil)| est un monoïde. \newline
La notation \verb|\big[*%M/1]_(i|\texttt{| P i) F i} correspond à l'application de \verb|reducebig| à une opération \verb|*| d'un monoïde qui a pour élément neutre \verb|1|. Le reste des paramètres est inféré de façon implicite par \coq. Par exemple \verb|\big[*%M/1]_(i|\texttt{| i < n) i} équivaut à la notation mathématique $ \sum_{i<n} i$.
\paragraph*{}
Un lemme intéressant sur \verb|reducebig|  est celui qui permet d'effectuer l'opération usuelle de ré-indexation. Dans le cas d'une somme indexée, ce lemme correspond à l'égalité entre les sommes 
$ \sum_{i=0}^{n} (i + m)$ et $ \sum_{j=m}^{n + m} j $. Une façon de formaliser cette égalité est de considérer que $i$ et $j$ sont de types différents, respectivement $[0..n]$ et $[m..n+m]$, et qu'il existe une bijection entre ces deux types. Cette bijection est la fonction $ f : x \rightarrow x + m $. \newline
Le prédicat \verb|ibjective P h| permet de dire que la fonction \verb|h| est bijective sur l'ensemble {\tt P}. Le lemme de ré-indexation s'énonce alors comme suit : 
\begin{verbatim}
Lemma reindex : forall (I J : finType) (h : J -> I) P F,
  ibijective P h ->
  \big[*%M/1]_(i | P i) F i = \big[*%M/1]_(j | P (h j)) F (h j).
\end{verbatim}
Un autre résultat intéressant sur les opérations indexées est celui qui permet de décomposer cette opération suivant une partition de l'ensemble d'indice. Par exemple, dans le cas d'une somme indexée, le résultat s'écrit $ \sum_{i=0}^{n + m} i = \sum_{i=0}^{n} i + \sum_{i=n+1}^{n + m} i $. La généralisation de cette propriété peut s'écrire formellement :
\begin{verbatim}
Lemma bigID : forall (I : finType) (a : set I) (P : I -> bool) F,
  \big[*%M/1]_(i | P i) F i
    = \big[*%M/1]_(i | P i && a i) F i * \big[*%M/1]_(i | P i && ~~ a i) F i.
\end{verbatim}
Dans ce lemme, étant donné un ensemble \texttt{a}, une partition d'un ensemble \texttt{P} est donnée par les deux ensembles $\mathtt{P \cap a}$ et $\mathtt{P \cap \bar{a} }$, où $\mathtt{\bar{a} }$ est l'ensemble complémentaire de $\mathtt{\bar{a} }$. La somme des éléments indexés par \texttt{P} peut être donc décomposée suivant ces deux ensembles.


\subsection{Structures canoniques}
Dans l'assistant de preuve \coq, le mécanisme des \texttt{Canonical Structure} permet de définir une instance d'un type enregistrement (\texttt{Record} ou \texttt{Structure}) qui pourra être utilisée lors du processus d'inférence de type dans des équations invoquant des arguments implicites. Par exemple, pour définir une structure de \texttt{eqType} sur le type \texttt{nat} il faut une égalité décidable sur les entiers et prouver que cette égalité est équivalente à celle de Leibniz sur les entiers. 
\begin{verbatim}
Fixpoint eqn (m n : nat) {struct m} : bool :=
  match m, n with
  | 0, 0 => true
  | S m', S n' => eqn m' n'
  | _, _ => false
  end.
Lemma eqnP : reflect_eq eqn.
Proof.
...
Qed.
Canonical Structure nat_eqType := EqType (@eqnP).
\end{verbatim}
Le lemme suivant montre un exemple simple d'utilisation des \texttt{Canonical Structure}.
\begin{verbatim}
Lemma eqn_add0 : forall m n:nat, (m + n == 0) = (m == 0) && (n == 0).
\end{verbatim} 

Rappelons que \verb|==| dénote l'égalité dans un \verb|eqType|. Dans cet énoncé \coq{} s'attend à ce que \texttt{m} et \texttt{n} soient d'un type \texttt{eqType}. Comme ils sont de type \texttt{nat}, \coq{} cherche alors une définition d'un \texttt{eqType} dont le paramètre \texttt{sort} est \texttt{nat}. Grâce à la définition de \texttt{Canonical Structure nat\_eqType}, \coq{} peut inférer automatiquement le type \texttt{nat\_eqType} aux arguments \texttt{m} et \texttt{n}. 
\paragraph*{}
Le mécanisme des \texttt{Canonical Structure} est puissant et très utile dans le travail avec les structures algébriques comme les groupes ou les anneaux. \ssr{} contient une bibliothèque \texttt{ssralg} qui, en utilisant ce mécanisme, fournit une hiérarchie de structures algébriques regroupant monoïde, groupe, anneau et corps. En utilisant cette bibliothèque, les définitions des types polynômes et matrices sont paramétrées par l'anneau de leurs coefficients. Avec l'utilisation des \texttt{Canonical Structure} sur ces types,  \coq{} pourra inférer automatiquement la structure d'anneau correspondante. Ceci nous permet d'unifier les notations pour les opérations algébriques sur ces types (addition, multiplication et opposé) et d'avoir ainsi des énoncés proches de ceux utilisés en mathématique standard et plus lisible du point de vue de l'utilisateur. 

\subsection{Matrices et déterminants}
Une matrice sur un anneau $R$ est une liste de coefficients doublement indexée. Elle peut être vue comme une fonction qui associe à une position  \((i,j)\) une valeur dans l'anneau $R$. Étant donnés $m$ et $n$ deux entiers et $R$ un anneau, une matrice sur $R$ (un objet de type $M_{m,n}(R)$) peut être représentée par la fonction suivante : $ [0..n[ \rightarrow [0..m[ \rightarrow R$. Pour définir un \texttt{eqType} sur les matrices, qui sont des fonctions, nous avons besoin de l'extensionnalité. La fonction \texttt{fgraphType} construit le graphe des fonctions dont le domaine est un \texttt{finType} et le co-domaine un \texttt{eqType}. Avec la définition des graphes de fonctions, les fonctions sont ainsi munies d'une égalité de Leibniz. Pour deux fonctions \texttt{f} et \texttt{g}, les notations \texttt{f =1 g} et \texttt{f =2 g} correspondent respectivement à $\mathtt{\forall x, f~x = g~x}$  et  $\mathtt{\forall x~y, f~x~y = g~x~y}$. Dans le cas où ces deux fonctions ont des domaines de type \texttt{finType} et des co-domaines de type \texttt{eqType}, les notations précédentes sont équivalentes à \texttt{f = g}.
\paragraph*{}
Le type des matrices de taille \((m,n)\) est défini par :
\begin{verbatim}
Definition matrix (m n :nat) := fgraphType (I_(m) * I_(n)) R.
\end{verbatim} 
Les fonctions \verb|matrix_of_fun| et \verb|fun_of_matrix| permettent respectivement de définir un objet de type \texttt{matrix} à partir d'une fonction et de convertir un objet de type \texttt{matrix} en une fonction à deux arguments. Cette dernière n'est autre qu'une coercion du type \texttt{matrix} vers celui des fonctions. Elle nous permet de dire que deux matrices \texttt{A} et \texttt{B} sont égales si et seulement si nous avons \texttt{A =2 B}. Ce qui veut dire que leurs fonctions associées sont égales : \texttt{fun\_of\_matrix A =2 fun\_of\_matrix B}.\newline
Dans la suite, les notations \texttt{M\_(n)} et \verb|\Z x| correspondent respectivement au type des matrices carrées et à la matrice scalaire en \texttt{x}. La notation \verb|\matrix_(i,j) E|, où \texttt{E} est une expression en \texttt{i} et \texttt{j}, correspond à l'application de \verb|matrix_of_fun| à la fonction \verb|f i j => E i j|. Par exemple, la matrice scalaire correspondant à un élément \texttt{x} est donnée par la formule suivante :
\begin{verbatim}
Definition scalar_mx n x : M_(n) := \matrix_(i, j) (if i == j then x else 0).
\end{verbatim} 

\paragraph*{}
La bibliothèque sur les déterminants utilise la formule de Leibniz pour définir le déterminant. Ce choix est motivé par le fait que cette formule est bien adaptée et que nous disposons des ``ingrédients'' nécessaires à sa formalisation. En effet, une formalisation des permutations (groupe, signature ...) a été déjà développée dans le cadre du travail sur les groupes finis~\cite{modgrp}. Etant donnée une matrice carrée $A$ de dimension $n$, le déterminant est défini par :
\begin{equation}
  \label{leibniz} \det(A)=\sum_{\sigma \in S_n} 
\epsilon(\sigma) \prod_{i=1}^n a_{i, \sigma(i)}
\end{equation} 
Dans cette formule, il est question d'opérations indexées pour les sommes et les produits, de groupe de permutations ($ S_n $) et de signature de permutations($\epsilon(\sigma)$). Les notations mathématiques cachent plusieurs autres éléments. Dans la bibliothèque sur les déterminants, pour pouvoir formaliser la formule (\ref{leibniz}) :
\begin{itemize}
 \item l'indexation des lignes et colonnes de la matrice par des entiers est remplacée par une 
indexation par les éléments du type \texttt{I\_(n)},
 \item l'ensemble des permutations sur cet ensemble fini est décrit comme un ensemble fini qui pourra être énuméré et donc servir d'ensemble d'indices.
\end{itemize}

\paragraph{}
Avec ces choix, grâce aux développements sur le calcul de la parité des permutations et à celui sur les groupes de permutations, la formule (\ref{leibniz}) s'écrit :
\begin{verbatim}
 Definition determinant n (A : M_(n)) := 
   \sum_(s : S_(n)) (-1) ^ s * \prod_(i) A i (s i).
\end{verbatim} 

Les notations \verb|\sum| et \verb|\prod| représentent respectivement la somme et le produit indexés. Ce sont des instances de \verb|reducebig| pour les opérations internes (addition et multiplication) de l'anneau des coefficients de la matrice. La notation \verb|S_(n)| représente le groupe des permutations sur un ensemble à $n$ éléments. Dans la suite, la notation \verb|\det| représentera la fonction \verb|determinant|.
\paragraph{}
Pour exprimer la règle de Cramer,  la co-matrice d'une matrice est définie à l'aide de la fonction {\tt row'}. Cette dernière prend en entrée  un nombre \(i\) inférieur à \(m\) (un élément de type {\tt I\_(m)}) et une matrice  de taille \((m,n)\); elle retourne la matrice \((m-1,n)\) où la rangée \(i\) a été enlevée. Avec les mêmes arguments, la fonction {\tt row} retourne la matrice \((1,n)\) (une rangée et \(n\) colonnes) qui contient la rangée \(i\). La transposée de la co-matrice est représentée par la fonction {\tt adjugate}.
\begin{verbatim}
Definition cofactor n (A : M_(n)) (i j : I_(n)) :=
   (-1) ^+(i + j) * \det (row' i (col' j A)).
Definition adjugate n (A : M_(n)) := \matrix_(i, j) (cofactor A j i).
\end{verbatim}

L'égalité de Cramer est alors formellement représentée par le lemme \verb|mulmx_adjr| :
\begin{verbatim}
Lemma mulmx_adjr : forall n (A : M_(n)), A * adjugate A = \Z (\det A).
\end{verbatim}
La preuve utilise la formule de Laplace ($\det(A)=\sum_{i=1}^{n} a_{i,j} {\rm cofacteur(A)}_{i,j}$) qui donne le déterminant en fonction des coefficients d'une seule ligne ou colonne et des cofacteurs correspondants. Celle-ci est formellement donnée par :
\begin{verbatim}
Lemma expand_determinant_row : forall n (A : M_(n)) i,
  \det A = \sum_(j) A i j * cofactor A i j.
\end{verbatim} 
Le lemme selon lequel le déterminant est une forme alternée (le déterminant d'une matrice, où au moins deux lignes sont identiques, est nul) s'énonce formellement comme suit: 
\begin{verbatim}
Lemma alternate_determinant : forall n (A : M_(n)) i1 i2,
  i1 != i2 -> A i1 =1 A i2 -> \det A = 0.
\end{verbatim} 

Comme les matrices sont des fonctions à deux arguments, le terme \verb|(A i1)| est une fonction à un argument et il correspond à la ligne d'indice \verb|i1| de la matrice {\tt A}.

\subsection{Polynômes}
Un polynôme est défini par la liste de ses coefficients $a_{i}$ qui appartiennent à un anneau $R$: 
\[ a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0}\]
Cette représentation n'est malheureusement pas unique, en effet les polynômes $ a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0} $ et $ 0 x^{n + 1} + a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0} $ ont des listes de coefficients différentes mais représentent le même polynôme. Pour avoir une égalité de Leibniz pour cette représentation, il est nécessaire de ne considérer que les polynômes normalisés, c'est-à-dire ceux dont le coefficient de plus grand degré est non nul, et avoir une égalité de Leibniz sur les coefficients. Les polynômes sont donc représentés par la structure suivante :
\begin{verbatim}
Structure polynomial (R : ring) : Type := Poly {
  p :>  seq R;
  normal : last 1 p != 0
}.
\end{verbatim} 
La propriété \texttt{normal} dit que le dernier élément de la liste des coefficients est non nul. Avec cette définition, nous pouvons donc définir une structure de \verb|eqType| sur les polynômes. Nous avons défini la fonction coefficient des polynômes par :
\begin{verbatim}
Definition coef (p : polynomial) i := sub 0 p i.
\end{verbatim} 
La fonction \verb|coef p| est de type \verb|nat -> R|. Le lemme suivant permet d'avoir l'équivalence entre l'égalité entre les polynômes et celles entre les fonctions de coefficient : 
\begin{verbatim}
Lemma coef_eqP : forall p1 p2, coef p1 =1 coef p2 <-> p1 = p2.
\end{verbatim} 
Avec ce lemme, nous pouvons passer de notre représentation structurelle des polynômes vers celle qui ne considère que la fonction des coefficients. L'avantage de la second représentation est de rendre les preuves des propriétés algébriques des polynômes plus intuitives. Par exemple, la multiplication de deux polynômes est définie par :
\begin{equation}
\label{poly-mult}
\left(\sum_{i=0}^n a_ix^i\right)\left(\sum_{j=0}^m  b_jx^j\right)=\sum_{k=0}^{m+n}\left(\sum_{i +j =k}a_{i} b_{j}\right)x^k.
\end{equation} 
La preuve de l'associativité de cette multiplication se ramène à des raisonnements sur des sommes indexées, sans avoir besoin de faire des récurrences sur les polynômes.\newline
Dans la suite, les notations \verb|\X| et \verb|\C c| correspondent respectivement au monôme $x$ et au polynôme constant $c$.\newline
L'opération de multiplication d'un polynôme par \verb|x| (décalage à droite) et addition d'une constante est l'une des opérations de base sur les polynômes. Dans la bibliothèque elle est réalisée par la fonction suivante : 
\begin{verbatim}
Definition horner c p : polynomial :=
  if p is Poly (Adds _ _ as s) ns then Poly (ns : normal (Adds c s)) else \C c.
\end{verbatim}
A partir de cette définition, la fonction de construction d'un polynôme à partir d'une liste de coefficients se définit simplement par :
\begin{verbatim}
Definition mkPoly := foldr horner \C0.
Notation "\poly_ ( i < n ) E" := (mkPoly (mkseq (fun i : nat => E) n)).
\end{verbatim}
La notation \verb|\poly| permet de construire un polynôme à partir d'une fonction de coefficients. Par exemple, le polynôme correspondant à \verb|\poly_ ( i < n ) i| est :  \( {n - 1} x^{n - 1} + \cdots + {1} x + {0}\) 
\paragraph{}
Les opérations de base sur les polynômes sont définies par récurrence sur la liste des coefficients. La liste résultat est ensuite normalisée par la fonction \verb|mkPoly|. Par exemple, la multiplication de deux polynômes est définie comme suit :
\begin{verbatim}
Fixpoint mult_poly_seq (s1 s2 : seq R) {struct s1} : seq R :=
  if s1 is Adds c1 s1' then
    add_poly_seq (maps (fun c2 => c1 * c2) s2)
                 (Adds 0 (mult_poly_seq s1' s2))
  else seq0.

Definition mult_poly (p1 p2 : polynomial) := mkPoly (mult_poly_seq p1 p2).
\end{verbatim} 
Dans la seconde définition, la conversion de type entre les types \verb|polynomial| et \verb|seq| permet d'écrire \verb|mult_poly_seq p1 p2| bien que \verb|p1| et \verb|p2| sont de type \verb|polynomial|. Le lemme \verb|coef_mul_poly|
\begin{verbatim}
Lemma coef_mul_poly : forall p1 p2 i,
  coef (mult_poly p1 p2) i = \sum_(j <= i) coef p1 j * coef p2 (i - j).
\end{verbatim}
donne une relation entre les coefficients de deux polynômes et ceux du résultat de leur multiplication. Il correspond à la relation de la formule (\ref{poly-mult}).
\paragraph{}
Une autre opération importante sur les polynômes est la fonction d'évaluation d'un polynôme. Elle consiste à remplacer sa variable par une valeur donnée. Cette fonction peut être décrite avec le schéma de Horner pour un polynôme $p$ et une valeur $x$ par :
\begin{equation}
 \label{horner-sch}
   p(x) = ((...((a_{n}x + a_{n-1})x + a_{n-2})x + ... ) + a_{1})x + a_{0}
\end{equation}
Suivant le schéma (\ref{horner-sch}) l'évaluation ne dépend que de la liste des coefficients et de la valeur où nous évaluons. Elle se définit par récurrence sur la liste des coefficients. La fonction d'évaluation peut être définie par récurrence sur une liste arbitraire comme suit :
\begin{verbatim}
Fixpoint eval_poly_seq (s : seq R) (x : R) {struct s} : R :=
  if s is (Adds a s') then eval_poly_seq s' x * x + a else 0.
\end{verbatim}
Rappelons que dans la définition de la structure \texttt{polynomial} nous avons une coercion entre elle et le type de la liste des coefficients. Ceci nous permet de définir l'évaluation d'un polynôme de la manière suivante :
\begin{verbatim}
Definition eval_poly (p : polynomial R) : R-> R := eval_poly_seq p.
\end{verbatim}
La notation \verb|p.[c]| correspond à l'application de la fonction \verb|eval_poly| en \verb|p| et \verb|c|.\newline
Les propriétés de morphisme de la fonction d'évaluation sont utilisées implicitement dans la preuve du théorème de Cayley-Hamilton. Ces propriétés sont données par les lemmes suivants :
\begin{verbatim}
Lemma eval_polyC : forall c x, (\C c).[x] = c.
Lemma eval_poly_plus : forall p q x, (p + q).[x] = p.[x] + q.[x].
Lemma eval_poly_mult : forall p q x, x * q.[x] = q.[x] * x ->
                                    (p * q).[x] = p.[x] * q.[x].
\end{verbatim} 
Dans le lemme \verb|eval_poly_mult| sur l'évaluation d'un produit de polynômes, il est nécessaire d'avoir que la valeur \verb|x| où l'on évalue le polynôme \verb|p * q| commute avec l'évaluation de \verb|q| en cette même valeur. Cette hypothèse est nécessaire vue que l'on évalue des polynômes sur un anneau non commutatif : l'anneau des matrices. 
\paragraph*{}
Après ces développements, le théorème du reste peut s'énoncer comme suit :
\begin{verbatim}
Theorem factor_theorem : forall p c,
  reflect (exists q, p = q * (\X - \C c)) (p.[c] == 0).
\end{verbatim} 
Dans la preuve de ce théorème, pour pouvoir dire que \verb|p.[c]| est égale à \verb|q.[c] * (\X - \C c).[c]|, il faut prouver que les coefficients du polynôme \verb|(\X - \C c)| commutent avec \texttt{c}. Ce qui se prouve facilement car \texttt{1} et \texttt{c} commutent avec \texttt{c}.

\subsection{Preuve de Cayley-Hamilton}
Le morphisme entre l'anneau des matrice de polynômes et celui des polynômes de matrices est la partie centrale de la preuve du théorème de Cayley-Hamilton. Les autres composantes de la preuve, la règle de Cramer et le théorème de factorisation, sont des propriétés qui se rattachent respectivement aux matrices et aux polynômes. \newline
Ce morphisme que nous allons appeler \verb|phi| prend en argument une matrice de polynômes et retourne un polynôme de matrices. La longueur de la liste des coefficients du polynôme résultat est la taille maximale des polynômes de la matrice de départ. La taille d'un polynôme correspond à la longueur de la liste de ces coefficients, en d'autre terme son degré plus un. Pour une matrice de polynômes \texttt{A}, \verb|phi A| est le polynômes de matrices dont le coefficient d'indice \texttt{k} est la matrice dont le coefficient en \texttt{i} et \texttt{j} est \texttt{coef (A i j) k}. Dans la suite, les notations \verb|R[X]|, \verb|M(R)|, \verb|M(R[X])| et \verb|M(R)[X]| représentent respectivement l'anneau des polynômes, celui des matrices, celui des matrices de polynômes et celui des polynômes de matrices. 
\begin{verbatim}
Definition phi (A : M(R[X])) : M(R)[X] :=
  \poly_(k < \max_(i) \max_(j) size (A i j)) \matrix_(i, j) coef (A i j) k.
\end{verbatim} 
Le lemme \verb|coef_phi| permet d'exprimer la relation entre une matrice de polynômes et son image par \texttt{phi}.
\begin{verbatim}
Lemma coef_phi : forall A i j k, coef (phi A) k i j = coef (A i j) k.
\end{verbatim} 
Pour pouvoir définir l'évaluation d'une matrice en son polynôme caractéristique, nous avons défini l'injection de l'anneau des polynômes vers celui des polynômes de matrices.
\begin{verbatim}
Definition Zpoly (p : R[X]) : M(R)[X] := \poly_(i < size p) \Z (coef p i).
\end{verbatim} 

Le polynôme caractéristique d'une matrice est définit en appliquant la définition du déterminant à la matrice de polynômes $xI_{n} - A$.  
\begin{verbatim}
Definition matrixC (A : M(R)) : M(R[X]) := \matrix_(i, j) \C (A i j).
Definition char_poly (A : M(R)) : R[X] := \det (\Z \X - matrixC A).
\end{verbatim}
La fonction \verb|matrixC| est l'injection canonique de l'anneau des matrices vers celui des matrices de polynômes.
\paragraph*{} 
Après ces définitions, le théorème de Cayley-Hamilton est prouvé formellement de la façon suivante :
\begin{verbatim}
Theorem Cayley_Hamilton : forall A, (Zpoly (char_poly A)).[A] = 0.
Proof.
move=> A; apply/eqP; apply/factor_theorem.
rewrite -phi_Zpoly -mulmx_adjl phi_mul; move: (phi _) => q; exists q.
by rewrite phi_add phi_opp phi_Zpoly phi_polyC ZpolyX.
Qed.
\end{verbatim} 

La preuve se déroule exactement comme décrit dans la seconde section. Après avoir appliqué le théorème du reste, le polynôme facteur est donné en récrivant avec la règle de Cramer (\verb|mulmx_adjl|). Le résultat du théorème de Cayley-Hamilton est alors prouvé par des réécritures et simplifications dans le terme obtenu. L'utilisation de \ssr{}, des mécanismes des \verb|Canonical Structure| et des notations, ainsi que la définition hiérarchique des structures de données ont permis d'aboutir à une preuve aussi concise : 3 lignes de codes. 

\section{Conclusion}
Nous avons présenté une formalisation du théorème de Cayley-Hamilton qui adopte une approche modulaire. La preuve que nous avons présentée dans la section 4.4 peut paraître très simple; mais la conception a été assez longue que ce soit pour choisir l'architecture globale de la preuve ou le bon type de données pour représenter les structures manipulées (polynômes et matrices). Les choix ont été motivés par des soucis de lisibilité et de réutilisabilité. L'utilisation des {Canonical Structure} de \coq{} nous a permis d'avoir des énoncés proches de ceux utilisés en mathématiques usuelles. Le découpage des différentes composantes de la preuve sous forme modulaire (les opérations indexées, les matrices et les polynômes) favorise la réutilisation de ces bibliothèques dans des développements indépendants. Les bibliothèques sur les opérations indexées et les matrices seront réutilisées dans nos prochains travaux sur la théories des caractères, une des composantes de la preuves du théorème de Feit-Thompson.\newline
Ce travail que nous avons présenté ici est la première formalisation du théorème de Cayley-Hamilton. Ce n'est pas la première formalisation des matrices ou des polynômes. Des formalisations de ces structures sont présentées respectivement dans~\cite{ring-mx, linalg} et~\cite{fta, factor-th}. Mais c'est le premier développement qui regroupe une formalisation des matrices et polynômes et où ces objets sont assemblées pour former de nouveaux objets : les matrices de polynômes et les polynômes de matrices.
\paragraph*{}
Dans la formalisation du théorème de Cayley-Hamilton, présentée dans cet article, nous avons choisi de construire nos structures de données sur des types munis d'une égalité décidables: les \texttt{eqType}. En plus du fait qu'en mathématiques classiques tous les types sont décidables, notre preuve sur les types où l'égalité est décidables peut être généralisés vers les types quelconques. Ceci se fait en remarquant que tout anneau est une $\mathbf{Z}$-algèbre et en considérant le morphisme d'évaluation des polynômes à $n^{2}$ variables et à coefficients dans $\mathbf{Z}$ qui est un type où l'égalité est décidable. Il va falloir alors travailler avec les \texttt{Setoid}.
\paragraph*{}
Dans ce développement la bibliothèque sur les polynômes comprend 83 objets (définitions et lemmes) pour environs 490 lignes de codes. Les définitions et lemmes propres à la preuve du théorème de Cayley-Hamilton sont au nombre de 15 pour 125 lignes de codes. Les sources du développement sont disponibles à l'adresse suivante : \verb|http://www-sop.inria.fr/marelle/Sidi.Biha/cayley/|.  

% La bibliographie
\begin{thebibliography}{13} % N'oubliez pas de l'inclure lors
\bibitem{100ths}
  Paul et Jack \textsc{Abad},
  \textit{The Hundred Greatest Theorems},
  Disponible à \verb|http://personal.stevens.edu/~nkahl/Top100Theorems.html|.

\bibitem{primeth}
  Jeremy \textsc{Avigad}, Kevin \textsc{Donnelly}, David \textsc{Gray}, et Paul \textsc{Raff},
  \textit{A Formally Verified Proof of the Prime Number Theorem},
  ACM Transactions on Computational Logic, A paraître.

\bibitem{coqart}
  Yves \textsc{Bertot}, Pierre \textsc{Castéran},
  \textit{Interactive Theorem Proving and Program Development Coq'Art: The Calculus of Inductive Constructions},
  Springer Verlag,
  2004.

\bibitem{algebra}
  Nathan \textsc{Jacobson},
  \textit{Lectures in Abstract Algebra: II. Linear Algebra},
  Springer Verlag, 1975.

\bibitem{fta}
  Herman \textsc{Geuvers}, Freek \textsc{Wiedijk} et Jan \textsc{Zwanenburg},
  \textit{A Constructive Proof of the Fundamental Theorem of Algebra without Using the Rationals},
  Types for Proofs and Programs, TYPES 2000 International Workshop, Selected Papers, volume 2277 of
  LNCS, pages 96-111, 2002.

\bibitem{4colproof}
  Georges \textsc{Gonthier},
  \textit{A computer-checked proof of the four-colour theorem},
  Disponible à \verb|http://research.microsoft.com/~gonthier/4colproof.pdf|.

\bibitem{ssrman}
  Georges \textsc{Gonthier}, Assia \textsc{Mahboubi},
  \textit{A small scale reflection extension for the Coq system},
  Disponible à \verb|http://www.msr-inria.inria.fr/~assia/rech-eng.html| (à paraître comme RR Inria).

\bibitem{modgrp}
  Georges \textsc{Gonthier}, Assia \textsc{Mahboubi}, Laurence \textsc{Rideau}, Enrico \textsc{Tassi} et Laurent \textsc{Théry},
  \textit{A Modular Formalisation of Finite Group Theory},
  Rapport de Recherche 6156, INRIA, 2007.

\bibitem{ring-mx}
  Nicolas \textsc{Magaud},
  \textit{Ring properties for square matrices} contribution à Coq,
  \verb|http://coq.inria.fr/contribs-eng.html|.

\bibitem{factor-th}
  Piotr \textsc{Rudnicki},
  \textit{Little Bezout Theorem (Factor Theorem)}, Journal of Formalized Mathematics volume 15, 2003,
  Disponible à \verb|http://mizar.org/JFM/Vol15/uproots.html|.

\bibitem{linalg}
  Jasper \textsc{Stein},
  \textit{Linear Algebra} contribution à Coq,
  \verb|http://coq.inria.fr/contribs-eng.html|.

\bibitem{coqman}
  \textsc{Coq Team},
  \textit{The Coq reference manual V 8.1},
  \verb|http://coq.inria.fr/V8.1/refman/index.html|.

\bibitem{100th}
  Freek \textsc{Wiedijk},
  \textit{Formalizing 100 Theorems},
  \verb|http://www.cs.ru.nl/freek/100/|.

\end{thebibliography}
\newpage
\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}