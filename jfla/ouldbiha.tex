\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}

\newcommand{\coq}{{\sc Coq}}
\newcommand{\ssr}{{\sc SSReflect}}

\title{ Formalisation des mathématiques : une preuve du théorème de Cayley-Hamilton $^*$ }

\author{Sidi Ould Biha $^1$}

\titlehead{Formalisation des mathématiques}%  a droite (page impaire)

\authorhead{Ould Biha}% a gauche (page paire)

\affiliation{\begin{tabular}{rr} 
\\ 1:  Inria de Sophia-Antipolis,
\\     2004, route des Lucioles - B.P. 93 06902 Sophia Antipolis Cedex, France
\\     {\tt Sidi.Ould\_biha@sophia.inria.fr} 
\\ $^*$:  Ce travail a été possible grâce au financement du laboratoire commun Microsoft-Inria
\\     {\tt http://www.msr-inria.inria.fr}
\end{tabular}}

\begin{document}
\setcounter{page}{1}
\maketitle

% Ici commence votre texte

\section{Introduction}
Les systèmes de preuves formelles peuvent être d'une grande utilité dans la vérification et la validation de preuves mathématiques, surtout lorsque ces preuves sont complexes et longues. Les travaux récents, comme la preuve formelle du théorème des 4 couleurs~\cite{4colproof} ou celle du théorème des nombres premiers~\cite{primeth}, montrent que ces systèmes ont atteint un niveau de maturité leur permettant de s'attaquer à des problèmes mathématiques non triviaux. Le travail de formalisation de preuves mathématiques faisant intervenir une large variété d'objets mathématiques nécessite l'adoption d'une approche semblable au génie logiciel. La formalisation de telles théories peut être vue comme un développement faisant intervenir différentes composantes : définitions et preuves mathématiques.
\paragraph*{}
Le théorème de Cayley-Hamilton, est l'un des théorèmes présents dans la liste des 100 théorèmes à formaliser~\cite{100th}. Ce papier en présente une première formalisation. Le fait qu'il n'avait pas été jusqu'à ce jour formalisé peut s'expliquer par le fait qu'il fait intervenir de nombreux objets et propriétés mathématiques. Ces objets ne sont pas uniquement utilisées, de façon indépendante; mais ils sont aussi emboîtés les uns sur les autres. Dans le cadre de ce travail de formalisation nous utilisons \ssr{} l'extension de \coq{} développée par G. Gonthier. Elle fournit des bibliothèques et un langage de tactique adaptés au travail de formalisation des mathématiques. Elle est la plate-forme de développement des travaux de formalisation du théorème de Feit-Thompson sur les groupes d'ordre impaires, un des objectifs du projet ``Mathematical Components''~\cite{manif}. 
\paragraph*{}
L'article est organisé comme suit. Dans la section 2, nous présentons l'énoncé et la preuve du théorème de Cayley-Hamilton. Dans la section 3, nous présentons \ssr{}, l'extension de \coq{} et plate-forme de notre développement. Enfin, dans la section 4, nous présentons le développement qui a été nécessaire pour arriver à la formalisation du théorème de Cayley-Hamilton. 

\section{Le théorème de Cayley-Hamilton}
Le théorème de Cayley-Hamilton~\cite{algebra} peut être énoncé de la façon suivante : 
\begin{center}
 \textit{Toute matrice carrée sur un anneau commutatif annule son polynôme caractéristique.}
\end{center}
Plus formellement, soient $R$ un anneau commutatif et $A$ une matrice carrée sur $R$. Alors, Le polynôme caractéristique de $A$, défini par : $p_{A}(x) = \det{(xI_{n} - A)}$, s'annule en A; ce qui veut dire que $p_{A}(A) = O_{n}$.
\newline
Le théorème peut être énoncé différemment en considérant les endomorphismes d'espace vectorielle. Dans ce cas il n'est plus question d'anneau commutatif mais de corps. L'énoncé et la preuve sont alors moins générales et plus simples.
\paragraph{}
La preuve du théorème de Cayley-Hamilton présentée dans ~\cite{algebra} découle de la formule de Cramer selon laquelle la multiplication d'une matrice $B$ par la transposée de sa co-matrice est égale au déterminant de cette même matrice $B$ multiplié par la matrice identité :
\begin{equation}
  \label{Cramer}
 B * {}^t{{\rm com} B} = {}^t{{\rm com} B} * B =\det{B} * I_{n}
\end{equation}
En appliquant la formule (\ref{Cramer}) à la matrice $(xI_{n} - A)$, nous obtenons :
\begin{equation}
  \label{Cramer-mx_poly}
 {}^t{{\rm com} (xI_{n} - A)} * (xI_{n} - A) =\det{(xI_{n} - A)} * I_{n} = p_{A}(x) * I_{n}
\end{equation}
La matrice $(xI_{n} - A) \in M_{n}(R[x]) = (M_{n}(R))[x] $ et les degrés de ses coefficients sont $\leq n-1$. $M_{n}(R[x])$ et $(M_{n}(R))[x] $ représentent respectivement l'anneau des matrices de polynômes et celui des polynômes de matrices sur un anneau $R$. Nous avons donc : 
\begin{equation}
\label{poly_tcom}
 {}^t{{\rm com} (xI_{n} - A)} = B_{n} x^{n} + B_{n-1} x^{n-1} + \cdots + B_{1} x + B_{0}
\end{equation}
De meme, si $p_{A}(x) = a_{n} x^{n} + a_{n-1} x^{n-1} + \cdots + a_{1} x + a_{0}$ nous avons alors que : 
\begin{equation}
\label{poly_car}
p_{A}(x)I_{n} = a_{n} I_{n} x^{n} + a_{n-1} I_{n} x^{n-1} + \cdots + a_{1} I_{n} x + a_{0} I_{n}
\end{equation}
L'égalité (\ref{Cramer-mx_poly}) devient donc : 
\begin{equation}
  \label{proof_start}
  (B_{n} x^{n} + B_{n-1} x^{n-1} + \cdots + B_{1} x + B_{0}) * (1 I_{n} x - A) = a_{n} I_{n} x^{n} + a_{n-1} I_{n} x^{n-1} + \cdots + a_{1} I_{n} x + a_{0} I_{n}
\end{equation}
Ceci montre que $(1 I_{n} x - A)$ est facteur de $p_{A}(x)I_{n}$ dans $(M_{n}(R))[x] $ et par le théorème du reste $ p_{A}(A) = O_{n} $.
\paragraph*{}
Formaliser une preuve mathématique dans un assistant de preuve consiste à développer cette preuve pour qu'elle soit compréhensible pour un ordinateur. Dans ce cadre, il est nécessaire d'une part d'expliciter les parties de cette preuve, implicites ou triviales pour un mathématicien. D'autre part, il est nécessaire d'éviter de se retrouver avec des formules longues, incompréhensibles et illisible pour un mathématicien.
\paragraph*{}
Dans le cas du théorème de Cayley-Hamilton et en considérant la preuve ci-dessus plusieurs problèmes se posent lors de sa formalisation. Dire que $M_{n}(R[x])$ est identique à $(M_{n}(R))[x]$ équivaut algébriquement à dire qu'il existe un isomorphisme d'anneau entre eux. En effet, toute matrice de polynômes peut s'écrire, de façon unique comme la somme de puissances en $x$ multipliées par des matrices, c'est-à-dire un polynôme à coefficients matriciels. Par exemple :
\begin{equation}
 \label{morphism}
 \left(
  \begin{array}{ c c }
     x^{2} + 1 & x - 2 \\
     - x + 3 & 2x - 4
  \end{array} \right)
=
 x^{2}\left(
  \begin{array}{ c c }
     1 & 0 \\
     0 & 0
  \end{array} \right) + 
x\left(
  \begin{array}{ c c }
     0 & 1 \\
     -1 & 2
  \end{array} \right) + 
\left(
  \begin{array}{ c c }
     1 & -2 \\
     3 & -4
  \end{array} \right)
\end{equation}
La formalisation de cette isomorphisme correspond à l'écriture de la fonction qui implémente de façon générale l'algorithme décrit dans l'exemple ci-dessus. La certification de cette fonction est nécessaire pour pouvoir l'utiliser dans la preuve formelle.
En notant $\phi$ cette isomorphisme, ses propriétés de morphisme sont utilisées implicitement dans la preuve. En effet, dans (\ref{Cramer-mx_poly}) les membres de l'égalité sont des matrices de polynômes. L'application de $\phi$ aux parties gauche et droite de (\ref{Cramer-mx_poly}) nous donne : 
\[   \phi ( {}^t{{\rm com} (xI_{n} - A)} * (xI_{n} - A)) = \phi ( p_{A}(x) * I_{n})) \]
Les propriétés de morphisme de $\phi$ sont alors utilisées pour obtenir :
\[       \phi ( {}^t{{\rm com} (xI_{n} - A)}) * \phi (xI_{n} - A)  = \phi ( p_{A}(x) * I_{n})) \]
Après développement de l'application de $\phi$ dans l'égalité ci-dessus, nous obtenons la formule (\ref{proof_start}) où $\phi ( {}^t{{\rm com} (xI_{n} - A)})$ est remplacé par (\ref{poly_tcom}) et $\phi ( p_{A}(x) * I_{n}))$ est remplacé par (\ref{poly_car}).\newline
Pour conclure la preuve utilise le théorème du reste selon lequel :
\[ p(x) = q(x)*(x-c) \Leftrightarrow p(c) = 0 \]
Dans ce théorème il y a un morphisme implicite : celui de l'évaluation des polynômes. Les propriétés de morphisme de l'évaluation se prouvent naturellement sur un anneau commutatif. Hors dans le théorème de Cayley-Hamilton il est question d'évaluation de matrice et l'anneau de matrice n'est pas commutatif. Pour prouver ces propriétés et par la suite prouver le théorème du reste il a fallu considérer des hypothèses de commutativité entre les coefficients du polynôme évalué et la matrice que l'on évalue.

\section{ \ssr }
\ssr~\cite{ssrman,modgrp} (pour \textit{Small Scale Reflection} ou réflection à petite échelle) est une extension de \coq{}~\cite{coqart} qui introduit de nouvelles tactiques et des bibliothèque \coq{} adaptées pour travailler sur des types avec une égalité décidable. Elle a été initialement développée par G. Gonthier dans le cadre de sa preuve du théorème des 4 couleurs. Un développement~\cite{modgrp} sur la théorie des groupes finis a été fait au dessus de \ssr. Ce développement comprend, entre autre, une formalisation du théorème de Sylow et du lemme de Cauchy-Frobenuis.\newline
Nous allons présenons en premier lieu la méthode de \ssr{} pour avoir la réflection entre les prédicats décidables et les booléens. Nous allons introduire par la suite quelques bibliothèques \coq{} de \ssr{} que nous avons utilisées dans notre développement. Des informations plus détaillées sur \ssr{} et précisément son langage de tactique peuvent être obtenues dans~\cite{ssrman}.
\subsection*{Réflection}
Dans le système de preuve \coq{} la logique par défaut est intuitionniste. Dans cette logique, les propositions logiques et les valeurs booléennes sont distinctes. Lorsque nous travaillons avec des types décidables cette distinction n'a pas lieu d'être. \ssr{} permet de combiner le meilleur des deux visions et de passer de la version propositionnelle d'un prédicat décidable vers la version booléenne. Pour ce faire, le type booléen est injecté dans celui des propositions par une coercion : 
\begin{verbatim}
Coercion is_true (b: bool) := b = true.
\end{verbatim}
Ainsi, et de façon transparente pour l'utilisateur, lorsque \coq{} attend un objet de type \texttt{Prop} et reçoit une valeur \texttt{b} de type \texttt{bool}, il la traduira automatiquement en la proposition \texttt{(is\_true b)}, qui correspond à la proposition \texttt{b $=$ true}.\newline
Le prédicat inductif \texttt{reflect} donne une équivalence pratique et confortable entre les propositions décidables et les booléens :
\begin{verbatim}
Inductive reflect (P: Prop): bool -> Type :=
  | Reflect_true: P => reflect P true
  | Reflect_false: ~P => reflect P false.
\end{verbatim}

La proposition \texttt{(reflect P b)} indique que \texttt{P} est équivalent à \texttt{(is\_true b)}. Par exemple, l'équivalence entre la conjonction booléenne \texttt{\&\&} et celle propositionnelle \verb|/\| est donnée par le lemme suivant : 
\begin{verbatim}
Lemma andP: forall a b, reflect (a /\ b) (a && b).
\end{verbatim}
Dans ce lemme \texttt{a} et \texttt{b} sont des variables booléennes.

\subsection*{Bibliothèques}
Des bibliothèques de base sont définies dans \ssr. C'est une hiérarchie de structure pour travailler avec les types décidables et en particulier les types finis. La structure \verb|eqType| définit les types munis d'une égalité décidable et de Leibniz.
\begin{verbatim}
Structure eqType : Type := EqType {
  sort :> Type; 
  _ == _ :  sort -> sort -> bool; 
  eqP :  forall x y, reflect (x = y) (x == y)
}.
\end{verbatim} 
Le symbole \verb|: >|  déclare \verb|sort| comme une coercion d'un \verb|eqType| vers son type porteur. C'est la technique standard de sous-typage, toute objet de type \verb|eqType| est aussi de type \verb|Type|. La structure \verb|eqType| ne suppose pas seulement l'existence d'une égalité décidable \verb|==|, en plus elle injecte cette égalité vers celle de Leibniz. \newline
Une propriété majeure des structures d'\verb|eqType| est qu'elles donnent la propriété de la \textit{proof-irrelevance} pour les preuves d'égalités de leurs éléments. Ainsi il n'y a qu'une seule preuve de l'égalité pour chaque paire d'objets égaux.
\begin{verbatim}
Lemma eq_irrelevance: forall (d: eqType) (x y: d) (E: x = y) (E': x = y), E = E'.
\end{verbatim} 
\paragraph*{}
Le type des listes sur un \verb|eqType d| se définit de façon inductive par :
\begin{verbatim}
Inductive seq : Type := Seq0 | Adds (x : d) (s : seq).
\end{verbatim} 
\verb|Adds| et \verb|Seq0| correspondent respectivement aux constructeurs \verb|cons| et \verb|nil| du type standard \verb|list| de \coq. Le type \verb|seq d| définit les listes sur un \verb|eqType d|. La fonction \texttt{foldr} correspond dans \ssr{} à l'opération \textit{fold} utilisée en programmation fonctionnelle. Elle est définit par récurrence sur une séquence. L'opération d'extraction d'un élément d'une liste est donnée par la fonction \verb|sub|. Par exemple \verb|sub x0 s i| retourne l'élément d'indice \texttt{i} de la séquence \texttt{s}, si \texttt{i} est strictement inférieure à la longueur de la séquence, et \texttt{x0} dans le cas contraire. La fonction \verb|mkseq| permet de construire une séquence de longueur donnée à partir d'une fonction sur les entiers. Par exemple, \verb|mkseq f n| correspond à la séquence \verb|[(f 0), (f 1), ..., (f n-1)]|.
%%%

%%%
\paragraph*{}
La définition du type liste sur un \verb|eqType| est à la base de celle des types finis. La structure \verb|finType| se compose d'une liste sur un \verb|eqType| et de la preuve qu'aucun élément de cette liste n'apparaît plus d'une fois.
\begin{verbatim}
Structure finType : Type := FinType {
  sort :> eqType;
  enum :  seq  sort;
  enumP :  forall x, count (set1 x) enum = 1
}.
\end{verbatim} 
Dans cette définition \verb|(set1 x)| est l'ensemble singleton ${x}$ et \verb|(count f l)| calcule le nombre d'éléments \verb|y| de la liste \verb|l| pour lesquels \verb|(f y)| est vraie. Le paramètre \verb|enum| correspond à la liste des éléments du type fini. Par exemple pour un \verb|finType d|, (\verb|enum d|) retourne la liste des éléments de \verb|d|. \newline
Pour représenter les types finis à \(n\) éléments, la bibliothèque \ssr{} fournit une famille de types nommée \verb|ordinal| dont les éléments sont des paires composées d'un nombre entier \(p\) et d'une preuve que \(p\) est inférieur à \(n\). Comme cette preuve est basée sur un test décidable, la propriété d'irrelevance s'applique et les éléments de ce type sont uniquement caractérisés par la composante \(p\). La notation \verb|I_(n)| désigne le type \verb|ordinal n|.

\section{Formalisations \coq}
Dans Ce travail de formalisation du théorème de Cayley-Hamilton, nous utilisons des bibliothèques sur les opérations indexées et les déterminants. Ces bibliothèques ont été développées par Y. Bertot et G. Gonthier dans le cadre du projet ``Mathematical Components''. \ssr{} contient aussi une bibliothèque  qui fournit une formalisation des structures algébriques de monoïde, groupe et anneau. L'utilisation de cette bibliothèque et le mécanisme des Canonical Structure de \coq{} nous ont permis d'avoir des notations proches de celles utilisées de façon standard en mathématiques. La bibliothèque sur les polynômes fournit une formalisation des propriétés algébrique des polynômes, du morphisme d'évaluation et du théorème du reste. La définition de l'isomorphisme entre l'anneau des matrices de polynômes et celui des polynômes de matrices est l'étape ultime de la formalisation du théorème de Cayley-Hamilton.

\subsection{Les opérations indexées} 
Dans la définition des opérations sur les matrices, par exemple la multiplication ou le calcul du déterminant, les opérations indexées (somme et produit) sont fréquentes. Factoriser la preuve de propriétés générales sur les sommes et produits indexés permet de réduire considérablement la longueur et la complexité des preuves. Une bibliothèque pour les opérations indexées n'est pas seulement utile dans le développement sur la théorie des matrices, elle pourra l'être aussi dans des développements plus générales que l'algèbre linéaire.
\paragraph{}
Une opération indexée est la généralisation de la définition d'une opération binaire aux éléments d'une suite finie. Dans le cas particulier de l'addition, c'est la somme de tous les éléments d'une suite donnée. \newline
La définition d'une opération indexée est donnée par :
\begin{verbatim}
Definition reducebig R I op nil (r : seq I) P F : R :=
  foldr (fun i x => if P i then op (F i : R) x else x) nil r.
\end{verbatim}
La fonction \verb|reducebig| a comme paramètres un type quelconque \verb|R|, un \verb|eqType I|, une opération binaire \verb|op| sur \verb|R|, un élément \verb|nil| de \verb|R| correspondant à l'ensemble vide, une séquence \verb|r| sur \verb|I|, une propriétés caractéristique \verb|P| sur \verb|I| (une fonction de \verb|I| vers \verb|bool| : un ensemble sur \verb|I|) et une fonction \verb|F| de \verb|I| vers \verb|R|. Le résultat de \verb|reducebig| correspond schématiquement à :
\[ F ~ p_{1} ~ op ~ F ~ p_{2} ~ op ~ \cdots ~ op ~ F ~ p_{n} ~ op ~ nil,  \] 
Les $p_{i}$ sont les éléments de la séquence $r$ pour lesquels la propriété $P$ est vraie : les éléments de l'ensemble $P$. L'utilisation de \verb|reducebig| est plus naturelle lorsque l'opération est associative et commutative et lorsque \verb|nil| est l'élément neutre de cette opération. En d'autres termes, lorsque \verb|op| et \verb|nil| ont des propriétés de monoïde. \newline
La notation \verb|\big[*%M/1]_(i|\texttt{| P i) F i} correspond à l'application de \verb|reducebig| à une opération \verb|*| qui a pour élément neutre \verb|1| et qui a des propriétés de monoïde. Le reste des paramètres sont inférés de façon implicite par \coq.
\paragraph*{}
Un lemme intéressant sur \verb|reducebig|  est celui qui permet d'effectuer l'opération usuelle de ré-indexation. Dans le cas d'une somme indexée, ce lemme correspond à l'égalité entre les sommes 
$ \sum_{i=0}^{n} (i + m)$ et $ \sum_{j=m}^{n + m} j $. Une façon de formaliser cette égalité est de considérer que $i$ et $j$ sont de types différents et qu'il existe une bijection entre eux.
Cette bijection est la fonction $ f : x \leftarrow x + m $. \newline
Le prédicat \verb|ibjective P h| permet de dire que la fonction \verb|h| est bijective sur l'ensemble {\tt P}. Le lemme de ré-indexation s'énonce alors comme suit : 
\begin{verbatim}
Lemma reindex : forall (I J : finType) (h : J -> I) P F,
  ibijective P h ->
  \big[*%M/1]_(i | P i) F i = \big[*%M/1]_(j | P (h j)) F (h j).
\end{verbatim}
Un autre résultat intéressant sur les opérations indexées est celui qui permet de décomposer cette opération suivant une partition de l'ensemble d'indice. Par exemple, dans le cas d'une somme indexée, le résultat s'écrit $ \sum_{i=0}^{n + m} i = \sum_{i=0}^{n} i + \sum_{i=n+1}^{n + m} i $. La généralisation de cette propriété peut s'écrire formellement :
\begin{verbatim}
Lemma bigID : forall (I : finType) (a : set I) (P : I -> bool) F,
  \big[*%M/1]_(i | P i) F i
    = \big[*%M/1]_(i | P i && a i) F i * \big[*%M/1]_(i | P i && ~~ a i) F i.
\end{verbatim}
Dans ce lemme, étant donnés deux ensembles \texttt{P} et \texttt{a}, une partition de \texttt{P} est donnée par les deux ensembles $\mathtt{P \cap a}$ et $\mathtt{P \cap \bar{a} }$. La somme des éléments indexés par \texttt{P} peut être donc décomposée en deux sommes des éléments indexés par ces deux ensembles.


\subsection{Structures canoniques}
Dans l'assistant de preuve \coq, le mécanisme des \texttt{Canonical Structure} permet de définir une instance d'un type structurel (mot clé \coq{} \texttt{Record} ou \texttt{Structure}) qui pourra être utilisée lors du processus d'inférence de type dans des équations invoquant des arguments implicites. Par exemple, pour définir une structure de \texttt{eqType} sur le type \texttt{nat} il faut une égalité décidable sur les entiers et prouver que cette égalité est équivalente à celle de Leibniz sur les entiers. 
\begin{verbatim}
Fixpoint eqn (m n : nat) {struct m} : bool :=
  match m, n with
  | 0, 0 => true
  | S m', S n' => eqn m' n'
  | _, _ => false
  end.
Lemma eqnP : reflect_eq eqn.
Proof.
...
Qed.
Canonical Structure nat_eqType := EqType (@eqnP).
\end{verbatim}
Grâce à la définition de \texttt{Canonical Structure nat\_eqType}, les arguments \texttt{m} et \texttt{n} vont être typés comme des éléments d'un \texttt{eqType}, il sera donc correcte de considérer l'égalité booléenne entre eux.
\begin{verbatim}
Lemma eqn_add0 : forall m n, (m + n == 0) = (m == 0) && (n == 0).
\end{verbatim} 
\paragraph*{}
Le mécanisme des \texttt{Canonical Structure} peut être appliquée à des structures plus complexes comme les anneaux. Dans les bibliothèques sur les matrices et les polynômes, nous définissons les types de polynômes et matrices sur des structures d'anneaux. Des structures d'anneaux sont ensuite définies sur ces types. Ainsi les mêmes opérations d'anneaux (addition, multiplication et opposé) sont utilisées pour les matrices et les polynômes. Avec la définition des \texttt{Canonical Structure} sur ces structures, \coq{} pourra inférer automatiquement que la structure d'anneau sur les polynômes et les matrices. Ceci nous permet d'avoir des énoncés proches de ceux en mathématique standard et plus lisible du point de vue de l'utilisateur. 

\subsection{Matrices et déterminants}
Une matrice sur un anneau $R$ est une séquence de coefficients doublement indexée. Elle peut être vue comme une fonction qui associe à une position  \((i,j)\) une valeur dans l'anneau $R$. Étant donnés $m$ et $n$ deux entiers et $R$ un anneau, une matrice sur $R$ (un objet de type $M_{m,n}(R)$) peut être représentée par la fonction suivante : $ [0..n[ \rightarrow [0..m[ \rightarrow R$. Le type des matrices de taille \((m,n)\) est défini par :
\begin{verbatim}
Definition matrix (m n :nat) :=
  fgraphType (I_(m) * I_(n)) R.
\end{verbatim} 
Dans cette définition, les matrices sont des fonctions à deux arguments. La fonction \texttt{fgraphType} construit le graphe des fonctions dont le domaine est un type fini et le co-domaine un eqType. Avec la définition des graphes de fonctions, les fonctions sont ainsi munies d'une égalité de Leibniz et ceci sans avoir besoin de nouveaux axiomes. Pour deux fonctions \texttt{f} et \texttt{g}, les notations \texttt{f =1 g} et \texttt{f =2 g} équivalent respectivement à $\mathtt{\forall x, f~x = g~x}$  et  $\mathtt{\forall x~y, f~x~y = g~x~y}$.
\paragraph*{}
Les fonctions \verb|matrix_of_fun| et \verb|fun_of_matrix| permettent respectivement de définir un objet de type \texttt{matrix} à partir d'une fonction et de convertir un objet de type \texttt{matrix} en une fonction à deux arguments. Cette dernière n'est autre qu'une coercion du type \texttt{matrix} vers celui des fonctions. Elle nous permet de dire que deux matrices \texttt{A} et \texttt{B} sont égales si et seulement si nous avons \texttt{A =2 B}. Ce qui veut dire que les fonctions associées à ces matrices sont égales : \texttt{fun\_of\_matrix A =2 fun\_of\_matrix B}.\newline
Dans la suite, les notations \texttt{M\_(n)} et \verb|\Z| correspondent respectivement au type des matrices carrées et à la multiplication d'un scalaire par la matrice identité.

\paragraph*{}
La bibliothèque sur les déterminants utilise la formule de Leibniz pour définir le déterminant. Ce choix est motivé par le fait que dans cette formule il est question de groupe de permutations et qu'une formalisation des permutations (groupe, signature ...) a été déjà développée dans le cadre du travail sur les groupes finies~\cite{modgrp}. Etant donné une matrice carrée $A$ de dimension $n$, le déterminant est donnée par :
\begin{equation}
  \label{leibniz} \det(A)=\sum_{\sigma \in S_n} 
\epsilon(\sigma) \prod_{i=1}^n a_{i, \sigma(i)}
\end{equation} 
Dans cette formule, il est question d'opérations indexées pour les sommes et les produits, mais les notations mathématiques cachent plusieurs autres éléments. Dans la bibliothèque sur les déterminant, pour pouvoir formaliser la formule (\ref{leibniz}) :
\begin{itemize}
 \item l'indexation des lignes et colonnes de la matrice par des entiers est remplacée par une 
indexation par les éléments du type \texttt{I\_(n)},
 \item l'ensemble des permutations sur cet ensemble fini est décrit comme un ensemble fini qui pourra être énuméré.
\end{itemize}

\paragraph{}
Avec ces choix, grâce aux développements sur le calcul de la parité des permutations et à celui sur les groupes de permutations, la formule (\ref{leibniz}) s'écrit :
\begin{verbatim}
 Definition determinant n (A : M_(n)) :=
  \sum_(s : S_(n)) (-1) ^ s * \prod_(i) A i (s i).
\end{verbatim} 

Les notations \verb|\sum| et \verb|\prod| représentent respectivement la somme et le produit indexées. Ce sont des instances de \verb|reducebig| pour les opérations internes (addition et multiplication) de l'anneau des coefficients de la matrice. La notation \verb|S_(n)| représente le groupe des permutations de taille $n$. Dans la suite, la notation \verb|\det| représentera la fonction \verb|determinant|.
\paragraph{}
Pour exprimer la règle de Cramer,  la co-matrice d'une matrice est définie à l'aide de la fonction {\tt row'}. Cette dernier prend en entrée  un nombre \(i\) inférieur à \(m\) (un élément de type {\tt I\_(m)}) et une matrice \((m,n)\); elle retourne la matrice \((m-1,n)\) où la rangée \(i\) a été enlevée. Avec les mêmes arguments, la fonction {\tt row} retourne la matrice \((1,n)\) (une rangée et \(n\) colonnes) qui contient la rangée \(i\). La transposée de la co-matrice est représentée par la fonction {\tt adjugate}.  L'égalité de Cramer s'énonce alors : 
\begin{verbatim}
Definition cofactor n (A : M_(n)) (i j : I_(n)) :=
   (-1) ^+(i + j) * \det (row' i (col' j A)).
Definition adjugate n (A : M_(n)) := \matrix_(i, j) (cofactor A j i).

Lemma mulmx_adjr : forall n (A : M_(n)), A * adjugate A = \Z (\det A).
\end{verbatim}
La preuve utilise la formule de Laplace ($\det(A)=\sum_{i=1}^{n} a_{i;j} {\rm co-matrice}_{i,j}$) sur les co-matrices et le lemme selon lequel le déterminant est une forme alternée (le déterminant d'une matrice, où au moins deux lignes sont identiques, est nul). Ces propriétés sont donnés respectivement par les lemmes suivants :
\begin{verbatim}
Lemma expand_determinant_row : forall n (A : M_(n)) i0,
  \det A = \sum_(j) A i0 j * cofactor A i0 j.
Lemma alternate_determinant : forall n (A : M_(n)) i1 i2,
  i1 != i2 -> A i1 =1 A i2 -> \det A = 0.
\end{verbatim} 
Le terme \verb|A i1 =1 A i2| correspond à l'égalité entre les lignes d'indice \verb|i1| et \verb|i2| de la matrice {\tt A}.

\subsection{Polynômes}
Un polynôme est défini par la liste de ses coefficients $a_{i}$ qui appartiennent à un anneau $R$: 
\[ a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0}\]
Cette représentation n'est malheureusement pas unique, en effet les polynômes $ a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0} $ et $ 0 x^{n + 1} + a_{n} x^n + a_{n - 1} x^{n - 1} + \cdots + a_{1} x + a_{0} $ ont des listes de coefficients différentes mais représentent le même polynôme. Pour avoir une égalité de Leibniz pour cette représentation, il est nécessaire de ne considérer que les polynômes normalisés, c'est-à-dire ceux dont le coefficient de plus grand degré est non nul, et avoir une égalité de Leibniz sur les coefficients. Les polynômes sont donc représentés par la structure suivante :
\begin{verbatim}
Structure polynomial (R : ring) : Type := Poly {
  p :>  seq R;
  normal : last 1 p != 0
}.
\end{verbatim} 
Avec cette définition nous pouvons donc définir une structure de \verb|eqType| sur les polynômes. Mais il est parfois utile de voir les polynômes juste comme une fonction qui donne les coefficients. Nous avons donc défini la fonction coefficient des polynômes par :
\begin{verbatim}
Definition coef (p : polynomial) i := sub 0 p i.
\end{verbatim} 
La fonction \verb|coef p| est de type \verb|nat -> R|. Le lemme suivant permet d'avoir l'équivalence entre l'égalité entre les polynômes et celles entre les fonctions de coefficient : 
\begin{verbatim}
Lemma coef_eqP : forall p1 p2, coef p1 =1 coef p2 <-> p1 = p2.
\end{verbatim} 
Avec ce lemme, nous pouvons passer de notre représentation structurelle des polynômes vers celle qui ne considère que la fonction des coefficients. L'avantage de la second représentation est de rendre les preuves des propriétés algébriques des polynômes plus intuitives. Par exemple, la multiplication de deux polynômes est définie par :
\begin{equation}
\label{poly-mult}
\left(\sum_{i=0}^n a_ix^i\right)\left(\sum_{j=0}^m  b_jx^j\right)=\sum_{k=0}^{m+n}\left(\sum_{i +j =k}a_{i} b_{j}\right)x^k.
\end{equation} 
La preuve de l'associativité de cette multiplication se ramène à des raisonnements sur des sommes indexées, sans avoir besoin de faire des récurrences sur les polynômes.\newline
Dans la suite, les notations \verb|\X|, \verb|\C c| et \verb|\C0| correspondent respectivement au monôme $x$, au polynôme constant $c$ et au polynôme nul (la séquence vide).\newline
L'opération de multiplication d'un polynôme par \verb|x| (décalage à droite) et addition d'une constante est l'une des opérations de base sur les polynômes. Dans la bibliothèque elle est réalisée par la fonction suivante : 
\begin{verbatim}
Definition horner c p : polynomial :=
  if p is Poly (Adds _ _ as s) ns then Poly (ns : normal (Adds c s)) else \C c.
\end{verbatim}
A partir de cette définition, la fonction de construction d'un polynôme à partir d'une liste de coefficient se définit simplement par :
\begin{verbatim}
Definition mkPoly := foldr horner \C0.
Notation "\poly_ ( i < n ) E" := (mkPoly (mkseq (fun i : nat => E) n)).
\end{verbatim}
La notation \verb|\poly| permet de construire un polynôme à partir d'une fonction de coefficients. Par exemple, le polynôme correspondant à \verb|\poly_ ( i < n ) i| est le suivant :
 \[ {n - 1} x^{n - 1} + \cdots + {1} x + {0}\] 
\paragraph{}
Les opérations de base sur les polynômes sont définies par récurrence sur la séquence des coefficients. La séquence résultat est ensuite normalisée par la fonction \verb|mkPoly|. Par exemple la multiplication de deux polynômes est définie comme suit :
\begin{verbatim}
Fixpoint mult_poly_seq (s1 s2 : seq R) {struct s1} : seq R :=
  if s1 is Adds c1 s1' then
    add_poly_seq (maps (fun c2 => c1 * c2) s2)
                 (Adds 0 (mult_poly_seq s1' s2))
  else seq0.

Definition mult_poly (p1 p2 : polynomial) := mkPoly (mult_poly_seq p1 p2).
\end{verbatim} 
Dans la seconde définition, la conversion de type entre les types \verb|polynomial| et \verb|seq| permet d'écrire \verb|mult_poly_seq p1 p2| bien que \verb|p1| et \verb|p2| sont de type \verb|polynomial|. Le lemme \verb|coef_mul_poly|
\begin{verbatim}
Lemma coef_mul_poly : forall p1 p2 i,
  coef (mult_poly p1 p2) i = \sum_(j <= i) coef p1 j * coef p2 (i - j).
\end{verbatim}
donne une relation entre les coefficients des deux polynômes et le résultat de leur multiplication. Il correspond à la relation de la formule (\ref{poly-mult}).
\paragraph{}
Une autre opération importante sur les polynômes est la fonction d'évaluation d'un polynôme. Elle consiste à remplacer sa variable par une valeur donnée. Cette fonction peut être décrite avec le schéma de Horner pour un polynôme \verb|p| et une valeur \verb|x| par :
\begin{equation}
 \label{horner-sch}
   p(x) = ((...((a_{n}x + a_{n-1})x + a_{n-2})x + ... ) + a_{1})x + a_{0}
\end{equation}
Suivant le schéma (\ref{horner-sch}) l'évaluation ne dépend que de la séquence des coefficients et de la valeur où nous évaluons. Elle se définit par récurrence sur la séquence des coefficients. La fonction d'évaluation peut être définie par récurrence comme suit :
\begin{verbatim}
Fixpoint eval_poly_seq (s : seq R) (x : R) {struct s} : R :=
  if s is (Adds a s') then eval_poly_seq s' x * x + a else 0.
Definition eval_poly (p : polynomial R) : R-> R := eval_poly_seq p.
\end{verbatim}
La notation \verb|p.[c]| correspond à l'application de la fonction \verb|eval_poly| en \verb|p| et \verb|c|.\newline
Les propriétés de morphisme de la fonction d'évaluation sont utilisées implicitement dans la preuve du théorème de Cayley-Hamilton. Ces propriétés sont données par les lemmes suivants :
\begin{verbatim}
Lemma eval_polyC : forall c x, (\C c).[x] = c.
Lemma eval_poly_plus : forall p q x,
 (p + q).[x] = p.[x] + q.[x].
Lemma eval_poly_mult : forall p q x,
 (forall i, (coef q i) * x = x * (coef q i)) ->
  (p * q).[x] = p.[x] * q.[x].
\end{verbatim} 
Dans le second lemme, la condition de commutativité entre les coefficients de \texttt{q} et \texttt{x} est nécessaire dans le cas d'un anneau non commutatif (les matrices par exemples).
\[
\mathrm{Soient} ~~~ p(x) = \sum_{i=0}^n a_ix^i ~~ \mathrm{et} ~~ q(x) = \sum_{j=0}^m  b_jx^j
\]
\begin{equation}
 \label{prod1}
\begin{array}{l l l l l }
  (p*q)(x) & = & \sum_{k=0}^{m+n}\left(\sum_{i+j =k}a_{i} b_{j}\right)x^k & = & \cdots a_{i} b_{j}x^(i +j) \cdots\\
\end{array} 
\end{equation} 
\begin{equation}
 \label{prod2}
\begin{array}{l l l l l }
  p(x)*q(x)& = & \left(\sum_{i=0}^n a_ix^i\right)\left(\sum_{j=0}^m  b_jx^j\right) & = & \cdots a_ix^ib_jx^j \cdots \\
\end{array} 
\end{equation}
La condition de commutativité s'explique donc par le fait que pour passer de (\ref{prod1}) à (\ref{prod2}), il faut que tous les $b_j$ commutent avec $x$.
\paragraph*{}
Après ces développements, le théorème du reste peut s'énoncer comme suit :
\begin{verbatim}
Theorem factor_poly : forall p c,
  (exists q, p = q * (\X - \C c)) <-> (p.[c] = 0).
\end{verbatim} 
Dans la preuve de ce théorème, pour pouvoir dire que \verb|p.[c]| est égale à \verb|q.[c] * (\X - \C c).[c]|, il faut prouver que les coefficients du polynôme \verb|(\X - \C c)| commutent avec \texttt{c}. Ce qui se prouve facilement car \texttt{1} et \texttt{c} commutent avec \texttt{c}.

\subsection{Preuve de Cayley-Hamilton}
Le morphisme entre l'anneau des matrice de polynômes et celui des polynômes de matrices est la partie centrale de la preuve du théorème de Cayley-Hamilton. Les autres composantes de la preuve : la règle de Cramer et le théorème de factorisation, sont des propriétés qui se rattachent respectivement aux matrices et aux polynômes. \newline
Ce morphisme que nous allons appeler \verb|phi| prend en entrée une matrice de polynômes, lui applique le procédé décrit dans (\ref{morphism}), et retourne un polynôme de matrices. La longueur de la séquence des coefficients du polynôme résultat est la taille maximale des polynômes de la matrice de départ. La taille d'un polynôme correspond à la longueur de la séquence de ces coefficients, en d'autre terme son degré plus un. Dans la suite, les notations \verb|M(R)|, \verb|M(R[X])| et \verb|M(R)[X]| représentent respectivement l'anneau des matrices, celui des matrices de polynômes et celui des polynômes de matrices. 
\begin{verbatim}
Definition phi (A : M(R[X])) : M(R)[X] :=
  \poly_(k < \max_(i) \max_(j) size (A i j)) \matrix_(i, j) coef (A i j) k.
\end{verbatim} 
Le lemme donnant la relation entre le résultat de \verb|phi| et sa valeur d'entrée est utilisé dans la preuve des propriétés de morphismes. Ce lemme dit que pour toute matrice de polynômes $M$, le coefficient du polynôme $M_{i, j}$ en $k$ est égale à l'élément d'indice $(i, j)$ de la matrice coefficient en $k$ de l'image de $M$ par \verb|phi|.
\begin{verbatim}
Lemma coef_phi : forall A i j k, coef (phi A) k i j = coef (A i j) k.
\end{verbatim} 
Pour pouvoir définir l'évaluation d'une matrice en son polynôme caractéristique, nous avons défini l'injection de l'anneau des polynômes vers celui des polynômes de matrices. Cette fonction prend un polynôme sur un anneau de base $R$ et multiplie ses coefficients par la matrice identité pour obtenir un polynôme à coefficients matriciels. La notation \texttt{Zpoly} correspond à cette fonction. \newline
Le polynôme caractéristique d'une matrice est définit en appliquant la définition du déterminant à la matrice de polynômes $xI_{n} - A$.  
\begin{verbatim}
Definition matrixC (A : M(R)) : M(R[X]) := \matrix_(i, j) \C (A i j).
Definition char_poly (A : M(R)) : R[X] := \det (\Z \X - matrixC A).
\end{verbatim}
La fonction \verb|matrixC| est l'injection canonique de l'anneau des matrice vers celui des matrice de polynômes.
\paragraph*{} 
Après ces définitions, le théorème de Cayley-Hamilton est prouvé formellement de la façon suivante :
\begin{verbatim}
Theorem Cayley_Hamilton : forall A, (Zpoly (char_poly A)).[A] = 0.
Proof.
move=> A; apply/eqP; apply/factor_theorem.
rewrite -phi_Zpoly -mulmx_adjl phi_mul; move: (phi _) => q; exists q.
by rewrite phi_add phi_opp phi_Zpoly phi_polyC ZpolyX.
Qed.
\end{verbatim} 

La preuve se déroule exactement comme décrit dans la seconde section. Après avoir appliqué le théorème du reste, le polynôme facteur est donné en récrivant avec la règle de Cramer. Le résultat du théorème de Cayley-Hamilton est alors obtenu par des réécritures et simplifications dans le terme obtenu. L'utilisation de \ssr{} a permit d'aboutir à une preuve aussi concise : 3 lignes de codes. C'est l'un des avantages du langage de tactique de \ssr{} par rapport à celui de \coq{} standard. 

\section{Conclusion}
Nous avons présenté une formalisation du théorème de Cayley-Hamilton qui adopte une approche modulaire. La preuve que nous avons présenté dans la section 4.4 peut paraître très simple; mais la conception a été assez longue que ce soit pour choisir l'architecture globale de la preuve ou le bon type de données pour représenter les structures manipulées (polynômes et matrices). Ceci a été d'autant plus difficile car dans la preuve les structures utilisées vont être combinées les unes avec les autres. Les choix ont été motivés par des soucis de lisibilité et de réutilisabilité. L'utilisation des {Canonical Structure} de \coq{} nous a permis d'avoir des énoncés proches de ceux utilisés en mathématiques classiques. Le découpage des différentes composantes de la preuve sous forme modulaire ( les opérations indexées, les matrices et les polynômes) favorise la réutilisation de ces bibliothèques dans des développements indépendants. Les bibliothèques sur les opérations indexées et les matrices seront réutilisées dans nos prochains travaux sur la théories des caractères, une des composantes de la preuves du théorème de Feit-Thompson.\newline
Ce travail que nous avons présenté ici est la première formalisation du théorème de Cayley-Hamilton. Ce n'est pas la première formalisation des matrices ou des polynômes. Des formalisations de ces structures sont présentées respectivement dans~\cite{ring-mx, linalg} et~\cite{fta, factor-th}. Mais c'est le premier développement qui regroupe une formalisation des matrices et polynômes et où ces objets sont assemblées pour former de nouveaux objets : les matrices de polynômes et les polynômes de matrices. Dans ce développement la bibliothèque sur les polynômes comprend 83 objets (définitions et lemmes) pour environs 490 lignes de codes. Celle pour les matrices comprend 89 objets pour 700 lignes de codes. Les définitions et lemmes propres à la preuve du théorème de Cayley-Hamilton sont au nombre de 15 pour 125 lignes de codes. Les sources du développement sont disponibles à l'adresse suivante : \verb|http://www-sop.inria.fr/marelle/Sidi.Biha/cayley/|.  
\paragraph*{}
Dans la formalisation du théorème de Cayley-Hamilton, présentée dans cet article, nous avons choisi de construire nos structures de données sur des types munis d'une égalité décidables: les \texttt{eqType}. En plus du fait qu'en mathématiques classiques tous les types sont décidables, notre preuve sur les types décidables peut être généralisés vers les types quelconques. Ceci se fait en remarquant que tout anneau est une $\mathbf{Z}$-algèbre et en considérant le morphisme d'évaluation des polynômes à $n^{2}$ variables et à coefficients dans $\mathbf{Z}$ qui est un type décidable. Puisque les opérations algébriques sur les matrices et les polynômes n'agissent qu'en fonction des indices des coefficients, ce morphisme commute avec ces opérations. Par conséquent le théorème de Cayley-Hamilton sur les types décidables peut être généralisé à des types quelconques. Cette démarche n'est pas difficile mais elle est fastidieuse et d'aucune utilité pour le travail que nous faisons dans le cadre du projet ``Mathematical Components''. L'avantage de construire nos structures de données (anneaux, matrices et polynômes) sur des types décidables est d'avoir une égalité de Leibniz sur ces structures. Nous pourrons alors profiter de la puissance de la réécriture avec cette égalité, qui est la règle de réécriture par défaut dans \coq{}.

% La bibliographie
\begin{thebibliography}{10} % N'oubliez pas de l'inclure lors
\bibitem{primeth}
  Jeremy \textsc{Avigad}, Kevin \textsc{Donnelly}, David \textsc{Gray}, et Paul \textsc{Raff},
  \textit{A Formally Verified Proof of the Prime Number Theorem},
  ACM Transactions on Computational Logic, A paraître.

\bibitem{coqart}
  Yves \textsc{Bertot}, Pierre \textsc{Castéran},
  \textit{Interactive Theorem Proving and Program Development Coq'Art: The Calculus of Inductive Constructions},
  Springer Verlag,
  2004.

\bibitem{algebra}
  Nathan \textsc{Jacobson},
  \textit{Lectures in Abstract Algebra: II. Linear Algebra},
  Springer Verlag, 1975.

\bibitem{fta}
  Herman \textsc{Geuvers}, Freek \textsc{Wiedijk} et Jan \textsc{Zwanenburg},
  \textit{A Constructive Proof of the Fundamental Theorem of Algebra without Using the Rationals},
  Types for Proofs and Programs, TYPES 2000 International Workshop, Selected Papers, volume 2277 of
  LNCS, pages 96-111, 2002.

\bibitem{4colproof}
  Georges \textsc{Gonthier},
  \textit{A computer-checked proof of the four-colour theorem},
  Disponible à http://research.microsoft.com/~gonthier/4colproof.pdf.

\bibitem{ssrman}
  Georges \textsc{Gonthier}, Assia \textsc{Mahboubi},
  \textit{A small scale reflection extension for the Coq system},
  Disponible à http://www.msr-inria.inria.fr/~assia/rech-eng.html.

\bibitem{modgrp}
  Georges \textsc{Gonthier}, Assia \textsc{Mahboubi}, Laurence \textsc{Rideau}, Enrico \textsc{Tassi} et Laurent \textsc{Théry},
  \textit{A Modular Formalisation of Finite Group Theory},
  Rapport de Recherche 6156, INRIA, 2007.

\bibitem{manif}
  Georges \textsc{Gonthier}, Benjamin \textsc{Werner}, Yves \textsc{Bertot},
  \textit{Mathematical Components Manifesto},
  Disponible à http://www.msr-inria.inria.fr/projects/math/manifesto.html.

\bibitem{ring-mx}
  Nicolas \textsc{Magaud},
  \textit{Ring properties for square matrices} contribution à Coq,
  http://coq.inria.fr/contribs-eng.html.

\bibitem{factor-th}
  Piotr \textsc{Rudnicki},
  \textit{Little Bezout Theorem (Factor Theorem)}, Journal of Formalized Mathematics volume 15, 2003,
  Disponible à http://mizar.org/JFM/Vol15/uproots.html.

\bibitem{linalg}
  Jasper \textsc{Stein},
  \textit{Linear Algebra} contribution à Coq,
  http://coq.inria.fr/contribs-eng.html.

\bibitem{coqman}
  \textsc{Coq Team},
  \textit{The Coq reference manual V 8.1},
  http://coq.inria.fr/V8.1/refman/index.html.

\bibitem{100th}
  Freek \textsc{Wiedijk},
  \textit{Formalizing 100 Theorems},
  http://www.cs.ru.nl/freek/100/.

\end{thebibliography}

\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage
\end{document}