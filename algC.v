(* (c) Copyright Microsoft Corporation and Inria. All rights reserved. *)
Require Import ssreflect ssrbool ssrfun ssrnat eqtype seq choice div fintype.
Require Import bigop prime ssralg.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import GRing.Theory.
Local Open Scope ring_scope.

(******************************************************************************)
(* This file provides a temporary partial axiomatic presentation of the       *)
(* algebraic numbers.                                                         *)
(*       algC == the closed field of algebraic numbers.                       *)
(*        z^* == the complex conjugate of z.                                  *)
(*     0 <= x <=> x is a nonnegative real.                                    *)
(*     x <= y <=> (y - x) is a nonnegative real                               *)
(*      x < y <=> (y - x) is a (strictly) positive real                       *)
(*    sqrtC z == a nonnegative square root of z, i.e., 0 <= sqrt x if 0 <= x. *)
(*       `|z| == the complex norm of z, i.e., sqrtC (z * z^* ).               *)
(*  isNatC z <=> z is a natural number.                                       *)
(*  getNatC x == the n such that x = n%:R if isNatC x, else 0.                *)
(*  isRealC x == x is a real number, i.e., x^* == x.                          *)
(*     isIntC x == x is an integer.                                           *)
(*    getIntC x == a pair (n, b) such that x = (-1) ^+ b * n%:R, if isIntC x. *)
(*     dvdC x y == x divides y, i.e., y = z * x for some integer z.           *)
(******************************************************************************)

Parameter algC : closedFieldType.
Parameter conjC : {rmorphism algC -> algC}.
Parameter repC : algC -> bool. (* C -> R^+ *)
Implicit Types (x y z : algC) (m n p : nat) (b : bool).

Notation "x ^*" := (conjC x) (at level 2, format "x ^*") : C_scope.
Open Scope C_scope.
Delimit Scope C_scope with C.

Axiom conjCK : involutive conjC.
Axiom repCD : forall x y, repC x -> repC y -> repC (x + y).
Axiom repCMl : forall x y, x != 0 -> repC x -> repC (x * y) = repC y.
Axiom repC_anti : forall x, repC x -> repC (- x) -> x = 0.
Axiom repC_pconj : forall x, repC (x * x ^*).
Axiom realC_archimedean : forall x, repC x ->
  exists n, [&& repC (x - n%:R), repC (n.+1%:R - x) & x != n.+1%:R].

(*   All these are redundant axioms / parametere.                             *)
(* Axiom Cchar : [char algC] =i pred0.                                        *)
(* Axiom Cchar : [char algC] =i pred0.                                        *)
(* Axiom repC_unit_exp : forall x n, repC x -> (x ^+ n.+1 == 1) = (x == 1).   *)
(* Axiom repC_conjI : forall x, repC x -> x^* = x.                            *)
(* Axiom repC1 : repC 1.                                                      *)
(* Variable sqrtC : algC -> algC.                                             *)
(* Axiom sqrtCK : forall c, (sqrtC c) ^+ 2 = c.                               *)
(* Axiom repC_sqrt : forall c, repC (sqrtC c) = repC c.                       *)
(* Axiom sqrtC_mul : {morph sqrtC: x y / x * y}. GG -- This is inconsistent!  *)
(* Axiom normC_add : forall x y,  normC (x + y) <= normC x + normC y.         *)
(* Axiom normC_add_eq : forall x y : algC,                                    *)
(*     normC (x + y) = normC(x) + normC(y) ->                                 *)
(*   exists2 k, normC k = 1 & ((x == normC x * k) && (y == normC y * k)).     *)
(* Parameter getNatC : algC -> nat.                                           *)
(* Axiom getNatC_def : forall c,                                              *)
(*  if (0 <= c) then ((getNatC c)%:R <= c) && (c < (getNatC c + 1)%:R)        *)
(*  else getNatC c == 0%N.                                                    *)

(* Note and caveat: Q-automorphisms of algC do not necessarily commute with   *)
(* conjugation. However, they necessarily do so on the subfield of algC       *)
(* generated by roots of unity, hence on all character values. We should      *)
(* therefore always ensure we only consider dot products of automorphisms of  *)
(* character on (virtual) characters - the alternative would be to add an     *)
(* explicit commutation condition (making sure that the automorphisms we      *)
(* generate from automorphisms of Q_n verify id); that approach would be less *)
(* convenient for things like reindexing irreducible characters, so I'll try  *)
(* to go with the first as much as I can.                                     *)
(*  Further note: by a theorem of Brauer, all character theory can be done in *)
(* the subfield generated by all nth roots of unity; is this an effective     *)
(* subfield of the algebraics ?                                               *)
Definition algC_Aut (u : {rmorphism algC -> algC}) := forall x, (u x)^* = u x^*.
Lemma conjC_AutC : algC_Aut conjC. Proof. by []. Qed.

Axiom Qn_Aut_exists : forall k n, coprime k n ->
  {u | algC_Aut u & forall z, z ^+ n = 1 -> u z = z ^+ k}.

Lemma repC1 : repC 1.
Proof. by rewrite -(mulr1 1) -{2}(rmorph1 conjC) repC_pconj. Qed.

Lemma repC_inv x : repC (x^-1) = repC x.
Proof.
case: (x =P 0)=> [->|]; first by rewrite invr0.
move/eqP=> Hx; apply/idP/idP=> Hp.
  by rewrite -(repCMl _ (invr_neq0 Hx)) // mulVf // repC1.
by rewrite -(repCMl _ Hx) // mulfV // repC1.
Qed.

Lemma repC_conj x : repC x^* = repC x.
Proof.
wlog suffices: x / repC x -> repC x^*.
  by move=> IH; apply/idP/idP=> /IH; rewrite ?conjCK.
have [-> | nz_x pos_x] := eqVneq x 0; first by rewrite rmorph0.
by rewrite -(repCMl _ nz_x pos_x) repC_pconj.
Qed.

Lemma repC0 : repC 0.
Proof. by rewrite -[0](mul0r 0^*) repC_pconj. Qed.

Lemma repC_nat n : repC n%:R.
Proof.
by elim: n=> [|n IH]; [exact: repC0 | rewrite -addn1 natr_add repCD // repC1].
Qed.

Lemma conjC_nat n : (n%:R)^* = n%:R.
Proof. exact: rmorph_nat. Qed.

Lemma conjC0 : 0^* = 0.
Proof. exact: (conjC_nat 0). Qed.

Lemma conjC1 : 1^* = 1.
Proof. exact: (conjC_nat 1). Qed.

Lemma conjC_eq0 x : (x^* == 0) = (x == 0).
Proof.
apply/eqP/eqP=> H; last by rewrite H (conjC_nat 0).
by rewrite -[x]conjCK H (conjC_nat 0).
Qed.

Definition leC x y := repC (y - x).

Notation "x <= y" := (leC x y) : ring_scope.
Notation "x >= y" := (leC y x) (only parsing) : ring_scope.

Lemma leC_sub x y : (0 <= y - x) = (x <= y).
Proof. by rewrite /leC subr0. Qed.

Definition ltC x y := ((y != x) && (x <= y)).

Notation "x < y" := (ltC x y) : ring_scope.
Notation "x > y" := (ltC y x) (only parsing) : ring_scope.

Lemma ltCE x y : (x < y) = ((y != x) && (x <= y)).
Proof. by []. Qed.

(* GG: inconsistent naming and orientation (cf. leC_sub). *)
Lemma ltC_sub x y : (x < y) = (0 < y - x).
Proof. by rewrite /ltC leC_sub subr_eq0. Qed.

Lemma leC_refl : reflexive leC.
Proof. move=> x; rewrite /leC subrr; exact repC0. Qed.

Lemma ltCW x y : x < y -> x <= y.
Proof. by case/andP. Qed.

Lemma leC_add2l z x y : (z + x <= z + y) = (x <= y).
Proof. by rewrite /leC oppr_add addrA [z + _]addrC addrK. Qed.

Lemma leC_add2r z x y : (x + z <= y + z) = (x <= y).
Proof. by rewrite ![_ +z]addrC leC_add2l. Qed.

Lemma posC_add x y : 0 <= x -> 0 <= y -> 0 <= x + y.
Proof. by rewrite /leC !subr0; exact: repCD. Qed.

Lemma posC_sum I r (P : pred I) (F : I -> algC) :
  (forall i, P i -> 0 <= F i) -> 0 <= \sum_(j <- r | P j) F j.
Proof.
move=> posF; elim/big_rec: _ => [|i x Pi pos_x]; first exact: leC_refl.
by rewrite posC_add ?posF // andbC.
Qed.

Lemma leC_trans : transitive leC.
Proof.
by move=> x y z Hx Hy; move: (repCD Hy Hx); rewrite addrA subrK.
Qed.

Lemma leC_add x y z t : x <= z -> y <= t -> x + y <= z + t.
Proof. by rewrite -(leC_add2r y) -(leC_add2l z y); exact: leC_trans. Qed.

Lemma leC_opp x y : (- x <= - y) = (y <= x).
Proof. by rewrite -leC_sub opprK addrC leC_sub. Qed.

Lemma ltC_opp x y : (- x < - y) = (y < x).
Proof. by rewrite /ltC leC_opp eqr_opp eq_sym. Qed.

Lemma posC_opp x : (0 <= - x) = (x <= 0).
Proof. by rewrite -{1}oppr0 leC_opp. Qed.

Lemma sposC_opp x : (0 < - x) = (x < 0).
Proof. by rewrite -{1}oppr0 ltC_opp. Qed.

Lemma leC_anti x y : x <= y -> y <= x -> x = y.
Proof.
move=> le_xy le_yx; apply/eqP; rewrite -subr_eq0; apply/eqP.
by apply: repC_anti; rewrite // oppr_sub.
Qed.

Lemma ltC_geF x y : x < y -> (y <= x) = false.
Proof. by case/andP=> neq_yx le_xy; apply: contraNF neq_yx => /leC_anti->. Qed.

Lemma leC_gtF x y : x <= y -> (y < x) = false.
Proof. by apply: contraTF => /ltC_geF->. Qed.

Lemma leC_eqVlt x y : (x <= y) = (x == y) || (x < y).
Proof. by rewrite /ltC eq_sym ; case: eqP => // ->; exact: leC_refl. Qed.

Lemma eqC_leC x y : (x == y) = (x <= y) && (y <= x).
Proof.
by apply/eqP/andP=> [-> | [le_xy le_yx]]; [rewrite leC_refl | exact: leC_anti].
Qed.

Lemma posC_mulr x y : 0 < x -> (0 <= x * y) = (0 <= y).
Proof.
case/andP; rewrite /leC !subr0; move=>*.
by apply: repCMl; rewrite // eq_sym. 
Qed.

Lemma posC_mull x y : 0 < x -> (0 <= y * x) = (0 <= y).
Proof. rewrite mulrC; exact: posC_mulr. Qed.

Lemma posC_mul x y : 0 <= x -> 0 <= y -> 0 <= x * y.
Proof.
move=> Hx Hy.
case: (boolP (x == 0)); first by move/eqP->; rewrite mul0r leC_refl.
by move=> Hdx; rewrite posC_mulr //; apply/andP.
Qed.

Lemma sposC_mul x y : 0 < x -> 0 < y -> 0 < x * y.
Proof.
by move=> /andP[nz_x le0x] /andP[nz_y le0y]; rewrite /ltC mulf_neq0 ?posC_mul.
Qed.

Lemma posC_nat n : 0 <= n%:R.
Proof. by rewrite /leC subr0 repC_nat. Qed.

Lemma posC1 : 0 <= 1.
Proof. by rewrite /leC subr0 repC1. Qed.

Lemma posC_exp n x : 0 <= x -> 0 <= x ^+ n.
Proof.
by move=> x_ge0; elim: n => [|n IHn]; rewrite ?posC1 // exprS posC_mul.
Qed.

Lemma sposC_exp n x : 0 < x -> 0 < x ^+ n.
Proof. by case/andP=> nzx x_ge0; rewrite ltCE expf_neq0 ?posC_exp. Qed.

Lemma leq_leC m n : (m <= n)%N = (m%:R <= n%:R).
Proof.
elim: m n => [n | m IH [|n]]; first 2 last.
- by rewrite -{2}add1n natr_add -{2}[n.+1]add1n natr_add leC_add2l -IH.
- by rewrite posC_nat.
apply/esym; apply: contraFF (oner_eq0 algC) => le_m1_0.
rewrite (leC_anti posC1) // -(leC_add2l m%:R) -mulrSr addr0.
exact: leC_trans (posC_nat m).
Qed.

Lemma eqN_eqC m n : (m == n) = (m%:R == n%:R :> algC).
Proof. by rewrite eqn_leq eqC_leC !leq_leC. Qed.

Lemma neq0N_neqC n : (n != 0%N) = (n%:R != 0 :> algC).
Proof. by rewrite eqN_eqC. Qed.

Lemma ltn_ltC m n : (m < n)%N = (m%:R < n%:R).
Proof. by rewrite !ltCE -leq_leC -eqN_eqC ltn_neqAle eq_sym. Qed.

Lemma sposC1 : 0 < 1.
Proof. by rewrite -(ltn_ltC 0 1). Qed.

Lemma signC_inj : injective (fun b => (-1) ^+ b : algC).
Proof.
apply: can_inj (fun x => ~~ (0 <= x)) _ => [[]]; rewrite ?posC1 //.
by rewrite posC_opp // ltC_geF ?sposC1.
Qed.

Lemma Cchar : [char algC] =i pred0.
Proof.
by move=> p; apply/andP=> [[/prime_gt0]]; rewrite lt0n neq0N_neqC => /negP.
Qed.

Lemma ltC_add2l x y z : (x + y < x + z) = (y < z).
Proof. by rewrite ltCE leC_add2l (inj_eq (addrI x)). Qed.

Lemma ltC_add2r y x z : (x + y < z + y) = (x < z).
Proof. by rewrite ![_ + y]addrC ltC_add2l. Qed.

Lemma leC_ltC_trans y x z : x <= y -> y < z -> x < z.
Proof.
move=> le_xy /andP[neq_zy le_yz]; rewrite /ltC (leC_trans le_xy le_yz) andbT.
by apply: contraNneq neq_zy => eq_zx; rewrite eqC_leC le_yz eq_zx le_xy.
Qed.

Lemma ltC_leC_trans y x z : x < y -> y <= z -> x < z.
Proof.
move=> /andP[neq_yx le_xy] le_yz; rewrite /ltC (leC_trans le_xy le_yz) andbT.
by apply: contraNneq neq_yx => eq_zx; rewrite eqC_leC le_xy -eq_zx le_yz.
Qed.

Lemma ltC_trans y x z : x < y -> y < z -> x < z.
Proof. by case/andP => _; exact: leC_ltC_trans. Qed.

Lemma sposC_addl x y : 0 <= x -> 0 < y -> 0 < x + y.
Proof. by rewrite -(ltC_add2l x 0 y) addr0; exact: leC_ltC_trans. Qed.

Lemma sposC_addr x y : 0 < x -> 0 <= y -> 0 < x + y.
Proof. by rewrite addrC => lt0x /sposC_addl ->. Qed.

Lemma leC_mul2l x y z : 0 <= x -> y <= z -> x * y <= x * z.
Proof.
by move=> le0x le_yz; rewrite -leC_sub -mulr_subr posC_mul ?leC_sub.
Qed.

Lemma leC_mul2r x y z : 0 <= x -> y <= z -> y * x <= z * x.
Proof. by rewrite ![_ * x]mulrC; exact: leC_mul2l. Qed.

Lemma posC_inv x : (0 <= x^-1) = (0 <= x).
Proof. by rewrite /leC !subr0; exact: repC_inv. Qed.

Lemma sposC_inv x : (0 < x^-1) = (0 < x).
Proof. by rewrite !ltCE posC_inv invr_eq0. Qed.

Lemma posC_div x y : 0 <= x -> 0 <= y -> 0 <= x / y.
Proof. by move=> le0x le0y; rewrite posC_mul ?posC_inv. Qed.

Lemma sposC_div x y : 0 < x -> 0 < y -> 0 < x / y.
Proof. by move=> lt0x lt0y; rewrite sposC_mul ?sposC_inv. Qed.

Lemma leC_pmul2l x y z : 0 < x -> (x * y <= x * z) = (y <= z).
Proof.
case/andP=> nz_x le0x; apply/idP/idP; last exact: leC_mul2l.
by move/(@leC_mul2l x^-1); rewrite posC_inv !mulKf // => ->.
Qed.

Lemma leC_pmul2r x y z : 0 < x -> (y * x <= z * x) = (y <= z).
Proof. by rewrite ![_* x]mulrC; exact: leC_pmul2l. Qed.

Lemma leC_exp2r n x y :
  (n > 0)%N -> 0 <= x -> 0 <= y -> (x ^+ n <= y ^+ n) = (x <= y).
Proof.
case: n => // n _ x_ge0 y_ge0.
have [-> | nzx] := eqVneq x 0; first by rewrite exprS mul0r posC_exp.
rewrite -leC_sub subr_expn posC_mull ?leC_sub // big_ord_recr /=.
rewrite sposC_addl ?posC_sum // => [i _|]; first by rewrite posC_mul ?posC_exp.
by rewrite subnn mul1r sposC_exp // ltCE nzx.
Qed.

Lemma ltC_exp2r n x y :
  (n > 0)%N -> 0 <= x -> 0 <= y -> (x ^+ n < y ^+ n) = (x < y).
Proof. by move=> n_gt0 x_ge0 y_ge0; rewrite !ltCE !eqC_leC !leC_exp2r. Qed.

Lemma leC_expr n x y : 0 <= x -> x <= y -> x ^+ n <= y ^+ n.
Proof.
case: n => [|n] x_ge0 lexy; first exact: leC_refl.
by rewrite leC_exp2r // (leC_trans x_ge0).
Qed.

Lemma ltC_expr n x y : (n > 0)%N -> 0 <= x -> x < y -> x ^+ n < y ^+ n.
Proof.
by move=> n_gt0 x_ge0 lexy; rewrite ltC_exp2r // (leC_trans x_ge0 (ltCW _)).
Qed.

Lemma leC1exp n x : (n > 0)%N -> 0 <= x -> (1 <= x ^+ n) = (1 <= x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(exp1rn _ n) leC_exp2r ?posC1. Qed.

Lemma ltC1exp n x : (n > 0)%N -> 0 <= x -> (1 < x ^+ n) = (1 < x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(exp1rn _ n) ltC_exp2r ?posC1. Qed.

Lemma geC1exp n x : (n > 0)%N -> 0 <= x -> (1 >= x ^+ n) = (1 >= x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(exp1rn _ n) leC_exp2r ?posC1. Qed.

Lemma gtC1exp n x : (n > 0)%N -> 0 <= x -> (1 > x ^+ n) = (1 > x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(exp1rn _ n) ltC_exp2r ?posC1. Qed.

Lemma leC_square x y : 0 <= x -> x <= y -> x ^+ 2 <= y ^+ 2.
Proof. exact: leC_expr. Qed.

Lemma posC_pconj x : 0 <= x * x ^*.
Proof. by rewrite /leC subr0 repC_pconj. Qed.

Lemma posC_conj x : (0 <= x^*) = (0 <= x).
Proof. rewrite /leC !subr0; exact: repC_conj. Qed.

Lemma posC_add_eq0 x y :
  0 <= x -> 0 <= y -> (x + y == 0) = (x == 0) && (y == 0).
Proof.
rewrite leC_eqVlt eq_sym; have [-> | _ /= lt0x] := eqP; first by rewrite add0r.
by rewrite eqC_leC => /(sposC_addr lt0x)/ltC_geF->.
Qed.

Lemma posC_sum_eq0 (I : finType) (P : pred I) (F : I -> algC) :
     (forall i, P i -> 0 <= F i) -> \sum_(i | P i) F i = 0 ->
  (forall i, P i -> F i = 0).
Proof.
move=> posF sumF0 i Pi; apply: leC_anti; last exact: posF.
rewrite -sumF0 (bigD1 i Pi) /= addrC -leC_sub addrK.
by rewrite big_andbC -big_filter_cond posC_sum.
Qed.

Definition leCif x y c := ((x <= y) * ((x == y) = c))%type.

Notation "x <= y ?= 'iff' c" := (leCif x y c) : C_scope.

Coercion leC_of_leqif x y c (le_xy : x <= y ?= iff c) := le_xy.1 : x <= y.

Lemma leCifP x y c :
   reflect (x <= y ?= iff c) (if c then x == y else x < y).
Proof.
rewrite /ltC (eq_sym y); apply: (iffP idP) => [|[-> ->]]; last by case: c.
by case: c => [/eqP-> | /andP[/negPf] //]; rewrite /leCif leC_refl eqxx.
Qed.

Fact sqrtC_subproof x : exists y : algC, y ^+ 2 == x.
Proof.
have [// | y def_y2] := @solve_monicpoly algC 2 [fun i => 0 with 0%N |-> x].
by exists y; rewrite def_y2 !big_ord_recl big_ord0 /= mulr1 mul0r !addr0.
Qed.

Definition sqrtC := locked (fun x =>
  let y := xchoose (sqrtC_subproof x) in if 0 <= y then y else - y).

Lemma sqrtCK x : sqrtC x ^+ 2 = x.
Proof.
unlock sqrtC; rewrite (fun_if (fun y => y ^+ 2)) sqrrN if_same.
exact/eqP/(xchooseP (sqrtC_subproof x)).
Qed.

Lemma sqrtC_sqr c : (sqrtC (c ^+ 2) == c) || (sqrtC (c ^+ 2) == - c).
Proof. by rewrite -subr_eq0 -addr_eq0 -mulf_eq0 -subr_sqr sqrtCK subrr. Qed.

Lemma sqrtC_sqr_pos c : 0 <= c -> sqrtC (c ^+ 2) = c.
Proof.
move=> le0c; case/pred2P: (sqrtC_sqr c) => //; unlock sqrtC.
case: ifPn => le0rc def_c; move: le0rc; last by rewrite (oppr_inj def_c) le0c.
by rewrite def_c -sub0r leC_sub => /leC_anti->; rewrite ?subrr.
Qed.

Lemma sqrtC0 : sqrtC 0 = 0.
Proof. by rewrite -{1}(mulr0 0) sqrtC_sqr_pos ?leC_refl. Qed.

Lemma sqrtC_eq0 c : (sqrtC c == 0) = (c == 0).
Proof.
apply/eqP/eqP=> [|->]; last exact: sqrtC0.
by rewrite -{2}[c]sqrtCK => ->; rewrite exprS mul0r.
Qed.

Lemma sqrtC1 : sqrtC 1 = 1.
Proof. by rewrite -{2}(sqrtC_sqr_pos posC1) exp1rn. Qed. 

Definition normC x := sqrtC (x * x^*).
Notation "`| z |" := (normC z) : C_scope.

Lemma normCK x : `|x| ^+ 2 = x * x^*.
Proof. exact: sqrtCK. Qed.

Lemma sqrf_eqP (F : idomainType) (x y : F) :
  reflect (x = y \/ x = - y) (x ^+ 2 == y ^+ 2).
Proof.
by rewrite -subr_eq0 subr_sqr mulf_eq0 subr_eq0 addr_eq0; exact: pred2P.
Qed.

Fact conjCid_norm z : `|z|^* = normC z.
Proof.
set y := normC z; have /sqrf_eqP[// | def_y]: y^* ^+ 2 == y ^+ 2.
  by rewrite -rmorphX normCK rmorphM conjCK mulrC.
suffices /eqP: y ^+ 2 = 0 by rewrite expf_eq0 => /=/eqP->; rewrite rmorph0.
apply: leC_anti; last by rewrite normCK posC_pconj.
by rewrite -posC_opp -mulrN -def_y posC_pconj.
Qed.

Fact leC_real_total x : x^* = x -> x <= 0 \/ 0 <= x.
Proof.
move=> Rx; pose y := sqrtC x; apply/orP; rewrite -posC_opp.
have: (y * y^*) ^+ 2 == x ^+ 2 by rewrite exprn_mull -rmorphX sqrtCK Rx.
by case/sqrf_eqP=> <-; rewrite posC_pconj ?orbT.
Qed.

Lemma normC_opp x : `|- x| = `|x|.
Proof. by rewrite /normC rmorphN mulrN mulNr opprK. Qed.

Lemma normC_mul_sign n x : `|(-1) ^+ n * x| = `|x|.
Proof. by rewrite -signr_odd mulr_sign fun_if normC_opp if_same. Qed.

Lemma normC_nat n : `|n%:R| = n%:R.
Proof. by rewrite /normC rmorph_nat sqrtC_sqr_pos ?posC_nat. Qed.

Lemma normC0 : `|0| = 0.
Proof. exact: normC_nat 0%N. Qed.

Lemma normC1 : `|1| = 1.
Proof. exact: normC_nat 1%N. Qed.

Lemma posC_norm x : 0 <= `|x|.
Proof.
have [| //] := leC_real_total (conjCid_norm x); rewrite -leC_sub sub0r.
by unlock normC sqrtC; case: ifP; rewrite // opprK => ->.
Qed.

Lemma normC_eq0 c : (`|c| == 0) = (c == 0).
Proof. by rewrite -[_ == 0](expf_eq0 _ 2) sqrtCK mulf_eq0 conjC_eq0 orbb. Qed.

Lemma normC_mul : {morph normC: x y / x * y}.
Proof.
move=> x y; rewrite {1}/normC rmorphM mulrCA -mulrA mulrCA mulrA.
rewrite -[x * _]sqrtCK -[y * _]sqrtCK -exprn_mull sqrtC_sqr_pos //.
by rewrite posC_mul //; exact: posC_norm.
Qed.

Lemma normC_exp x n : `|x ^+ n| = `|x| ^+ n.
Proof.
elim: n => [|n IH]; first exact: normC1.
by rewrite exprS normC_mul IH exprS.
Qed.

Lemma normC_conj x : `|x^*| = `|x|.
Proof. by rewrite /normC conjCK mulrC. Qed.

Lemma normC_inv x : `|x^-1| = `|x|^-1.
Proof.
have [|nz_x] := boolP (normC x == 0).
  by rewrite normC_eq0 => /eqP->; rewrite !(normC0, invr0).
by apply: (mulIf nz_x); rewrite mulVf // -normC_mul mulVf ?normC1 // -normC_eq0.
Qed.

Lemma invC_norm x : x^-1 = `|x| ^- 2 * x^*.
Proof.
have [-> | nx_x] := eqVneq x 0; first by rewrite conjC0 mulr0 invr0.
by rewrite sqrtCK invf_mul divfK ?conjC_eq0.
Qed.

Lemma conjC_inv x : (x^-1)^* = (x^*)^-1.
Proof. exact: fmorphV. Qed.

(* This is the first use of Archimedean axiom. *)
Lemma normC_pos x : 0 <= x -> `|x| = x.
Proof.
move=> le0x; have [-> | nzx] := eqVneq x 0; first by rewrite normC0.
rewrite -{2}[x]mul1r; apply: canRL (divfK nzx) _; set y := normC x / x.
have le0y: 0 <= y by rewrite posC_mul ?posC_inv ?posC_norm.
have ley1_sym: (y <= 1) = (1 <= y).
  rewrite -leC_sub -posC_conj rmorph_sub rmorph1 leC_sub.
  have lt0y: 0 < y by rewrite ltCE mulf_eq0 invr_eq0 normC_eq0 orbb nzx.
  rewrite -(leC_pmul2l _ _ lt0y) mulr1 fmorph_div conjCid_norm mulrCA !mulrA.
  by rewrite -expr2 sqrtCK (mulrC x) mulfK // divff ?conjC_eq0.
suffices ley1: y <= 1 by rewrite (leC_anti ley1) -?ley1_sym.
rewrite /leC subr0 in le0y.
have [[/and3P[] //| n /andP[le_n1_y _]]] := realC_archimedean le0y.
by rewrite ley1_sym (leC_trans _ le_n1_y) -?(leq_leC 1).
Qed.

Lemma posC_conjK x : 0 <= x -> x^* = x.
Proof. by move/normC_pos <-; rewrite conjCid_norm. Qed.

Lemma sqrtC_pos x : (0 <= sqrtC x) = (0 <= x).
Proof.
apply/idP/idP=> [le0rx | le0x]; first by rewrite -[x]sqrtCK posC_mul.
have [-> | nzx] := eqVneq x 0; first by rewrite sqrtC0 leC_refl.
pose y := sqrtC x * (sqrtC x)^*; suffices ->: x = y by exact: posC_norm.
have: x ^+ 2 == y ^+ 2 by rewrite exprn_mull -rmorphX sqrtCK posC_conjK.
rewrite -subr_eq0 subr_sqr mulf_eq0 subr_eq0 => /predU1P[] // /idPn[].
suffices: 0 < x + y by case/andP.
by rewrite sposC_addr ?posC_pconj // ltCE nzx.
Qed.

Lemma posC_unit_exp x n : 0 <= x -> (x ^+ n.+1 == 1) = (x == 1).
Proof.
move=> le0x; apply/idP/eqP=> [|->]; last by rewrite exp1rn.
apply: contraTeq => neq_x_1.
suffices: x ^+ n.+1 < 1 \/ 1 < x ^+ n.+1.
  by move/orP; rewrite ltCE eq_sym -andb_orr => /andP[].
have{neq_x_1}: x < 1 \/ 1 < x.
  rewrite !ltCE eq_sym neq_x_1 -(leC_sub 1) -leC_sub -oppr_sub -sub0r leC_sub.
  by apply: leC_real_total; rewrite rmorph_sub rmorph1 posC_conjK.
case=> [ltx1 | lt1x]; [left | right]; elim: n => // n /ltCW IHn.
  by apply: leC_ltC_trans ltx1; rewrite -{2}[x]mulr1 leC_mul2l. 
by apply: ltC_leC_trans lt1x _; rewrite -{1}[x]mulr1 leC_mul2l. 
Qed.

Lemma normC_add x y : `|x + y| <= `|x| + `|y|.
Proof.
have [-> | ntx] := eqVneq x 0; first by rewrite normC0 !add0r leC_refl.
have [-> | nty] := eqVneq y 0; first by rewrite normC0 !addr0 leC_refl.
have /leC_pmul2r ltMxy: 0 < `|x| + `|y| + `|x + y|.
  by rewrite !sposC_addr ?ltCE ?posC_norm //= normC_eq0 ntx.
rewrite -leC_sub -{}ltMxy mul0r -subr_sqr sqrr_add !sqrtCK leC_sub rmorphD.
rewrite mulr_addl !mulr_addr addrA leC_add2r -addrA leC_add2l -normC_mul.
set z := _ + _; set p := _ *+ 2.
have le0p: 0 <= p by rewrite posC_add ?posC_norm.
have Rz: z^* = z by rewrite !(rmorphD, rmorphM) !conjCK mulrC addrC (mulrC _ x).
case/leC_real_total: Rz => [/leC_trans-> // | le0z].
have /leC_pmul2r ltMxy: 0 < p + z.
  by rewrite !sposC_addr ?ltCE ?posC_norm // normC_eq0 mulf_neq0.
rewrite -leC_sub -{}ltMxy mul0r -subr_sqr leC_sub -[p]mulr_natr exprn_mull.
rewrite -natr_exp mulr_natr sqrtCK rmorphM mulrA mulrC -mulrA mulrCA mulrA.
rewrite -subr_sqr_add_sub addrC -leC_sub addrK -mulNr oppr_sub.
rewrite -[_ - _]conjCK rmorph_sub !rmorphM !conjCK mulrC (mulrC x) (mulrC y).
exact: posC_pconj.
Qed.

Lemma normC_add_eq x y : 
    `|x + y| = `|x| + `|y| -> 
  exists2 k, `|k| = 1 & ((x == `|x| * k) && (y == `|y| * k)).
Proof.
pose s z := z / normC z; have congr_sqr := congr1 (fun z => z ^+ 2).
have norm1 z: z != 0 -> `|s z| = 1 /\ z == `|z| * s z.
  rewrite -normC_eq0 => nzz; rewrite mulrC divfK // /normC fmorph_div //.
  rewrite conjCid_norm mulrCA -mulrA -invf_mul mulrCA mulrA -expr2 -expr_inv.
  by rewrite -[z * _]sqrtCK -exprn_mull divff // exp1rn sqrtC1.
move=> def_Nxy; have [-> | ntx] := eqVneq x 0.
  have [-> | nty] := eqVneq y 0.
    by exists 1; rewrite ?normC1 // !normC0 mul0r eqxx.
  by have [? ?] := norm1 y nty; exists (s y); rewrite // normC0 mul0r eqxx.
have [ns1 def_x] := norm1 x ntx; exists (s x); rewrite ?def_x //=.
move/congr_sqr: def_Nxy; rewrite sqrr_add !sqrtCK rmorphD mulr_addl !mulr_addr.
rewrite addrA => /addIr; rewrite -addrA -normC_mul -mulr_natr => /addrI def2xy.
have eq_xy: x * y^* = y * x^*.
  apply/eqP; rewrite -subr_eq0 -normC_eq0 sqrtC_eq0 rmorph_sub !rmorphM !conjCK.
  rewrite -(mulrC x) -(mulrC y) [_ * _]mulrC -[_ - _]oppr_sub mulNr -expr2.
  move/congr_sqr/esym/eqP: def2xy; rewrite exprn_mull sqrtCK -natr_exp.
  rewrite mulr_natr rmorphM mulrA [_ * _]mulrC -mulrA mulrCA mulrA.
  by rewrite -subr_sqr_add_sub addrC -[_ == _]subr_eq0 addrK.
have{eq_xy def2xy} def_xy: y * x^* = normC (x * y).
  apply: (@mulIf _ 2%:R); first by rewrite -(eqN_eqC 2 0).
  by rewrite mulr_natr mulrS -{1}eq_xy.
apply/eqP/(@mulfI _ (normC x ^+ 2)); first by rewrite expf_eq0 normC_eq0.
rewrite {1}sqrtCK mulrAC -mulrA def_xy normC_mul mulrC -!mulrA; congr (_ * _).
by rewrite mulrCA; congr (_ * _); rewrite mulrC divfK ?normC_eq0.
Qed.

Lemma normC_sum I (r : seq I) (P : pred I) (F : I -> algC) :
   `|\sum_(i <- r | P i) F i| <= \sum_(i <- r | P i) `|F i|.
Proof.
elim/big_rec2: _ => [|i u x _ le_ux]; first by rewrite normC0 leC_refl.
by apply: (leC_trans (normC_add _ _)); rewrite leC_add2l.
Qed.

Lemma normC_sum_eq (I : finType) (P : pred I) (F : I -> algC) :
     `|\sum_(i | P i) F i| = \sum_(i | P i) `|F i| ->
   exists2 k, `|k| = 1 & forall i, P i -> F i = `|F i| * k.
Proof.
have [i /andP[Pi nzFi] | F0] := pickP [pred i | P i && (F i != 0)]; last first.
  exists 1 => [|i Pi]; first exact: normC1.
  by case/nandP: (F0 i) => [/negP[]// | /negbNE/eqP->]; rewrite normC0 mul0r.
rewrite !(bigD1 i Pi) /=; set Q := fun _ => _ : bool => norm_sumF.
rewrite -normC_eq0 in nzFi; set c := F i / `|F i|; exists c => [|j Pj].
  by rewrite normC_mul normC_inv (normC_pos (posC_norm _)) divff.
have [Qj | /nandP[/negP[]// | /negbNE/eqP->]] := boolP (Q j); last first.
  by rewrite mulrC divfK.
have: `|F i + F j| = `|F i| + `|F j|.
  do [rewrite !(bigD1 j Qj) /=; set z := \sum_(k | _) `|_|] in norm_sumF.
  apply/eqP; rewrite eqC_leC normC_add -(leC_add2r z) -addrA -norm_sumF addrA.
  by rewrite (leC_trans (normC_add _ _)) // leC_add2l normC_sum.
case/normC_add_eq=> k _ /andP[/eqP/(canLR (mulKf nzFi)) <- /eqP].
by rewrite -(mulrC (F i)).
Qed.

Lemma normC_sum_eq1 (I : finType) (P : pred I) (F : I -> algC) :
    `|\sum_(i | P i) F i| = (\sum_(i | P i) `|F i|) ->
     (forall i, P i -> `|F i| = 1) ->
   exists2 k, `|k| = 1 & forall i, P i -> F i = k.
Proof.
case/normC_sum_eq=> k k1 defF normF.
by  exists k => // i Pi; rewrite defF // normF // mul1r.
Qed.

Lemma normC_sum_upper (I : finType) (P : pred I) (F G : I -> algC) :
     (forall i, P i -> `|F i| <= G i) ->
     \sum_(i | P i) F i = \sum_(i | P i) G i ->
   forall i, P i -> F i = G i.
Proof.
set sumF := \sum_(i | _) _; set sumG := \sum_(i | _) _ => leFG eq_sumFG.
have posG i: P i -> 0 <= G i by move/leFG; apply: leC_trans; exact: posC_norm.
have norm_sumG: `|sumG| = sumG by rewrite normC_pos ?posC_sum.
have norm_sumF: `|sumF| = \sum_(i | P i) `|F i|.
  apply/eqP; rewrite eqC_leC normC_sum eq_sumFG norm_sumG -leC_sub -sumr_sub.
  by rewrite posC_sum // => i Pi; rewrite leC_sub ?leFG.
have [k _ defF] := normC_sum_eq norm_sumF.
have [/(posC_sum_eq0 posG) G0 i Pi | nz_sumG] := eqVneq sumG 0.
  by apply/eqP; rewrite G0 // -normC_eq0 eqC_leC posC_norm -(G0 i Pi) leFG.
have k1: k = 1.
  apply: (mulfI nz_sumG); rewrite mulr1 -{1}norm_sumG -eq_sumFG norm_sumF.
  by rewrite -mulr_suml -(eq_bigr _ defF).
have /posC_sum_eq0 eqFG i : P i -> 0 <= G i - F i.
  by move=> Pi; rewrite leC_sub defF // k1 mulr1 leFG.
move=> i /eqFG/(canRL (subrK _))->; rewrite ?add0r //.
by rewrite sumr_sub -/sumF eq_sumFG subrr.
Qed.

Definition getNatC x :=
  if insub x : {? c | repC c} is Some c then
    val (sigW (realC_archimedean (valP c)))
  else 0%N.

Lemma getNatC_def x (n := getNatC x) :
  if 0 <= x then (n%:R <= x) && (x < (n + 1)%:R) else n == 0%N.
Proof.
rewrite {}/n /getNatC /ltC /leC subr0 addn1 eq_sym (andbC (~~ _)).
case: ifPn => [le0x | not_le0x]; last by rewrite insubN.
by rewrite insubT //=; case: (sigW _).
Qed.

Lemma getNatC_nat n : getNatC (n%:R) = n.
Proof.
have:= getNatC_def n%:R; rewrite /= posC_nat -leq_leC -ltn_ltC.
case/andP=> H1 H2; apply: anti_leq => //.
by rewrite H1 // -ltnS -[(getNatC _).+1]addn1.
Qed.

Definition isNatC c := c == (getNatC c)%:R.

Lemma isNatCP c : reflect (exists n, c = n%:R) (isNatC c).
Proof.
apply: (iffP idP)=> [H | [n H]]; first by exists (getNatC c); apply/eqP.
by rewrite H /isNatC getNatC_nat.
Qed.

Lemma isNatC_nat n : isNatC (n%:R).
Proof. by apply/isNatCP; exists n. Qed.
Lemma isNatC_0 : isNatC 0. Proof. exact: (isNatC_nat 0). Qed.
Lemma isNatC_1 : isNatC 1. Proof. exact: (isNatC_nat 1). Qed.
Hint Resolve isNatC_0 isNatC_1.

Lemma isNatC_add c1 c2 : isNatC c1 -> isNatC c2 -> isNatC (c1 + c2).
Proof.
by case/isNatCP=> n1 ->; case/isNatCP=> n2 ->; rewrite -natr_add isNatC_nat.
Qed.

Lemma isNatC_mul c1 c2 : isNatC c1 -> isNatC c2 -> isNatC (c1 * c2).
Proof.
by case/isNatCP=> n1 ->; case/isNatCP=> n2 ->; rewrite -natr_mul isNatC_nat.
Qed.

Lemma isNatC_exp x n : isNatC x -> isNatC (x ^+ n).
Proof. by move=> Nx; elim: n => // n IHn; rewrite exprS isNatC_mul. Qed.

Lemma isNatC_sum (I : Type) (r : seq I) (P : pred I) (F : I -> algC) :
   (forall i, P i -> isNatC (F i)) -> isNatC (\sum_(j <- r | P j) F j).
Proof. by move=> H; apply big_ind=> //; exact: isNatC_add. Qed.

Lemma isNatC_muln x n : isNatC x -> isNatC (x *+ n).
Proof. by elim: n => // n IH Hx; rewrite mulrSr isNatC_add // IH. Qed.

Lemma posC_Nat c : isNatC c -> 0 <= c.
Proof. by case/isNatCP=> n ->; exact: posC_nat. Qed.

Lemma isNatC_conj c : isNatC c -> c^* = c.
Proof. by case/isNatCP=> n ->; exact: conjC_nat. Qed.

Lemma isNatC_sum_eq1 (I : finType) (P : pred I) (F : I -> algC) :
     (forall i, P i -> isNatC (F i)) -> \sum_(i | P i) F i = 1 ->
   {i : I | [/\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]}.
Proof.
move=> natF sumF1; pose nF i := getNatC (F i).
have{natF} defF i: P i -> F i = (nF i)%:R by move/natF/eqP.
have{sumF1} /eqP sumF1: (\sum_(i | P i) nF i == 1)%N.
  by rewrite eqN_eqC natr_sum -(eq_bigr _ defF) sumF1.
have [i Pi nZfi]: {i : I | P i & nF i != 0%N}.
  by apply/sig2W/exists_inP; rewrite -negb_forall_in -sum_nat_eq0 sumF1.
have F'ge0 := (leq0n _, etrans (eq_sym _ _) (sum_nat_eq0 (predD1 P i) nF)).
rewrite -lt0n in nZfi; have [_] := (leqif_add (leqif_eq nZfi) (F'ge0 _)).
rewrite /= big_andbC -bigD1 // sumF1 => /esym/andP/=[/eqP Fi1 /forall_inP Fi'0].
exists i; split=> // [|j neq_ji Pj]; first by rewrite defF // -Fi1.
by rewrite defF // (eqP (Fi'0 j _)) // neq_ji.
Qed.

(* Real algebraics. *)
Definition isRealC x := (x^* == x).

Lemma realC_leP x : reflect (x <= 0 \/ 0 <= x) (isRealC x).
Proof.
apply: (iffP eqP); first exact: leC_real_total.
by rewrite -posC_opp => [[]] /posC_conjK //; rewrite rmorphN => /oppr_inj.
Qed.

Lemma real_normCK x : isRealC x -> `|x| ^+ 2 = x ^+ 2.
Proof. by rewrite normCK => /eqP->. Qed.

Lemma real_signE x : isRealC x -> x = (-1) ^+ (x < 0)%C * `|x|.
Proof.
rewrite mulr_sign; case/realC_leP=> [ge0x | le0x]; last first.
  by rewrite normC_pos ?leC_gtF.
rewrite ltCE ge0x andbT -normC_opp normC_pos ?opprK ?posC_opp //.
by case: eqP => // <-; rewrite oppr0.
Qed.

Lemma realC_ltNge x y : isRealC x -> isRealC y -> (x < y) = ~~ (x >= y).
Proof.
move=> r_x r_y; rewrite ltCE eqC_leC negb_and andb_orl andNb orbF andb_idr //.
apply/implyP; rewrite implybE negbK -leC_sub orbC -leC_sub -oppr_sub posC_opp.
by rewrite (sameP orP (realC_leP _)) /isRealC rmorph_sub (eqP r_x) (eqP r_y).
Qed.

Lemma realC_leNgt x y : isRealC x -> isRealC y -> (x <= y) = ~~ (x > y).
Proof. by move=> r_x r_y; rewrite realC_ltNge ?negbK. Qed.

(* We mimic Z by a sign and a natural number *)
Definition getIntC x :=
  if 0 <= x then (false, getNatC x) else (true, getNatC (- x)).

Definition isIntC x := x == (let: (b, n) := getIntC x in (-1) ^+ b * n%:R).

Lemma isIntCP x : isIntC x -> {e : bool & {n | x = (-1) ^+ e * n%:R}}.
Proof. by move/(x =P _); case: (getIntC x) => e n; exists e, n. Qed.

Lemma isIntCE x : isIntC x = isNatC x || isNatC (- x).
Proof.
apply/idP/idP=> [/isIntCP[b [n ->]] | ].
  by rewrite mulr_sign; case: b; rewrite ?opprK ?isNatC_nat ?orbT.
rewrite /isIntC /getIntC => /orP[] /isNatCP[n def_x].
  by rewrite def_x posC_nat mul1r getNatC_nat.
rewrite -{-4}[x]opprK {x}def_x getNatC_nat posC_opp -(leq_leC n 0).
by case: n => [|n]; rewrite /= ?mulN1r // mul1r oppr0 (getNatC_nat 0).
Qed.

Lemma isIntC_Nat x : isNatC x -> isIntC x.
Proof. by rewrite isIntCE => ->. Qed.

Lemma isIntC_nat n : isIntC (n%:R).
Proof. by rewrite isIntCE isNatC_nat. Qed.
Lemma isIntC_0 : isIntC 0. Proof. exact: (isIntC_nat 0). Qed.
Lemma isIntC_1 : isIntC 1. Proof. exact: (isIntC_nat 1). Qed.
Hint Resolve isIntC_0 isIntC_1.

Lemma isIntC_opp x : isIntC (- x) = isIntC x.
Proof. by rewrite !isIntCE opprK orbC. Qed.

Lemma isIntC_mul_sign n x : isIntC ((-1) ^+ n * x) = isIntC x.
Proof. by rewrite -signr_odd mulr_sign fun_if isIntC_opp if_same. Qed.

Lemma isIntC_sign n : isIntC ((-1) ^+ n).
Proof. by rewrite -[_ ^+ _]mulr1 isIntC_mul_sign (isIntC_nat 1). Qed.

Lemma isIntC_add x y : isIntC x -> isIntC y -> isIntC (x + y).
Proof.
move=> /isIntCP[e [m ->]] /isIntCP[b [n ->]].
without loss le_nm: e b m n / (n <= m)%N.
  by move=> IH; case/orP: (leq_total n m) => /IH //; rewrite addrC.
rewrite -(addKb e b) signr_addb -mulrA -mulr_addr isIntC_mul_sign mulr_sign.
by case: ifP => _; rewrite -(natr_add, natr_sub) // isIntC_nat.
Qed.

Lemma isIntC_sub x y : isIntC x -> isIntC y -> isIntC (x - y).
Proof. by move=> Zx Zy; rewrite isIntC_add ?isIntC_opp. Qed.

Lemma isIntC_mul x y : isIntC x -> isIntC y -> isIntC (x * y).
Proof.
move=> /isIntCP[e [m ->]] /isIntCP[b [n ->]].
by rewrite -mulrA isIntC_mul_sign mulrCA isIntC_mul_sign -natr_mul isIntC_nat.
Qed.

Lemma isIntC_exp x n : isIntC x -> isIntC (x ^+ n).
Proof. by move=> Zx; elim: n => // n IHn; rewrite exprS isIntC_mul. Qed.

Lemma isIntC_sum (I : Type) (r : seq I) (P : pred I) (F : I -> algC) :
   (forall i, P i -> isIntC (F i)) -> isIntC (\sum_(j <- r | P j) F j).
Proof. by move=> Z_F; apply big_ind=> //; exact: isIntC_add. Qed.

Lemma isIntC_conj c : isIntC c -> c^* = c.
Proof. by case/isIntCP=> b [n ->]; rewrite rmorphM rmorph_sign rmorph_nat. Qed.

Lemma isIntC_Real x : isIntC x -> isRealC x.
Proof. by move/isIntC_conj/eqP. Qed.

Lemma int_normCK x : isIntC x -> `|x| ^+ 2 = x ^+ 2.
Proof. by move/isIntC_Real/real_normCK. Qed.

Lemma isIntC_signE x : isIntC x -> x = (-1) ^+ (x < 0)%C * `|x|.
Proof. by move/isIntC_Real/real_signE. Qed.

Lemma normIntC_Nat x : isIntC x -> isNatC `|x|.
Proof.
by case/isIntCP=> b [n ->]; rewrite normC_mul_sign normC_nat isNatC_nat.
Qed.

Lemma isIntC_pos x : 0 <= x -> isIntC x = isNatC x.
Proof. by rewrite /isIntC /getIntC => ->; rewrite mul1r. Qed.

Lemma isNatC_posInt x : isNatC x = isIntC x && (0 <= x).
Proof.
by rewrite -(andb_idr (@posC_Nat x)); apply: andb_id2r => /isIntC_pos.
Qed.

Lemma isNatC_exp_even x n : ~~ odd n -> isIntC x -> isNatC (x ^+ n).
Proof.
rewrite -dvdn2 => /dvdnP[m ->] Zx; rewrite isNatC_posInt isIntC_exp //.
by rewrite exprn_mulr -int_normCK ?isIntC_exp // posC_exp ?posC_norm.
Qed.

Lemma isIntC_normC_ge1 x : isIntC x -> x != 0 -> 1 <= `|x|.
Proof.
rewrite -normC_eq0; case/normIntC_Nat/isNatCP=> n ->.
by rewrite -neq0N_neqC -lt0n leq_leC.
Qed.

Lemma isIntC_expr2_ge1 x : isIntC x -> x != 0 -> 1 <= x ^+ 2.
Proof.
by move=> Zx nz_x; rewrite -int_normCK // leC1exp ?posC_norm ?isIntC_normC_ge1.
Qed.

Definition dvdC x y := if x == 0 then y == 0 else isIntC (y / x).
Notation dvdNC n y := (dvdC n%:R y).

Lemma dvdCP x y : reflect (exists2 z, isIntC z & y = z * x) (dvdC x y).
Proof.
rewrite /dvdC; have [-> | nz_x] := altP eqP.
  by apply: (iffP eqP) => [-> | [z _ ->]]; first exists 0; rewrite ?mulr0.
apply: (iffP idP) => [Zxp | [z Zz ->]]; last by rewrite mulfK.
by exists (y / x); rewrite ?divfK.
Qed.

Lemma dvdCP_nat x y : 0 <= x -> 0 <= y -> dvdC x y -> {n | y = n%:R * x}.
Proof.
move=> x_ge0 y_ge0 x_dv_y; apply: sig_eqW.
case/dvdCP: x_dv_y => z Zz -> in y_ge0 *; move: x_ge0 y_ge0 Zz.
rewrite leC_eqVlt => /predU1P[<- | ]; first by exists 22; rewrite !mulr0.
by move=> /posC_mull-> /isIntC_pos-> /isNatCP[n ->]; exists n.
Qed.

Lemma dvdC0 x : dvdC x 0.
Proof. by rewrite /dvdC mul0r isIntC_0 eqxx if_same. Qed.

Lemma dvd0C x : dvdC 0 x = (x == 0).
Proof. by rewrite /dvdC eqxx. Qed.

Lemma dvdC_opp x y : dvdC x (- y) = dvdC x y.
Proof. by rewrite /dvdC mulNr isIntC_opp oppr_eq0. Qed.

Lemma dvdC_mulrn p x : isIntC x -> dvdNC p (x *+ p).
Proof. by move=> Zx; apply/dvdCP; exists x; rewrite ?mulr_natr ?IsIntC_nat. Qed.

Lemma dvdC_mul_sign x e y : dvdC x ((-1) ^+ e * y) = dvdC x y.
Proof. by rewrite -signr_odd mulr_sign fun_if dvdC_opp if_same. Qed.

Lemma dvdC_nat p n : dvdNC p (n%:R) = (p %| n).
Proof.
rewrite /dvdC isIntC_pos ?posC_div ?posC_nat // -(eqN_eqC n 0) -dvd0n.
have [|nz_p] := ifPn; first by rewrite -(eqN_eqC p 0) => /eqP->.
apply/isNatCP/dvdnP=> [[q def_q] | [q ->]]; exists q.
  by apply/eqP; rewrite eqN_eqC natr_mul -def_q divfK. 
by rewrite natr_mul mulfK.
Qed.

Lemma dvdC_int p x : isIntC x -> dvdNC p x = (p %| getNatC `|x|).
Proof.
case/isIntCP=> e [n ->{x}]; rewrite dvdC_mul_sign {e}normC_mul_sign.
by rewrite normC_nat getNatC_nat dvdC_nat.
Qed.

Lemma dvdC_add x y z : dvdC x y -> dvdC x z -> dvdC x (y + z).
Proof.
rewrite /dvdC; case: ifP => [_ /eqP-> | _ p_x p_y]; first by rewrite add0r.
by rewrite mulr_addl isIntC_add.
Qed.

Lemma dvdC_addl x y z : dvdC x y -> dvdC x (y + z) = dvdC x z.
Proof.
move=> x_dv_y; apply/idP/idP; last exact: dvdC_add.
by rewrite -{2}(addKr y z); apply: dvdC_add; rewrite dvdC_opp.
Qed.

Lemma dvdC_mull x y z : isIntC y -> dvdC x z -> dvdC x (y * z).
Proof.
move=> Zy /dvdCP[m Zm ->]; apply/dvdCP.
by exists (y * m); rewrite ?mulrA ?isIntC_mul.
Qed.

Lemma dvdC_mulr x y z : isIntC y -> dvdC x z -> dvdC x (z * y).
Proof. by rewrite mulrC; exact: dvdC_mull. Qed.

Lemma dvdC_trans x y z : dvdC x y -> dvdC y z -> dvdC x z.
Proof. by move=> x_dv_y /dvdCP[m Zm ->]; exact: dvdC_mull. Qed.

Lemma dvdC_refl x : dvdC x x.
Proof. by apply/dvdCP; exists 1; rewrite ?mul1r. Qed.
Hint Resolve dvdC_refl.

Section AutC.

Variable u : {rmorphism algC -> algC}.

Lemma rmorph_NatC z : isNatC z -> u z = z.
Proof. by case/isNatCP=> n ->; exact: rmorph_nat. Qed.

Lemma rmorph_IntC z : isIntC z -> u z = z.
Proof.
by rewrite isIntCE => /orP[]/rmorph_NatC //; rewrite rmorphN => /oppr_inj.
Qed.

End AutC.

Section AutLmodC.

Variables (U V : lmodType algC) (f : {additive U -> V}).

Lemma raddfZ_NatC a u : isNatC a -> f (a *: u) = a *: f u. 
Proof. by case/isNatCP=> n ->; exact: raddfZnat. Qed.

Lemma raddfZ_IntC a u : isIntC a -> f (a *: u) = a *: f u. 
Proof.
by move/eqP->; case: (getIntC a) => e n; rewrite -!scalerA raddfZsign raddfZnat.
Qed.

End AutLmodC.
