(* (c) Copyright Microsoft Corporation and Inria. All rights reserved. *)
Require Import ssreflect ssrbool ssrfun ssrnat eqtype seq choice div fintype.
Require Import bigop finset prime ssralg poly polydiv ssrint rat.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import GRing.Theory.
Local Open Scope ring_scope.

(******************************************************************************)
(* This file provides a temporary partial axiomatic presentation of the       *)
(* algebraic numbers.                                                         *)
(*       algC == the closed field of algebraic numbers.                       *)
(*        z^* == the complex conjugate of z.                                  *)
(*     0 <= x <=> x is a nonnegative real.                                    *)
(*     x <= y <=> (y - x) is a nonnegative real                               *)
(*      x < y <=> (y - x) is a (strictly) positive real                       *)
(*    sqrtC z == a nonnegative square root of z, i.e., 0 <= sqrt x if 0 <= x. *)
(*       `|z| == the complex norm of z, i.e., sqrtC (z * z^* ).               *)
(*  isNatC z <=> z is a natural number.                                       *)
(*  getNatC x == the n such that x = n%:R if isNatC x, else 0.                *)
(*  isRealC x == x is a real number, i.e., x^* == x.                          *)
(*     isIntC x == x is an integer.                                           *)
(*    getIntC x == a pair (n, b) such that x = (-1) ^+ b * n%:R, if isIntC x. *)
(*     dvdC x y == x divides y, i.e., y = z * x for some integer z.           *)
(******************************************************************************)

Parameter algC : closedFieldType.
Parameter conjC : {rmorphism algC -> algC}.
Parameter repC : algC -> bool. (* C -> R^+ *)
(* Against all logic, Implicit Types declarations are Local. *)
Implicit Types (x y z : algC) (m n : nat) (b : bool).

Notation "x ^*" := (conjC x) (at level 2, format "x ^*") : C_scope.
Open Scope C_scope.
Delimit Scope C_scope with C.

Axiom conjCK : involutive conjC.
Axiom repCD : forall x y, repC x -> repC y -> repC (x + y).
Axiom repCMl : forall x y, x != 0 -> repC x -> repC (x * y) = repC y.
Axiom repC_anti : forall x, repC x -> repC (- x) -> x = 0.
(* Note: the two axioms below can be replaced by real trichotomy. *)
Axiom repC_pconj : forall x, repC (x * x ^*).
Axiom realC_archimedean : forall x, repC x ->
  exists n, [&& repC (x - n%:R), repC (n.+1%:R - x) & x != n.+1%:R].
Axiom algC_algebraic : forall x, exists2 p, p != 0 & root (map_poly intr p) x.

(* Note and caveat: Q-automorphisms of algC do not necessarily commute with   *)
(* conjugation. However, they necessarily do so on the subfield of algC       *)
(* generated by roots of unity, hence on all character values. We should      *)
(* therefore always ensure we only consider dot products of automorphisms of  *)
(* character on (virtual) characters.                                         *)
(*  Further note: by a theorem of Brauer, all non-modular representation      *)
(* theory can be done in the subfield generated by all nth roots of unity; on *)
(* this subfield commutation would be automatic. However, it would be rather  *)
(* inconvenient to work with because we would not be abe to use the complex   *)
(* norm du tp the lack of square roots. Unfortunately adding square roots     *)
(* implies that an automorphism that commutes conjugation must preserve the   *)
(* order on real algebraics, hence be trivial.                                *)

Lemma repC1 : repC 1.
Proof. by rewrite -(mulr1 1) -{2}(rmorph1 conjC) repC_pconj. Qed.

Lemma repC_inv x : repC (x^-1) = repC x.
Proof.
case: (x =P 0)=> [->|]; first by rewrite invr0.
move/eqP=> Hx; apply/idP/idP=> Hp.
  by rewrite -(repCMl _ (invr_neq0 Hx)) // mulVf // repC1.
by rewrite -(repCMl _ Hx) // mulfV // repC1.
Qed.

Lemma repC_conj x : repC x^* = repC x.
Proof.
wlog suffices: x / repC x -> repC x^*.
  by move=> IH; apply/idP/idP=> /IH; rewrite ?conjCK.
have [-> | nz_x pos_x] := eqVneq x 0; first by rewrite rmorph0.
by rewrite -(repCMl _ nz_x pos_x) repC_pconj.
Qed.

Lemma repC0 : repC 0.
Proof. by rewrite -[0](mul0r 0^*) repC_pconj. Qed.

Lemma repC_nat n : repC n%:R.
Proof.
by elim: n=> [|n IH]; [exact: repC0 | rewrite -addn1 natrD repCD // repC1].
Qed.

Lemma conjC_nat n : (n%:R)^* = n%:R.
Proof. exact: rmorph_nat. Qed.

Lemma conjC0 : 0^* = 0.
Proof. exact: (conjC_nat 0). Qed.

Lemma conjC1 : 1^* = 1.
Proof. exact: (conjC_nat 1). Qed.

Lemma conjC_eq0 x : (x^* == 0) = (x == 0).
Proof.
apply/eqP/eqP=> H; last by rewrite H (conjC_nat 0).
by rewrite -[x]conjCK H (conjC_nat 0).
Qed.

Definition leC x y := repC (y - x).

Notation "x <= y" := (leC x y) : ring_scope.
Notation "x >= y" := (leC y x) (only parsing) : ring_scope.

Lemma leC_sub x y : (0 <= y - x) = (x <= y).
Proof. by rewrite /leC subr0. Qed.

Definition ltC x y := ((y != x) && (x <= y)).

Notation "x < y" := (ltC x y) : ring_scope.
Notation "x > y" := (ltC y x) (only parsing) : ring_scope.

Lemma ltCE x y : (x < y) = ((y != x) && (x <= y)).
Proof. by []. Qed.

(* GG: inconsistent naming and orientation (cf. leC_sub). *)
Lemma ltC_sub x y : (x < y) = (0 < y - x).
Proof. by rewrite /ltC leC_sub subr_eq0. Qed.

Lemma leC_refl : reflexive leC.
Proof. move=> x; rewrite /leC subrr; exact repC0. Qed.

Lemma ltCW x y : x < y -> x <= y.
Proof. by case/andP. Qed.

Lemma leC_add2l z x y : (z + x <= z + y) = (x <= y).
Proof. by rewrite /leC opprD addrA [z + _]addrC addrK. Qed.

Lemma leC_add2r z x y : (x + z <= y + z) = (x <= y).
Proof. by rewrite ![_ +z]addrC leC_add2l. Qed.

Lemma posC_add x y : 0 <= x -> 0 <= y -> 0 <= x + y.
Proof. by rewrite /leC !subr0; exact: repCD. Qed.

Lemma posC_sum I r (P : pred I) (F : I -> algC) :
  (forall i, P i -> 0 <= F i) -> 0 <= \sum_(j <- r | P j) F j.
Proof.
move=> posF; elim/big_rec: _ => [|i x Pi pos_x]; first exact: leC_refl.
by rewrite posC_add ?posF // andbC.
Qed.

Lemma leC_trans : transitive leC.
Proof.
by move=> x y z Hx Hy; move: (repCD Hy Hx); rewrite addrA subrK.
Qed.

Lemma leC_add x y z t : x <= z -> y <= t -> x + y <= z + t.
Proof. by rewrite -(leC_add2r y) -(leC_add2l z y); exact: leC_trans. Qed.

Lemma leC_opp x y : (- x <= - y) = (y <= x).
Proof. by rewrite -leC_sub opprK addrC leC_sub. Qed.

Lemma ltC_opp x y : (- x < - y) = (y < x).
Proof. by rewrite /ltC leC_opp eqr_opp eq_sym. Qed.

Lemma posC_opp x : (0 <= - x) = (x <= 0).
Proof. by rewrite -{1}oppr0 leC_opp. Qed.

Lemma sposC_opp x : (0 < - x) = (x < 0).
Proof. by rewrite -{1}oppr0 ltC_opp. Qed.

Lemma leC_anti x y : x <= y -> y <= x -> x = y.
Proof.
move=> le_xy le_yx; apply/eqP; rewrite -subr_eq0; apply/eqP.
by apply: repC_anti; rewrite // opprB.
Qed.

Lemma ltC_geF x y : x < y -> (y <= x) = false.
Proof. by case/andP=> neq_yx le_xy; apply: contraNF neq_yx => /leC_anti->. Qed.

Lemma leC_gtF x y : x <= y -> (y < x) = false.
Proof. by apply: contraTF => /ltC_geF->. Qed.

Lemma leC_eqVlt x y : (x <= y) = (x == y) || (x < y).
Proof. by rewrite /ltC eq_sym ; case: eqP => // ->; exact: leC_refl. Qed.

Lemma eqC_leC x y : (x == y) = (x <= y) && (y <= x).
Proof.
by apply/eqP/andP=> [-> | [le_xy le_yx]]; [rewrite leC_refl | exact: leC_anti].
Qed.

Lemma posC_mulr x y : 0 < x -> (0 <= x * y) = (0 <= y).
Proof.
case/andP; rewrite /leC !subr0; move=>*.
by apply: repCMl; rewrite // eq_sym. 
Qed.

Lemma posC_mull x y : 0 < x -> (0 <= y * x) = (0 <= y).
Proof. rewrite mulrC; exact: posC_mulr. Qed.

Lemma posC_mul x y : 0 <= x -> 0 <= y -> 0 <= x * y.
Proof.
move=> Hx Hy.
case: (boolP (x == 0)); first by move/eqP->; rewrite mul0r leC_refl.
by move=> Hdx; rewrite posC_mulr //; apply/andP.
Qed.

Lemma sposC_mul x y : 0 < x -> 0 < y -> 0 < x * y.
Proof.
by move=> /andP[nz_x le0x] /andP[nz_y le0y]; rewrite /ltC mulf_neq0 ?posC_mul.
Qed.

Lemma posC_nat n : 0 <= n%:R.
Proof. by rewrite /leC subr0 repC_nat. Qed.

Lemma posC1 : 0 <= 1.
Proof. by rewrite /leC subr0 repC1. Qed.

Lemma posC_exp n x : 0 <= x -> 0 <= x ^+ n.
Proof.
by move=> x_ge0; elim: n => [|n IHn]; rewrite ?posC1 // exprS posC_mul.
Qed.

Lemma sposC_exp n x : 0 < x -> 0 < x ^+ n.
Proof. by case/andP=> nzx x_ge0; rewrite ltCE expf_neq0 ?posC_exp. Qed.

Lemma leq_leC m n : (m <= n)%N = (m%:R <= n%:R).
Proof.
elim: m n => [n | m IH [|n]]; first 2 last.
- by rewrite -{2}add1n natrD -{2}[n.+1]add1n natrD leC_add2l -IH.
- by rewrite posC_nat.
apply/esym; apply: contraFF (oner_eq0 algC) => le_m1_0.
rewrite (leC_anti posC1) // -(leC_add2l m%:R) -mulrSr addr0.
exact: leC_trans (posC_nat m).
Qed.

Lemma eqN_eqC m n : (m == n) = (m%:R == n%:R :> algC).
Proof. by rewrite eqn_leq eqC_leC !leq_leC. Qed.

Lemma neq0N_neqC n : (n != 0%N) = (n%:R != 0 :> algC).
Proof. by rewrite eqN_eqC. Qed.

Lemma ltn_ltC m n : (m < n)%N = (m%:R < n%:R).
Proof. by rewrite !ltCE -leq_leC -eqN_eqC ltn_neqAle eq_sym. Qed.

Lemma sposC1 : 0 < 1.
Proof. by rewrite -(ltn_ltC 0 1). Qed.

Lemma signC_inj : injective (fun b => (-1) ^+ b : algC).
Proof.
apply: can_inj (fun x => ~~ (0 <= x)) _ => [[]]; rewrite ?posC1 //.
by rewrite posC_opp // ltC_geF ?sposC1.
Qed.

Lemma Cchar : [char algC] =i pred0.
Proof.
by move=> p; apply/andP=> [[/prime_gt0]]; rewrite lt0n neq0N_neqC => /negP.
Qed.

Lemma ltC_add2l x y z : (x + y < x + z) = (y < z).
Proof. by rewrite ltCE leC_add2l (inj_eq (addrI x)). Qed.

Lemma ltC_add2r y x z : (x + y < z + y) = (x < z).
Proof. by rewrite ![_ + y]addrC ltC_add2l. Qed.

Lemma leC_ltC_trans y x z : x <= y -> y < z -> x < z.
Proof.
move=> le_xy /andP[neq_zy le_yz]; rewrite /ltC (leC_trans le_xy le_yz) andbT.
by apply: contraNneq neq_zy => eq_zx; rewrite eqC_leC le_yz eq_zx le_xy.
Qed.

Lemma ltC_leC_trans y x z : x < y -> y <= z -> x < z.
Proof.
move=> /andP[neq_yx le_xy] le_yz; rewrite /ltC (leC_trans le_xy le_yz) andbT.
by apply: contraNneq neq_yx => eq_zx; rewrite eqC_leC le_xy -eq_zx le_yz.
Qed.

Lemma ltC_trans y x z : x < y -> y < z -> x < z.
Proof. by case/andP => _; exact: leC_ltC_trans. Qed.

Lemma sposC_addl x y : 0 <= x -> 0 < y -> 0 < x + y.
Proof. by rewrite -(ltC_add2l x 0 y) addr0; exact: leC_ltC_trans. Qed.

Lemma sposC_addr x y : 0 < x -> 0 <= y -> 0 < x + y.
Proof. by rewrite addrC => lt0x /sposC_addl ->. Qed.

Lemma leC_mul2l x y z : 0 <= x -> y <= z -> x * y <= x * z.
Proof.
by move=> le0x le_yz; rewrite -leC_sub -mulrBr posC_mul ?leC_sub.
Qed.

Lemma leC_mul2r x y z : 0 <= x -> y <= z -> y * x <= z * x.
Proof. by rewrite ![_ * x]mulrC; exact: leC_mul2l. Qed.

Lemma posC_inv x : (0 <= x^-1) = (0 <= x).
Proof. by rewrite /leC !subr0; exact: repC_inv. Qed.

Lemma sposC_inv x : (0 < x^-1) = (0 < x).
Proof. by rewrite !ltCE posC_inv invr_eq0. Qed.

Lemma posC_div x y : 0 <= x -> 0 <= y -> 0 <= x / y.
Proof. by move=> le0x le0y; rewrite posC_mul ?posC_inv. Qed.

Lemma sposC_div x y : 0 < x -> 0 < y -> 0 < x / y.
Proof. by move=> lt0x lt0y; rewrite sposC_mul ?sposC_inv. Qed.

Lemma leC_pmul2l x y z : 0 < x -> (x * y <= x * z) = (y <= z).
Proof.
case/andP=> nz_x le0x; apply/idP/idP; last exact: leC_mul2l.
by move/(@leC_mul2l x^-1); rewrite posC_inv !mulKf // => ->.
Qed.

Lemma leC_pmul2r x y z : 0 < x -> (y * x <= z * x) = (y <= z).
Proof. by rewrite ![_* x]mulrC; exact: leC_pmul2l. Qed.

Lemma leC_exp2r n x y :
  (n > 0)%N -> 0 <= x -> 0 <= y -> (x ^+ n <= y ^+ n) = (x <= y).
Proof.
case: n => // n _ x_ge0 y_ge0.
have [-> | nzx] := eqVneq x 0; first by rewrite exprS mul0r posC_exp.
rewrite -leC_sub subrXX posC_mull ?leC_sub // big_ord_recr /=.
rewrite sposC_addl ?posC_sum // => [i _|]; first by rewrite posC_mul ?posC_exp.
by rewrite subnn mul1r sposC_exp // ltCE nzx.
Qed.

Lemma ltC_exp2r n x y :
  (n > 0)%N -> 0 <= x -> 0 <= y -> (x ^+ n < y ^+ n) = (x < y).
Proof. by move=> n_gt0 x_ge0 y_ge0; rewrite !ltCE !eqC_leC !leC_exp2r. Qed.

Lemma leC_expr n x y : 0 <= x -> x <= y -> x ^+ n <= y ^+ n.
Proof.
case: n => [|n] x_ge0 lexy; first exact: leC_refl.
by rewrite leC_exp2r // (leC_trans x_ge0).
Qed.

Lemma ltC_expr n x y : (n > 0)%N -> 0 <= x -> x < y -> x ^+ n < y ^+ n.
Proof.
by move=> n_gt0 x_ge0 lexy; rewrite ltC_exp2r // (leC_trans x_ge0 (ltCW _)).
Qed.

Lemma leC1exp n x : (n > 0)%N -> 0 <= x -> (1 <= x ^+ n) = (1 <= x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(expr1n _ n) leC_exp2r ?posC1. Qed.

Lemma ltC1exp n x : (n > 0)%N -> 0 <= x -> (1 < x ^+ n) = (1 < x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(expr1n _ n) ltC_exp2r ?posC1. Qed.

Lemma geC1exp n x : (n > 0)%N -> 0 <= x -> (1 >= x ^+ n) = (1 >= x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(expr1n _ n) leC_exp2r ?posC1. Qed.

Lemma gtC1exp n x : (n > 0)%N -> 0 <= x -> (1 > x ^+ n) = (1 > x).
Proof. by move=> n_gt0 x_ge0; rewrite -{1}(expr1n _ n) ltC_exp2r ?posC1. Qed.

Lemma leC_square x y : 0 <= x -> x <= y -> x ^+ 2 <= y ^+ 2.
Proof. exact: leC_expr. Qed.

Lemma posC_pconj x : 0 <= x * x ^*.
Proof. by rewrite /leC subr0 repC_pconj. Qed.

Lemma posC_conj x : (0 <= x^*) = (0 <= x).
Proof. rewrite /leC !subr0; exact: repC_conj. Qed.

Lemma posC_add_eq0 x y :
  0 <= x -> 0 <= y -> (x + y == 0) = (x == 0) && (y == 0).
Proof.
rewrite leC_eqVlt eq_sym; have [-> | _ /= lt0x] := eqP; first by rewrite add0r.
by rewrite eqC_leC => /(sposC_addr lt0x)/ltC_geF->.
Qed.

Lemma posC_sum_eq0 (I : finType) (P : pred I) (F : I -> algC) :
     (forall i, P i -> 0 <= F i) -> \sum_(i | P i) F i = 0 ->
  (forall i, P i -> F i = 0).
Proof.
move=> posF sumF0 i Pi; apply: leC_anti; last exact: posF.
rewrite -sumF0 (bigD1 i Pi) /= addrC -leC_sub addrK.
by rewrite big_andbC -big_filter_cond posC_sum.
Qed.

Definition leCif x y c := ((x <= y) * ((x == y) = c))%type.

Notation "x <= y ?= 'iff' c" := (leCif x y c) : C_scope.

Coercion leC_of_leqif x y c (le_xy : x <= y ?= iff c) := le_xy.1 : x <= y.

Lemma leCifP x y c :
   reflect (x <= y ?= iff c) (if c then x == y else x < y).
Proof.
rewrite /ltC (eq_sym y); apply: (iffP idP) => [|[-> ->]]; last by case: c.
by case: c => [/eqP-> | /andP[/negPf] //]; rewrite /leCif leC_refl eqxx.
Qed.

Fact sqrtC_subproof x : exists y : algC, y ^+ 2 == x.
Proof.
have [// | y def_y2] := @solve_monicpoly algC 2 [fun i => 0 with 0%N |-> x].
by exists y; rewrite def_y2 !big_ord_recl big_ord0 /= mulr1 mul0r !addr0.
Qed.

Definition sqrtC := locked (fun x =>
  let y := xchoose (sqrtC_subproof x) in if 0 <= y then y else - y).

Lemma sqrtCK x : sqrtC x ^+ 2 = x.
Proof.
unlock sqrtC; rewrite (fun_if (fun y => y ^+ 2)) sqrrN if_same.
exact/eqP/(xchooseP (sqrtC_subproof x)).
Qed.

Lemma sqrtC_sqr c : (sqrtC (c ^+ 2) == c) || (sqrtC (c ^+ 2) == - c).
Proof. by rewrite -subr_eq0 -addr_eq0 -mulf_eq0 -subr_sqr sqrtCK subrr. Qed.

Lemma sqrtC_sqr_pos c : 0 <= c -> sqrtC (c ^+ 2) = c.
Proof.
move=> le0c; case/pred2P: (sqrtC_sqr c) => //; unlock sqrtC.
case: ifPn => le0rc def_c; move: le0rc; last by rewrite (oppr_inj def_c) le0c.
by rewrite def_c -sub0r leC_sub => /leC_anti->; rewrite ?subrr.
Qed.

Lemma sqrtC0 : sqrtC 0 = 0.
Proof. by rewrite -{1}(mulr0 0) sqrtC_sqr_pos ?leC_refl. Qed.

Lemma sqrtC_eq0 c : (sqrtC c == 0) = (c == 0).
Proof.
apply/eqP/eqP=> [|->]; last exact: sqrtC0.
by rewrite -{2}[c]sqrtCK => ->; rewrite exprS mul0r.
Qed.

Lemma sqrtC1 : sqrtC 1 = 1.
Proof. by rewrite -{2}(sqrtC_sqr_pos posC1) expr1n. Qed. 

Definition normC x := sqrtC (x * x^*).
Notation "`| z |" := (normC z) : ring_scope.

Lemma normCK x : `|x| ^+ 2 = x * x^*.
Proof. exact: sqrtCK. Qed.

Lemma sqrf_eqP (F : idomainType) (x y : F) :
  reflect (x = y \/ x = - y) (x ^+ 2 == y ^+ 2).
Proof.
by rewrite -subr_eq0 subr_sqr mulf_eq0 subr_eq0 addr_eq0; exact: pred2P.
Qed.

Fact conjCid_norm z : `|z|^* = normC z.
Proof.
set y := normC z; have /sqrf_eqP[// | def_y]: y^* ^+ 2 == y ^+ 2.
  by rewrite -rmorphX normCK rmorphM conjCK mulrC.
suffices /eqP: y ^+ 2 = 0 by rewrite expf_eq0 => /=/eqP->; rewrite rmorph0.
apply: leC_anti; last by rewrite normCK posC_pconj.
by rewrite -posC_opp -mulrN -def_y posC_pconj.
Qed.

Fact leC_real_total x : x^* = x -> x <= 0 \/ 0 <= x.
Proof.
move=> Rx; pose y := sqrtC x; apply/orP; rewrite -posC_opp.
have: (y * y^*) ^+ 2 == x ^+ 2 by rewrite exprMn -rmorphX sqrtCK Rx.
by case/sqrf_eqP=> <-; rewrite posC_pconj ?orbT.
Qed.

Lemma normC_opp x : `|- x| = `|x|.
Proof. by rewrite /normC rmorphN mulrN mulNr opprK. Qed.

Lemma normC_mul_sign n x : `|(-1) ^+ n * x| = `|x|.
Proof. by rewrite -signr_odd mulr_sign fun_if normC_opp if_same. Qed.

Lemma normC_nat n : `|n%:R| = n%:R.
Proof. by rewrite /normC rmorph_nat sqrtC_sqr_pos ?posC_nat. Qed.

Lemma normC0 : `|0| = 0.
Proof. exact: normC_nat 0%N. Qed.

Lemma normC1 : `|1| = 1.
Proof. exact: normC_nat 1%N. Qed.

Lemma posC_norm x : 0 <= `|x|.
Proof.
have [| //] := leC_real_total (conjCid_norm x); rewrite -leC_sub sub0r.
by unlock normC sqrtC; case: ifP; rewrite // opprK => ->.
Qed.

Lemma normC_eq0 c : (`|c| == 0) = (c == 0).
Proof. by rewrite -[_ == 0](expf_eq0 _ 2) sqrtCK mulf_eq0 conjC_eq0 orbb. Qed.

Lemma normC_mul : {morph normC: x y / x * y}.
Proof.
move=> x y; rewrite {1}/normC rmorphM mulrCA -mulrA mulrCA mulrA.
rewrite -[x * _]sqrtCK -[y * _]sqrtCK -exprMn sqrtC_sqr_pos //.
by rewrite posC_mul //; exact: posC_norm.
Qed.

Lemma normC_exp x n : `|x ^+ n| = `|x| ^+ n.
Proof.
elim: n => [|n IH]; first exact: normC1.
by rewrite exprS normC_mul IH exprS.
Qed.

Lemma normC_conj x : `|x^*| = `|x|.
Proof. by rewrite /normC conjCK mulrC. Qed.

Lemma normC_inv x : `|x^-1| = `|x|^-1.
Proof.
have [|nz_x] := boolP (normC x == 0).
  by rewrite normC_eq0 => /eqP->; rewrite !(normC0, invr0).
by apply: (mulIf nz_x); rewrite mulVf // -normC_mul mulVf ?normC1 // -normC_eq0.
Qed.

Lemma invC_norm x : x^-1 = `|x| ^- 2 * x^*.
Proof.
have [-> | nx_x] := eqVneq x 0; first by rewrite conjC0 mulr0 invr0.
by rewrite sqrtCK invfM divfK ?conjC_eq0.
Qed.

Lemma conjC_inv x : (x^-1)^* = (x^*)^-1.
Proof. exact: fmorphV. Qed.

(* This is the first use of Archimedean axiom. *)
Lemma normC_pos x : 0 <= x -> `|x| = x.
Proof.
move=> le0x; have [-> | nzx] := eqVneq x 0; first by rewrite normC0.
rewrite -{2}[x]mul1r; apply: canRL (divfK nzx) _; set y := normC x / x.
have le0y: 0 <= y by rewrite posC_mul ?posC_inv ?posC_norm.
have ley1_sym: (y <= 1) = (1 <= y).
  rewrite -leC_sub -posC_conj rmorphB rmorph1 leC_sub.
  have lt0y: 0 < y by rewrite ltCE mulf_eq0 invr_eq0 normC_eq0 orbb nzx.
  rewrite -(leC_pmul2l _ _ lt0y) mulr1 fmorph_div conjCid_norm mulrCA !mulrA.
  by rewrite -expr2 sqrtCK (mulrC x) mulfK // divff ?conjC_eq0.
suffices ley1: y <= 1 by rewrite (leC_anti ley1) -?ley1_sym.
rewrite /leC subr0 in le0y.
have [[/and3P[] //| n /andP[le_n1_y _]]] := realC_archimedean le0y.
by rewrite ley1_sym (leC_trans _ le_n1_y) -?(leq_leC 1).
Qed.

Lemma posC_conjK x : 0 <= x -> x^* = x.
Proof. by move/normC_pos <-; rewrite conjCid_norm. Qed.

Lemma sqrtC_pos x : (0 <= sqrtC x) = (0 <= x).
Proof.
apply/idP/idP=> [le0rx | le0x]; first by rewrite -[x]sqrtCK posC_mul.
have [-> | nzx] := eqVneq x 0; first by rewrite sqrtC0 leC_refl.
pose y := sqrtC x * (sqrtC x)^*; suffices ->: x = y by exact: posC_norm.
have: x ^+ 2 == y ^+ 2 by rewrite exprMn -rmorphX sqrtCK posC_conjK.
rewrite -subr_eq0 subr_sqr mulf_eq0 subr_eq0 => /predU1P[] // /idPn[].
suffices: 0 < x + y by case/andP.
by rewrite sposC_addr ?posC_pconj // ltCE nzx.
Qed.

Lemma posC_unit_exp x n : 0 <= x -> (x ^+ n.+1 == 1) = (x == 1).
Proof.
move=> le0x; apply/idP/eqP=> [|->]; last by rewrite expr1n.
apply: contraTeq => neq_x_1.
suffices: x ^+ n.+1 < 1 \/ 1 < x ^+ n.+1.
  by move/orP; rewrite ltCE eq_sym -andb_orr => /andP[].
have{neq_x_1}: x < 1 \/ 1 < x.
  rewrite !ltCE eq_sym neq_x_1 -(leC_sub 1) -leC_sub -opprB -sub0r leC_sub.
  by apply: leC_real_total; rewrite rmorphB rmorph1 posC_conjK.
case=> [ltx1 | lt1x]; [left | right]; elim: n => // n /ltCW IHn.
  by apply: leC_ltC_trans ltx1; rewrite -{2}[x]mulr1 leC_mul2l. 
by apply: ltC_leC_trans lt1x _; rewrite -{1}[x]mulr1 leC_mul2l. 
Qed.

Lemma normC_add x y : `|x + y| <= `|x| + `|y|.
Proof.
have [-> | ntx] := eqVneq x 0; first by rewrite normC0 !add0r leC_refl.
have [-> | nty] := eqVneq y 0; first by rewrite normC0 !addr0 leC_refl.
have /leC_pmul2r ltMxy: 0 < `|x| + `|y| + `|x + y|.
  by rewrite !sposC_addr ?ltCE ?posC_norm //= normC_eq0 ntx.
rewrite -leC_sub -{}ltMxy mul0r -subr_sqr sqrrD !sqrtCK leC_sub rmorphD.
rewrite mulrDl !mulrDr addrA leC_add2r -addrA leC_add2l -normC_mul.
set z := _ + _; set p := _ *+ 2.
have le0p: 0 <= p by rewrite posC_add ?posC_norm.
have Rz: z^* = z by rewrite !(rmorphD, rmorphM) !conjCK mulrC addrC (mulrC _ x).
case/leC_real_total: Rz => [/leC_trans-> // | le0z].
have /leC_pmul2r ltMxy: 0 < p + z.
  by rewrite !sposC_addr ?ltCE ?posC_norm // normC_eq0 mulf_neq0.
rewrite -leC_sub -{}ltMxy mul0r -subr_sqr leC_sub -[p]mulr_natr exprMn.
rewrite -natrX mulr_natr sqrtCK rmorphM mulrA mulrC -mulrA mulrCA mulrA.
rewrite -subr_sqrDB addrC -leC_sub addrK -mulNr opprB.
rewrite -[_ - _]conjCK rmorphB !rmorphM !conjCK mulrC (mulrC x) (mulrC y).
exact: posC_pconj.
Qed.

Lemma normC_add_eq x y : 
    `|x + y| = `|x| + `|y| -> 
  exists2 k, `|k| = 1 & ((x == `|x| * k) && (y == `|y| * k)).
Proof.
pose s z := z / normC z; have congr_sqr := congr1 (fun z => z ^+ 2).
have norm1 z: z != 0 -> `|s z| = 1 /\ z == `|z| * s z.
  rewrite -normC_eq0 => nzz; rewrite mulrC divfK // /normC fmorph_div //.
  rewrite conjCid_norm mulrCA -mulrA -invfM mulrCA mulrA -expr2 -exprVn.
  by rewrite -[z * _]sqrtCK -exprMn divff // expr1n sqrtC1.
move=> def_Nxy; have [-> | ntx] := eqVneq x 0.
  have [-> | nty] := eqVneq y 0.
    by exists 1; rewrite ?normC1 // !normC0 mul0r eqxx.
  by have [? ?] := norm1 y nty; exists (s y); rewrite // normC0 mul0r eqxx.
have [ns1 def_x] := norm1 x ntx; exists (s x); rewrite ?def_x //=.
move/congr_sqr: def_Nxy; rewrite sqrrD !sqrtCK rmorphD mulrDl !mulrDr.
rewrite addrA => /addIr; rewrite -addrA -normC_mul -mulr_natr => /addrI def2xy.
have eq_xy: x * y^* = y * x^*.
  apply/eqP; rewrite -subr_eq0 -normC_eq0 sqrtC_eq0 rmorphB !rmorphM !conjCK.
  rewrite -(mulrC x) -(mulrC y) [_ * _]mulrC -[_ - _]opprB mulNr -expr2.
  move/congr_sqr/esym/eqP: def2xy; rewrite exprMn sqrtCK -natrX.
  rewrite mulr_natr rmorphM mulrA [_ * _]mulrC -mulrA mulrCA mulrA.
  by rewrite -subr_sqrDB addrC -[_ == _]subr_eq0 addrK.
have{eq_xy def2xy} def_xy: y * x^* = normC (x * y).
  apply: (@mulIf _ 2%:R); first by rewrite -(eqN_eqC 2 0).
  by rewrite mulr_natr mulrS -{1}eq_xy.
apply/eqP/(@mulfI _ (normC x ^+ 2)); first by rewrite expf_eq0 normC_eq0.
rewrite {1}sqrtCK mulrAC -mulrA def_xy normC_mul mulrC -!mulrA; congr (_ * _).
by rewrite mulrCA; congr (_ * _); rewrite mulrC divfK ?normC_eq0.
Qed.

Lemma normC_sum I (r : seq I) (P : pred I) (F : I -> algC) :
   `|\sum_(i <- r | P i) F i| <= \sum_(i <- r | P i) `|F i|.
Proof.
elim/big_rec2: _ => [|i u x _ le_ux]; first by rewrite normC0 leC_refl.
by apply: (leC_trans (normC_add _ _)); rewrite leC_add2l.
Qed.

Lemma normC_sum_eq (I : finType) (P : pred I) (F : I -> algC) :
     `|\sum_(i | P i) F i| = \sum_(i | P i) `|F i| ->
   exists2 k, `|k| = 1 & forall i, P i -> F i = `|F i| * k.
Proof.
have [i /andP[Pi nzFi] | F0] := pickP [pred i | P i && (F i != 0)]; last first.
  exists 1 => [|i Pi]; first exact: normC1.
  by case/nandP: (F0 i) => [/negP[]// | /negbNE/eqP->]; rewrite normC0 mul0r.
rewrite !(bigD1 i Pi) /=; set Q := fun _ => _ : bool => norm_sumF.
rewrite -normC_eq0 in nzFi; set c := F i / `|F i|; exists c => [|j Pj].
  by rewrite normC_mul normC_inv (normC_pos (posC_norm _)) divff.
have [Qj | /nandP[/negP[]// | /negbNE/eqP->]] := boolP (Q j); last first.
  by rewrite mulrC divfK.
have: `|F i + F j| = `|F i| + `|F j|.
  do [rewrite !(bigD1 j Qj) /=; set z := \sum_(k | _) `|_|] in norm_sumF.
  apply/eqP; rewrite eqC_leC normC_add -(leC_add2r z) -addrA -norm_sumF addrA.
  by rewrite (leC_trans (normC_add _ _)) // leC_add2l normC_sum.
case/normC_add_eq=> k _ /andP[/eqP/(canLR (mulKf nzFi)) <- /eqP].
by rewrite -(mulrC (F i)).
Qed.

Lemma normC_sum_eq1 (I : finType) (P : pred I) (F : I -> algC) :
    `|\sum_(i | P i) F i| = (\sum_(i | P i) `|F i|) ->
     (forall i, P i -> `|F i| = 1) ->
   exists2 k, `|k| = 1 & forall i, P i -> F i = k.
Proof.
case/normC_sum_eq=> k k1 defF normF.
by  exists k => // i Pi; rewrite defF // normF // mul1r.
Qed.

Lemma normC_sum_upper (I : finType) (P : pred I) (F G : I -> algC) :
     (forall i, P i -> `|F i| <= G i) ->
     \sum_(i | P i) F i = \sum_(i | P i) G i ->
   forall i, P i -> F i = G i.
Proof.
set sumF := \sum_(i | _) _; set sumG := \sum_(i | _) _ => leFG eq_sumFG.
have posG i: P i -> 0 <= G i by move/leFG; apply: leC_trans; exact: posC_norm.
have norm_sumG: `|sumG| = sumG by rewrite normC_pos ?posC_sum.
have norm_sumF: `|sumF| = \sum_(i | P i) `|F i|.
  apply/eqP; rewrite eqC_leC normC_sum eq_sumFG norm_sumG -leC_sub -sumrB.
  by rewrite posC_sum // => i Pi; rewrite leC_sub ?leFG.
have [k _ defF] := normC_sum_eq norm_sumF.
have [/(posC_sum_eq0 posG) G0 i Pi | nz_sumG] := eqVneq sumG 0.
  by apply/eqP; rewrite G0 // -normC_eq0 eqC_leC posC_norm -(G0 i Pi) leFG.
have k1: k = 1.
  apply: (mulfI nz_sumG); rewrite mulr1 -{1}norm_sumG -eq_sumFG norm_sumF.
  by rewrite mulr_suml -(eq_bigr _ defF).
have /posC_sum_eq0 eqFG i : P i -> 0 <= G i - F i.
  by move=> Pi; rewrite leC_sub defF // k1 mulr1 leFG.
move=> i /eqFG/(canRL (subrK _))->; rewrite ?add0r //.
by rewrite sumrB -/sumF eq_sumFG subrr.
Qed.

Definition getNatC x :=
  if insub x : {? c | repC c} is Some c then
    val (sigW (realC_archimedean (valP c)))
  else 0%N.

Lemma getNatC_def x (n := getNatC x) :
  if 0 <= x then (n%:R <= x) && (x < (n + 1)%:R) else n == 0%N.
Proof.
rewrite {}/n /getNatC /ltC /leC subr0 addn1 eq_sym (andbC (~~ _)).
case: ifPn => [le0x | not_le0x]; last by rewrite insubN.
by rewrite insubT //=; case: (sigW _).
Qed.

Lemma getNatC_nat n : getNatC (n%:R) = n.
Proof.
have:= getNatC_def n%:R; rewrite /= posC_nat -leq_leC -ltn_ltC.
case/andP=> H1 H2; apply: anti_leq => //.
by rewrite H1 // -ltnS -[(getNatC _).+1]addn1.
Qed.

Definition isNatC c := c == (getNatC c)%:R.

Lemma isNatCP c : reflect (exists n, c = n%:R) (isNatC c).
Proof.
apply: (iffP idP)=> [H | [n H]]; first by exists (getNatC c); apply/eqP.
by rewrite H /isNatC getNatC_nat.
Qed.

Lemma isNatC_nat n : isNatC (n%:R).
Proof. by apply/isNatCP; exists n. Qed.
Lemma isNatC_0 : isNatC 0. Proof. exact: (isNatC_nat 0). Qed.
Lemma isNatC_1 : isNatC 1. Proof. exact: (isNatC_nat 1). Qed.
Hint Resolve isNatC_0 isNatC_1.

Lemma isNatC_add c1 c2 : isNatC c1 -> isNatC c2 -> isNatC (c1 + c2).
Proof.
by case/isNatCP=> n1 ->; case/isNatCP=> n2 ->; rewrite -natrD isNatC_nat.
Qed.

Lemma isNatC_mul c1 c2 : isNatC c1 -> isNatC c2 -> isNatC (c1 * c2).
Proof.
by case/isNatCP=> n1 ->; case/isNatCP=> n2 ->; rewrite -natrM isNatC_nat.
Qed.

Lemma isNatC_exp x n : isNatC x -> isNatC (x ^+ n).
Proof. by move=> Nx; elim: n => // n IHn; rewrite exprS isNatC_mul. Qed.

Lemma isNatC_sum (I : Type) (r : seq I) (P : pred I) (F : I -> algC) :
   (forall i, P i -> isNatC (F i)) -> isNatC (\sum_(j <- r | P j) F j).
Proof. by move=> H; apply big_ind=> //; exact: isNatC_add. Qed.

Lemma isNatC_muln x n : isNatC x -> isNatC (x *+ n).
Proof. by elim: n => // n IH Hx; rewrite mulrSr isNatC_add // IH. Qed.

Lemma posC_Nat c : isNatC c -> 0 <= c.
Proof. by case/isNatCP=> n ->; exact: posC_nat. Qed.

Lemma isNatC_conj c : isNatC c -> c^* = c.
Proof. by case/isNatCP=> n ->; exact: conjC_nat. Qed.

Lemma isNatC_sum_eq1 (I : finType) (P : pred I) (F : I -> algC) :
     (forall i, P i -> isNatC (F i)) -> \sum_(i | P i) F i = 1 ->
   {i : I | [/\ P i, F i = 1 & forall j, j != i -> P j -> F j = 0]}.
Proof.
move=> natF sumF1; pose nF i := getNatC (F i).
have{natF} defF i: P i -> F i = (nF i)%:R by move/natF/eqP.
have{sumF1} /eqP sumF1: (\sum_(i | P i) nF i == 1)%N.
  by rewrite eqN_eqC natr_sum -(eq_bigr _ defF) sumF1.
have [i Pi nZfi]: {i : I | P i & nF i != 0%N}.
  by apply/sig2W/exists_inP; rewrite -negb_forall_in -sum_nat_eq0 sumF1.
have F'ge0 := (leq0n _, etrans (eq_sym _ _) (sum_nat_eq0 (predD1 P i) nF)).
rewrite -lt0n in nZfi; have [_] := (leqif_add (leqif_eq nZfi) (F'ge0 _)).
rewrite /= big_andbC -bigD1 // sumF1 => /esym/andP/=[/eqP Fi1 /forall_inP Fi'0].
exists i; split=> // [|j neq_ji Pj]; first by rewrite defF // -Fi1.
by rewrite defF // (eqP (Fi'0 j _)) // neq_ji.
Qed.

(* Real algebraics. *)
Definition isRealC x := (x^* == x).

Lemma realC_leP x : reflect (x <= 0 \/ 0 <= x) (isRealC x).
Proof.
apply: (iffP eqP); first exact: leC_real_total.
by rewrite -posC_opp => [[]] /posC_conjK //; rewrite rmorphN => /oppr_inj.
Qed.

Lemma real_normCK x : isRealC x -> `|x| ^+ 2 = x ^+ 2.
Proof. by rewrite normCK => /eqP->. Qed.

Lemma real_signE x : isRealC x -> x = (-1) ^+ (x < 0)%C * `|x|.
Proof.
rewrite mulr_sign; case/realC_leP=> [ge0x | le0x]; last first.
  by rewrite normC_pos ?leC_gtF.
rewrite ltCE ge0x andbT -normC_opp normC_pos ?opprK ?posC_opp //.
by case: eqP => // <-; rewrite oppr0.
Qed.

Lemma realC_ltNge x y : isRealC x -> isRealC y -> (x < y) = ~~ (x >= y).
Proof.
move=> r_x r_y; rewrite ltCE eqC_leC negb_and andb_orl andNb orbF andb_idr //.
apply/implyP; rewrite implybE negbK -leC_sub orbC -leC_sub -opprB posC_opp.
by rewrite (sameP orP (realC_leP _)) /isRealC rmorphB (eqP r_x) (eqP r_y).
Qed.

Lemma realC_leNgt x y : isRealC x -> isRealC y -> (x <= y) = ~~ (x > y).
Proof. by move=> r_x r_y; rewrite realC_ltNge ?negbK. Qed.

(* We mimic Z by a sign and a natural number *)
Definition getIntC x :=
  if 0 <= x then (false, getNatC x) else (true, getNatC (- x)).

Definition isIntC x := x == (let: (b, n) := getIntC x in (-1) ^+ b * n%:R).

Lemma isIntCP x : isIntC x -> {e : bool & {n | x = (-1) ^+ e * n%:R}}.
Proof. by move/(x =P _); case: (getIntC x) => e n; exists e, n. Qed.

Lemma isIntCE x : isIntC x = isNatC x || isNatC (- x).
Proof.
apply/idP/idP=> [/isIntCP[b [n ->]] | ].
  by rewrite mulr_sign; case: b; rewrite ?opprK ?isNatC_nat ?orbT.
rewrite /isIntC /getIntC => /orP[] /isNatCP[n def_x].
  by rewrite def_x posC_nat mul1r getNatC_nat.
rewrite -{-4}[x]opprK {x}def_x getNatC_nat posC_opp -(leq_leC n 0).
by case: n => [|n]; rewrite /= ?mulN1r // mul1r oppr0 (getNatC_nat 0).
Qed.

Lemma isIntC_Nat x : isNatC x -> isIntC x.
Proof. by rewrite isIntCE => ->. Qed.

Lemma isIntC_nat n : isIntC (n%:R).
Proof. by rewrite isIntCE isNatC_nat. Qed.
Lemma isIntC_0 : isIntC 0. Proof. exact: (isIntC_nat 0). Qed.
Lemma isIntC_1 : isIntC 1. Proof. exact: (isIntC_nat 1). Qed.
Hint Resolve isIntC_0 isIntC_1.

Lemma isIntC_opp x : isIntC (- x) = isIntC x.
Proof. by rewrite !isIntCE opprK orbC. Qed.

Lemma isIntC_mul_sign n x : isIntC ((-1) ^+ n * x) = isIntC x.
Proof. by rewrite -signr_odd mulr_sign fun_if isIntC_opp if_same. Qed.

Lemma isIntC_sign n : isIntC ((-1) ^+ n).
Proof. by rewrite -[_ ^+ _]mulr1 isIntC_mul_sign (isIntC_nat 1). Qed.

Lemma isIntC_add x y : isIntC x -> isIntC y -> isIntC (x + y).
Proof.
move=> /isIntCP[e [m ->]] /isIntCP[b [n ->]].
without loss le_nm: e b m n / (n <= m)%N.
  by move=> IH; case/orP: (leq_total n m) => /IH //; rewrite addrC.
rewrite -(addKb e b) signr_addb -mulrA -mulrDr isIntC_mul_sign mulr_sign.
by case: ifP => _; rewrite -(natrD, natrB) // isIntC_nat.
Qed.

Lemma isIntC_sub x y : isIntC x -> isIntC y -> isIntC (x - y).
Proof. by move=> Zx Zy; rewrite isIntC_add ?isIntC_opp. Qed.

Lemma isIntC_mul x y : isIntC x -> isIntC y -> isIntC (x * y).
Proof.
move=> /isIntCP[e [m ->]] /isIntCP[b [n ->]].
by rewrite -mulrA isIntC_mul_sign mulrCA isIntC_mul_sign -natrM isIntC_nat.
Qed.

Lemma isIntC_exp x n : isIntC x -> isIntC (x ^+ n).
Proof. by move=> Zx; elim: n => // n IHn; rewrite exprS isIntC_mul. Qed.

Lemma isIntC_sum (I : Type) (r : seq I) (P : pred I) (F : I -> algC) :
   (forall i, P i -> isIntC (F i)) -> isIntC (\sum_(j <- r | P j) F j).
Proof. by move=> Z_F; apply big_ind=> //; exact: isIntC_add. Qed.

Lemma isIntC_conj c : isIntC c -> c^* = c.
Proof. by case/isIntCP=> b [n ->]; rewrite rmorphM rmorph_sign rmorph_nat. Qed.

Lemma isIntC_Real x : isIntC x -> isRealC x.
Proof. by move/isIntC_conj/eqP. Qed.

Lemma int_normCK x : isIntC x -> `|x| ^+ 2 = x ^+ 2.
Proof. by move/isIntC_Real/real_normCK. Qed.

Lemma isIntC_signE x : isIntC x -> x = (-1) ^+ (x < 0)%C * `|x|.
Proof. by move/isIntC_Real/real_signE. Qed.

Lemma normIntC_Nat x : isIntC x -> isNatC `|x|.
Proof.
by case/isIntCP=> b [n ->]; rewrite normC_mul_sign normC_nat isNatC_nat.
Qed.

Lemma isIntC_pos x : 0 <= x -> isIntC x = isNatC x.
Proof. by rewrite /isIntC /getIntC => ->; rewrite mul1r. Qed.

Lemma isNatC_posInt x : isNatC x = isIntC x && (0 <= x).
Proof.
by rewrite -(andb_idr (@posC_Nat x)); apply: andb_id2r => /isIntC_pos.
Qed.

Lemma isNatC_exp_even x n : ~~ odd n -> isIntC x -> isNatC (x ^+ n).
Proof.
rewrite -dvdn2 => /dvdnP[m ->] Zx; rewrite isNatC_posInt isIntC_exp //.
by rewrite exprM -int_normCK ?isIntC_exp // posC_exp ?posC_norm.
Qed.

Lemma isIntC_normC_ge1 x : isIntC x -> x != 0 -> 1 <= `|x|.
Proof.
rewrite -normC_eq0; case/normIntC_Nat/isNatCP=> n ->.
by rewrite -neq0N_neqC -lt0n leq_leC.
Qed.

Lemma isIntC_expr2_ge1 x : isIntC x -> x != 0 -> 1 <= x ^+ 2.
Proof.
by move=> Zx nz_x; rewrite -int_normCK // leC1exp ?posC_norm ?isIntC_normC_ge1.
Qed.

Definition dvdC x y := if x == 0 then y == 0 else isIntC (y / x).
Notation dvdNC n y := (dvdC n%:R y).

Lemma dvdCP x y : reflect (exists2 z, isIntC z & y = z * x) (dvdC x y).
Proof.
rewrite /dvdC; have [-> | nz_x] := altP eqP.
  by apply: (iffP eqP) => [-> | [z _ ->]]; first exists 0; rewrite ?mulr0.
apply: (iffP idP) => [Zxp | [z Zz ->]]; last by rewrite mulfK.
by exists (y / x); rewrite ?divfK.
Qed.

Lemma dvdCP_nat x y : 0 <= x -> 0 <= y -> dvdC x y -> {n | y = n%:R * x}.
Proof.
move=> x_ge0 y_ge0 x_dv_y; apply: sig_eqW.
case/dvdCP: x_dv_y => z Zz -> in y_ge0 *; move: x_ge0 y_ge0 Zz.
rewrite leC_eqVlt => /predU1P[<- | ]; first by exists 22; rewrite !mulr0.
by move=> /posC_mull-> /isIntC_pos-> /isNatCP[n ->]; exists n.
Qed.

Lemma dvdC0 x : dvdC x 0.
Proof. by rewrite /dvdC mul0r isIntC_0 eqxx if_same. Qed.

Lemma dvd0C x : dvdC 0 x = (x == 0).
Proof. by rewrite /dvdC eqxx. Qed.

Lemma dvdC_opp x y : dvdC x (- y) = dvdC x y.
Proof. by rewrite /dvdC mulNr isIntC_opp oppr_eq0. Qed.

Lemma dvdC_mulrn p x : isIntC x -> dvdNC p (x *+ p).
Proof. by move=> Zx; apply/dvdCP; exists x; rewrite ?mulr_natr ?IsIntC_nat. Qed.

Lemma dvdC_mul_sign x e y : dvdC x ((-1) ^+ e * y) = dvdC x y.
Proof. by rewrite -signr_odd mulr_sign fun_if dvdC_opp if_same. Qed.

Lemma dvdC_nat p n : dvdNC p (n%:R) = (p %| n)%N.
Proof.
rewrite /dvdC isIntC_pos ?posC_div ?posC_nat // -(eqN_eqC n 0) -dvd0n.
have [|nz_p] := ifPn; first by rewrite -(eqN_eqC p 0) => /eqP->.
apply/isNatCP/dvdnP=> [[q def_q] | [q ->]]; exists q.
  by apply/eqP; rewrite eqN_eqC natrM -def_q divfK. 
by rewrite natrM mulfK.
Qed.

Lemma dvdC_int p x : isIntC x -> dvdNC p x = (p %| getNatC `|x|%R)%N.
Proof.
case/isIntCP=> e [n ->{x}]; rewrite dvdC_mul_sign {e}normC_mul_sign.
by rewrite normC_nat getNatC_nat dvdC_nat.
Qed.

Lemma dvdC_add x y z : dvdC x y -> dvdC x z -> dvdC x (y + z).
Proof.
rewrite /dvdC; case: ifP => [_ /eqP-> | _ p_x p_y]; first by rewrite add0r.
by rewrite mulrDl isIntC_add.
Qed.

Lemma dvdC_addl x y z : dvdC x y -> dvdC x (y + z) = dvdC x z.
Proof.
move=> x_dv_y; apply/idP/idP; last exact: dvdC_add.
by rewrite -{2}(addKr y z); apply: dvdC_add; rewrite dvdC_opp.
Qed.

Lemma dvdC_mull x y z : isIntC y -> dvdC x z -> dvdC x (y * z).
Proof.
move=> Zy /dvdCP[m Zm ->]; apply/dvdCP.
by exists (y * m); rewrite ?mulrA ?isIntC_mul.
Qed.

Lemma dvdC_mulr x y z : isIntC y -> dvdC x z -> dvdC x (z * y).
Proof. by rewrite mulrC; exact: dvdC_mull. Qed.

Lemma dvdC_trans x y z : dvdC x y -> dvdC y z -> dvdC x z.
Proof. by move=> x_dv_y /dvdCP[m Zm ->]; exact: dvdC_mull. Qed.

Lemma dvdC_refl x : dvdC x x.
Proof. by apply/dvdCP; exists 1; rewrite ?mul1r. Qed.
Hint Resolve dvdC_refl.

Section AutC.

Variable u : {rmorphism algC -> algC}.

Lemma rmorph_NatC z : isNatC z -> u z = z.
Proof. by case/isNatCP=> n ->; exact: rmorph_nat. Qed.

Lemma rmorph_IntC z : isIntC z -> u z = z.
Proof.
by rewrite isIntCE => /orP[]/rmorph_NatC //; rewrite rmorphN => /oppr_inj.
Qed.

End AutC.

Section AutLmodC.

Variables (U V : lmodType algC) (f : {additive U -> V}).

Lemma raddfZ_NatC a u : isNatC a -> f (a *: u) = a *: f u. 
Proof. by case/isNatCP=> n ->; exact: raddfZnat. Qed.

Lemma raddfZ_IntC a u : isIntC a -> f (a *: u) = a *: f u. 
Proof.
by move/eqP->; case: (getIntC a) => e n; rewrite -!scalerA raddfZsign raddfZnat.
Qed.

End AutLmodC.

Section AlgCRect.
(* Imaginary numbers and rectangular coordinates. This is proof-of-concept    *)
(* only, and not currently used in the rest of the formalization (it was part *)
(* of a failed early automorphism construction attempt).                      *)
Definition algCi : algC := sqrtC (- 1).
Definition alg_Re x := (x + x^*) / 2%:R.
Definition alg_Im x := (x - x^*) / (algCi *+ 2).

Lemma sqr_algCi : algCi ^+ 2 = -1. Proof. exact: sqrtCK. Qed.

Lemma algCi_nonReal : ~~ isRealC algCi.
Proof.
apply: contraFN (ltC_geF sposC1) => /real_normCK norm_i.
by rewrite -posC_opp -sqr_algCi -norm_i sqrtCK posC_pconj.
Qed.

Lemma algCi_neq0 : algCi != 0.
Proof. by apply: contraNneq algCi_nonReal => ->; exact: isIntC_Real. Qed.

Lemma normCi : `|algCi| = 1.
Proof.
apply/eqP; rewrite -(@posC_unit_exp _ 1) ?posC_norm // -normC_exp sqr_algCi.
by rewrite normC_opp normC1.
Qed.

Lemma conjCi : algCi^* = - algCi.
Proof.
have: root (\prod_(z <- [:: algCi; -algCi]) ('X - z%:P)) algCi^*.
  rewrite big_cons big_seq1 raddfN opprK -subr_sqr -rmorphX sqr_algCi.
  by rewrite /root !hornerE -expr2 -rmorphX sqr_algCi rmorphN rmorph1 subrr.
by rewrite root_prod_XsubC !inE [_ == _](negPf algCi_nonReal) => /eqP.
Qed.

Lemma invCi : algCi^-1 = - algCi.
Proof. by rewrite invC_norm normCi conjCi expr1n invr1 mul1r. Qed.

Lemma algCrect x : x = alg_Re x + algCi * alg_Im x.
Proof. 
rewrite mulrCA -mulr_natr invfM mulVKf ?algCi_neq0 // -mulrDl.
by rewrite addrCA !addrA addrK -mulr2n -mulr_natr mulfK -?neq0N_neqC.
Qed.

Lemma alg_Re_Real x : isRealC (alg_Re x).
Proof. by rewrite /isRealC fmorph_div rmorph_nat rmorphD conjCK addrC. Qed.

Lemma alg_Im_Real x : isRealC (alg_Im x).
Proof.
rewrite /isRealC fmorph_div rmorphMn conjCi mulNrn invrN mulrN -mulNr.
by rewrite rmorphB conjCK opprB.
Qed.

Lemma isRealC_conj x : isRealC x -> x^* = x. Proof. by move/eqP. Qed.

Lemma alg_Re_rect x y : isRealC x -> isRealC y -> alg_Re (x + algCi * y) = x.
Proof.
move=> Rx Ry; rewrite /alg_Re rmorphD addrCA !addrA rmorphM conjCi mulNr.
by rewrite !isRealC_conj // addrK -mulr2n -(mulr_natr x) mulfK -?neq0N_neqC.
Qed.

Lemma alg_Im_rect x y : isRealC x -> isRealC y -> alg_Im (x + algCi * y) = y.
Proof.
move=> Rx Ry; rewrite /alg_Im rmorphD opprD addrAC -!addrA rmorphM conjCi.
rewrite mulNr opprK !isRealC_conj // addNKr -(mulrC y) -mulr2n -mulrnAr.
by rewrite mulfK // -mulr_natr mulf_neq0 ?algCi_neq0 -?neq0N_neqC.
Qed.

End AlgCRect.

Section AlgCorder.
(* Link to numFieldType, used (for now) only to get intr injectivity and      *)
(* ratr morphism properties. Note that since the head symbol of algC : Type  *)
(* is in fact GRing.ClosedField.sort, the structures below are in fact        *)
(* incompatible with some the canonical ones declared by ssrnum.          *)
Import ssrnum.

Fact algC_numMixin : Num.mixin_of algC.
Proof.
apply: (@NumMixin _ leC ltC normC) => //.
+ exact: normC_add.
+ by move=> x y x_gt0 y_gt0; rewrite sposC_addl // ltCW.
+ by move=> x /eqP; rewrite normC_eq0 => /eqP.
+ move=> x y x_ge0 y_ge0; apply/orP.
  rewrite -leC_sub -[leC y x]leC_sub -opprB posC_opp.
  by apply: leC_real_total; rewrite rmorphB !posC_conjK.
+ exact: normC_mul.
+ move=> x y; rewrite -leC_sub; move: (_ - _) => z; apply/idP/eqP.
    by move=> /normC_pos.
  by move<-; rewrite posC_norm.
Qed.

Definition algC_numIdomainType := NumIdomainType algC algC_numMixin.
Definition algC_numFieldType := NumFieldType algC algC_numMixin.

End AlgCorder.

Canonical algC_numIdomainType.
Canonical algC_numFieldType.

Local Notation ZtoQ := (intr : int -> rat).
Local Notation ZtoC := (intr : int -> algC).
Local Notation QtoC := (ratr : rat -> algC).

Local Notation intrp := (map_poly intr).
Local Notation pZtoQ := (map_poly ZtoQ).
Local Notation pZtoC := (map_poly ZtoC).
Local Notation pQtoC := (map_poly ratr).

Local Hint Resolve (@intr_inj algC_numIdomainType).
Local Notation QtoC_M := (ratr_rmorphism algC_numFieldType).

Notation negz x := (ssrnum.Num.Def.ltr x 0).

(* More axiom reconstruction... *)
Lemma algC_archimedean x : 0 <= x -> {n | n%:R <= x & x < n.+1%:R}.
Proof.
have trichotomy01 y: 0 <= y -> 1 <= y \/ y <= 1.
  move=> y_ge0; rewrite -leC_sub -(leC_sub y) -opprB posC_opp.
  by apply/realC_leP; rewrite /isRealC rmorphB rmorph1 posC_conjK.
move=> pos_x; suffices /ex_minnP[n lt_x_n1 min_n]: exists n, x < n.+1%:R.
  exists n => //; case Dn: n => // [n1]; rewrite -Dn.
  have /trichotomy01/orP: 0 <= x / n%:R by rewrite posC_div ?posC_nat.
  have n_gt0: 0 < n%:R by [rewrite -(ltn_ltC 0) Dn].
  have [nz_n _] := andP n_gt0.
  rewrite -(leC_pmul2r _ _ n_gt0) -(leC_pmul2r _ 1 n_gt0) divfK // mul1r.
  case/orP=> //; rewrite leC_eqVlt.
  case/predU1P=> [-> | ]; first exact: leC_refl.
  by rewrite Dn => /min_n; rewrite Dn ltnn.
suffices [n x_le_n]: exists n, x <= n%:R.
  by exists n; rewrite (leC_ltC_trans x_le_n) -?ltn_ltC.
have [x_ge1 | x_le1] := trichotomy01 x pos_x; last by exists 1%N.
have [p nz_p px0] := algC_algebraic x; pose n := (size p).-2.
have Dn: n.+2 = size p.
  rewrite /n -subn2 -addn2 subnK // ltnNge.
  apply: contra nz_p => /size1_polyC Dp; rewrite Dp polyC_eq0.
  by rewrite Dp /root map_polyC hornerC intr_eq0 in px0.
have xk_gt0 k: 0 < x ^+ k by rewrite sposC_exp // (ltC_leC_trans sposC1).  
exists (\sum_(i < n.+1) `|(p`_i)%R|)%N.
apply: leC_trans (_ : x <= `|lead_coef p|%:R * x) _.
  rewrite -{1}[x]mul1r leC_pmul2r ?(xk_gt0 1%N) // -(leq_leC 1) lt0n.
  by rewrite absz_eq0 lead_coef_eq0.
rewrite -[_ * x]subr0 -(leC_pmul2r _ _ (xk_gt0 n)) mulrBl mul0r -mulrA.
rewrite -exprS -(mulr0 ((-1) ^+ negz (lead_coef p))) -(eqP px0).
rewrite horner_coef size_map_inj_poly // lead_coefE -Dn big_ord_recr coef_map.
move: p`_n.+1 => a /=; rewrite addrC {2}[a]intEsign mulrDr.
rewrite !rmorphM rmorph_sign -mulrA signrMK opprD addrNK mulr_sumr.
rewrite -leC_sub opprK natr_sum mulr_suml -big_split /= posC_sum // => i _.
rewrite coef_map {2}[p`_i]intEsign /= rmorphM rmorph_sign !mulrA -signr_addb.
rewrite -mulrA mulrCA -mulrDr posC_mul ?posC_nat // mulr_sign.
case: ifP => _; last by rewrite posC_add ?ltCW.
rewrite leC_sub -{2}(subnK (leq_ord i)) -[x ^+ i]mul1r exprD.
by case: (n - i)%N => [|k]; rewrite ?leC_refl // leC_pmul2r // leC1exp.
Qed.

(* Countability. *)
Lemma algC_countMixin : Countable.mixin_of algC.
Proof.
pose code x :=
  let p := s2val (sig2_eqW (algC_algebraic x)) in
  (p : seq int, index x (sval (closed_field_poly_normal (pZtoC p)))).
pose decode pi :=
  (sval (closed_field_poly_normal (Poly (map ZtoC pi.1))))`_(pi.2).
apply: CanCountMixin (code) (decode) _ => x; rewrite {}/decode {code}/=.
rewrite -map_polyE; case: (sig2_eqW _) => p /= nz_p px0.
case: (closed_field_poly_normal _) => r /= Dp; apply: nth_index.
have nz_a: lead_coef (pZtoC p) != 0.
  by rewrite lead_coef_map_inj // intr_eq0 lead_coef_eq0.
by rewrite -root_prod_XsubC -(rootZ _ _ nz_a) -Dp.
Qed.

Module Import AlgCcountable.
(* This must be file-local, as it makes algC into THE canonical countable *)
(* closedFieldType.                                                         *)
Canonical algC_countType := CountType algC algC_countMixin.
End AlgCcountable.

(* Integer subring; this should replace isIntC / getIntC. *)
Lemma isIntC_int (m : int) : isIntC m%:~R.
Proof.
by rewrite [m]intEsign rmorphM rmorph_sign isIntC_mul_sign isIntC_nat.
Qed.

Definition getCint z := (-1) ^+ (z < 0)%R * (getNatC `|z|)%:Z.
Local Notation CtoZ := getCint.

Lemma getCintK z : isIntC z -> {for z, cancel CtoZ ZtoC}.
Proof.
rewrite /{for z, _} /= => Zz; rewrite rmorphM rmorph_sign /= -pmulrn.
by rewrite -(eqP (normIntC_Nat Zz)) -isIntC_signE.
Qed.

Lemma CintrK : cancel ZtoC CtoZ. 
Proof.
move=> z; rewrite [z]intEsign rmorphM rmorph_sign /= /getCint.
rewrite normC_mul_sign normC_nat getNatC_nat; congr (_ ^+ _ * _).
case: z => n; first by rewrite mul1r leC_gtF ?posC_nat.
by rewrite -sposC_opp mulN1r opprK -(ltn_ltC 0).
Qed.

Lemma rpred_Cnat S (ringS : semiringPred S) (kS : keyed_pred ringS) x :
  isNatC x -> x \in kS.
Proof. by case/isNatCP=> n ->; apply: rpred_nat. Qed.

Lemma rpred_Cint S (ringS : subringPred S) (kS : keyed_pred ringS) x :
  isIntC x -> x \in kS.
Proof. by move/getCintK <-; apply: rpred_int. Qed.

Lemma getCint0 : CtoZ 0 = 0. Proof. exact: (CintrK 0). Qed.
Hint Resolve getCint0.

Lemma getCintpK (p : {poly algC}) :
  all isIntC p -> pZtoC (map_poly CtoZ p) = p.
Proof.
move/(all_nthP 0)=> Zp; apply/polyP=> i.
rewrite coef_map coef_map_id0 //= -[p]coefK coef_poly.
by case: ifP => [/Zp/getCintK// | _]; rewrite getCint0.
Qed.

Lemma getCintpP (p : {poly algC}) : all isIntC p -> {q | p = pZtoC q}.
Proof. by exists (map_poly CtoZ p); rewrite getCintpK. Qed.

(* Reconstructed rational subring. *)
(* Note that this proof is tweaked so that it depends only on the fact that *)
(* QtoC is a field embedding, and not on the order structure assumed for C. *)
(* Thus, it could be used in (and moved to) the construction of C.          *)
Fact getCrat_subproof : {CtoQ | cancel QtoC CtoQ}.
Proof.
have QtoCinj: injective QtoC by exact: fmorph_inj.
have ZtoQinj: injective ZtoQ by exact: intr_inj.
have defZtoC: ZtoC =1 QtoC \o ZtoQ by move=> m; rewrite /= rmorph_int.
suffices CtoQ x: {xa : seq rat | forall a, x = QtoC a -> a \in xa}.
  exists (fun x => let: exist xa _ := CtoQ x in xa`_(index x (map QtoC xa))).
  move=> a /=; case: (CtoQ _) => xa /= /(_ a (erefl _)) xa_a; apply: QtoCinj.
  by rewrite -(nth_map _ 0) ?nth_index -?(size_map QtoC) ?index_mem ?map_f.
have [-> | nz_x] := eqVneq x 0.
  by exists [:: 0] => a; rewrite inE -(inj_eq QtoCinj) rmorph0 => <-.
have /sig2_eqW[p nz_p px0] := algC_algebraic x.
without loss{nz_x} nz_p0: p nz_p px0 / p`_0 != 0.
  move=> IH; elim/poly_ind: p nz_p => [/eqP// | p a IHp nz_p] in px0.
  have [a0 | nz_a] := eqVneq a 0; last first.
    by apply: IH nz_p px0 _; rewrite coefD coefC coefMX add0r.
  rewrite a0 addr0 mulrC mulf_eq0 -size_poly_eq0 size_polyX in nz_p px0.
  apply: IHp nz_p _; rewrite rmorphM rootM /= map_polyX in px0.
  by rewrite {1}/root hornerX (negPf nz_x) in px0.
pose p_n := lead_coef p; pose q e m : rat := (-1) ^+ e * m%:R / `|p_n|%:R.
exists [seq q e m | e <- iota 0 2, m <- divisors `|p_n * p`_0|] => a Dx.
rewrite {x}Dx (eq_map_poly defZtoC) map_poly_comp fmorph_root /root in px0.
have [n Dn]: {n | size p = n.+2}.
  exists (size p - 2)%N; rewrite -addn2 subnK // ltnNge. 
  apply: contra nz_p => /size1_polyC Dp; rewrite Dp polyC_eq0.
  by rewrite Dp map_polyC hornerC intr_eq0 in px0.
pose qn (c : int) m := c * (m ^ n.+1)%N.
pose Eqn (c0 c1 c2 : int) d m := qn c0 d + qn c1 m = c2 * d * m.
have Eqn_div c1 c2 d m c0: coprime m d -> Eqn c0 c1 c2 d m -> (m %| `|c0|)%N.
  move=> co_m_d /(canRL (addrK _))/(congr1 (dvdn m \o absz))/=.
  rewrite abszM mulnC Gauss_dvdr ?coprime_expr // => ->.
  by rewrite -mulNr expnSr PoszM mulrA -mulrDl abszM dvdn_mull.
pose m := numq a; pose d := `|denq a|%N.
have co_md: coprime `|m| d by exact: coprime_num_den.
have Dd: denq a = d by rewrite /d; case: (denq a) (denq_gt0 a).
have{px0} [c Dc1 Emd]: {c | `|c.1|%N = `|p_n|%N & Eqn p`_0 c.1 c.2 d `|m|%N}.
  pose e : int := (-1) ^+ negz m.
  pose r := \sum_(i < n) p`_i.+1 * m ^+ i * (d ^ (n - i.+1))%N.
  exists (e ^+ n.+1 * p_n, - (r * e)); first by rewrite -exprM abszMsign.
  apply/eqP; rewrite !mulNr -addr_eq0 (mulrAC r) -!mulrA -intEsign addrAC.
  apply/eqP; transitivity (\sum_(i < n.+2) p`_i * m ^+ i * (d ^ (n.+1 - i))%N).
    rewrite big_ord_recr big_ord_recl subnn !mulr1; congr (_ + _ + _).
      rewrite mulr_suml; apply: eq_bigr => i _; rewrite -!mulrA; congr (_ * _).
      by rewrite /= mulrC -!mulrA -exprS mulrA -PoszM -expnSr mulrC -subSn.
    rewrite /qn /p_n lead_coefE Dn mulrAC mulrC; congr (_ * _).
    rewrite -[Posz (_ ^ _)]intz -pmulrn natrX pmulrn intz.
    by rewrite -exprMn -intEsign.
  apply: (ZtoQinj); rewrite rmorph0 -(mul0r (ZtoQ (d ^ n.+1)%N)) -(eqP px0).
  rewrite rmorph_sum horner_coef (size_map_inj_poly ZtoQinj) // Dn mulr_suml.
  apply: eq_bigr => i _; rewrite coef_map !rmorphM !rmorphX /= numqE Dd.
  by rewrite -!pmulrn !natrX exprMn -!mulrA -exprD subnKC ?leq_ord.
have{Dc1} /dvdnP[d1 Dp_n]: (d %| `|p_n|)%N.
  rewrite -Dc1 (Eqn_div p`_0 c.2 `|m|%N) 1?coprime_sym //.
  by rewrite /Eqn mulrAC addrC //.
have [d1_gt0 _]: (0 < d1 /\ 0 < d)%N.
  by apply/andP; rewrite -muln_gt0 -Dp_n absz_gt0 lead_coef_eq0. 
have dv_md1_p0n: (`|m| * d1 %| `|p_n| * `|(p`_0)%R|)%N.
  by rewrite Dp_n mulnC -mulnA dvdn_pmul2l ?dvdn_mull // (Eqn_div c.1 c.2 d).
apply/allpairsP; exists (negz m : nat, `|m| * d1)%N.
rewrite mem_iota ltnS leq_b1; split=> //.
  by rewrite abszM -dvdn_divisors // muln_gt0 !absz_gt0 lead_coef_eq0 nz_p.
rewrite /q Dp_n !natrM invfM !mulrA !pmulrn -rmorphMsign -intEsign /=.
by rewrite -Dd mulfK ?divq_num_den // intr_eq0 -lt0n.
Qed.

Definition getCrat := sval getCrat_subproof.
Local Notation CtoQ := getCrat.
Definition Crat : pred algC := (fun x => x == QtoC (CtoQ x)).
Fact Crat_key : pred_key Crat. Proof. by []. Qed.
Canonical Crat_keyed := KeyedPred Crat_key.

Lemma CratrK : cancel QtoC CtoQ.
Proof. by rewrite /getCrat; case: getCrat_subproof. Qed.

Lemma getCratK : {in Crat, cancel CtoQ QtoC}.
Proof. by move=> x /eqP. Qed.

Lemma ratr_Crat (a : rat) : QtoC a \in Crat.
Proof. by rewrite unfold_in /Crat CratrK. Qed.

Lemma CratP x : reflect (exists a, x = QtoC a) (x \in Crat).
Proof.
by apply: (iffP eqP) => [-> | [a ->]]; [exists (CtoQ x) | rewrite CratrK].
Qed.

Lemma Crat0 : 0 \in Crat. Proof. by apply/CratP; exists 0; rewrite rmorph0. Qed.
Lemma Crat1 : 1 \in Crat. Proof. by apply/CratP; exists 1; rewrite rmorph1. Qed.
Hint Resolve Crat0 Crat1.

Fact Crat_divring_closed : divring_closed Crat.
Proof.
split=> // _ _ /CratP[x ->] /CratP[y ->].
  by rewrite -rmorphB ratr_Crat.
by rewrite -fmorph_div ratr_Crat.
Qed.
Canonical Crat_opprPred := OpprPred Crat_divring_closed.
Canonical Crat_addrPred := AddrPred Crat_divring_closed.
Canonical Crat_mulrPred := MulrPred Crat_divring_closed.
Canonical Crat_zmodPred := ZmodPred Crat_divring_closed.
Canonical Crat_semiringPred := SemiringPred Crat_divring_closed.
Canonical Crat_smulrPred := SmulrPred Crat_divring_closed.
Canonical Crat_divrPred := DivrPred Crat_divring_closed.
Canonical Crat_subringPred := SubringPred Crat_divring_closed.
Canonical Crat_sdivrPred := SdivrPred Crat_divring_closed.
Canonical Crat_divringPred := DivringPred Crat_divring_closed.

Lemma rpred_Crat S (ringS : divringPred S) (kS : keyed_pred ringS) :
  {subset Crat <= kS}.
Proof. by move=> _ /CratP[a ->]; apply: rpred_rat. Qed.

Lemma CratV x : (x^-1 \in Crat) = (x \in Crat).
Proof. exact: rpredV. Qed.

Lemma CratXz m : {in Crat, forall x, x ^ m \in Crat}.
Proof. exact: rpredXint. Qed.

Lemma Crat_div : {in Crat &, forall x y, x / y \in Crat}.
Proof. exact: rpred_div. Qed.

Lemma conj_Crat z : z \in Crat -> z^* = z.
Proof. by move/getCratK <-; rewrite fmorph_div !rmorph_int. Qed.

Lemma Creal_Rat z : z \in Crat -> isRealC z.
Proof. by move/conj_Crat/eqP. Qed.

Lemma Cint_ratr a : isIntC (QtoC a) = (a \in Qint).
Proof.
apply/idP/idP=> [Za | /numqK <-]; last by rewrite rmorph_int isIntC_int.
apply/QintP; exists (CtoZ (QtoC a)); apply: (can_inj CratrK).
by rewrite rmorph_int getCintK.
Qed.

(* Minimal polynomial. *)
Fact minCpoly_subproof (x : algC) :
  {p | p \is monic & forall q, root (pQtoC q) x = (p %| q)%R}.
Proof.
have /sig2_eqW[p0 nz_p0 p0x] := algC_algebraic x.
have [r Dp0] := closed_field_poly_normal (pZtoC p0).
do [rewrite lead_coef_map_inj //; set d0 := _%:~R] in Dp0.
have{nz_p0} nz_d0: d0 != 0 by rewrite intr_eq0 lead_coef_eq0.
have r_x: x \in r by rewrite Dp0 rootZ // root_prod_XsubC in p0x.
pose p_ (I : {set 'I_(size r)}) := \prod_(i <- enum I) ('X - (r`_i)%:P).
pose Qpx I := root (p_ I) x && all (mem Crat) (p_ I).
have{d0 p0 nz_d0 p0x Dp0} /minset_exists[I /minsetP[]]: Qpx setT.
  rewrite /Qpx; have ->: p_ setT = d0^-1 *: intrp p0.
     rewrite Dp0 scalerK // (big_nth 0) big_mkord /p_ big_filter /=.
     by apply: eq_bigl => i; rewrite inE.
   rewrite rootZ ?invr_eq0 // p0x; apply/(all_nthP 0)=> i _ /=.
   by rewrite coefZ mulrC coef_map Crat_div ?rpred_int.
case/andP=> pIx QpI minI _; pose p := map_poly CtoQ (p_ I).
have DpI: p_ I = pQtoC p.
  rewrite -[p_ I]coefK; apply/polyP=> i; rewrite -map_poly_comp !coef_poly.
  by case: ifP => //= lti_pI; rewrite getCratK //; exact: (all_nthP 0 QpI).
exists p; first by rewrite -(map_monic QtoC_M) -DpI monic_prod_XsubC.
move=> q; rewrite -(dvdp_map QtoC_M) -DpI.
apply/idP/idP=> [qx0 | /dvdpP[{q} q ->]]; last by rewrite rootM pIx orbT.
pose q1 := gcdp p q; have /dvdp_prod_XsubC[m Dq1]: pQtoC q1 %| p_ I.
  by rewrite gcdp_map DpI dvdp_gcdl.
pose B := [set i \in mask m (enum I)].
have{Dq1} Dq1: pQtoC q1 %= p_ B.
  congr (_ %= _): Dq1; apply: eq_big_perm.
  by rewrite uniq_perm_eq ?mask_uniq ?enum_uniq // => i; rewrite mem_enum inE.
rewrite -(minI B); first by rewrite -(eqp_dvdl _ Dq1) gcdp_map dvdp_gcdr.
  rewrite /Qpx -(eqp_root Dq1) gcdp_map root_gcd qx0 -DpI pIx.
  have{Dq1} /eqpP[[d1 d2] /= /andP[nz_d1 nz_d2] Dq1] := Dq1.
  rewrite -[p_ B](scalerK nz_d2) -Dq1 scalerA mulrC.
  have ->: d1 / d2 = (QtoC (lead_coef q1))^-1.
    have:= congr1 lead_coef Dq1; rewrite !lead_coefZ lead_coef_map.
    rewrite (monicP (monic_prod_XsubC _ _ _)) mulr1 => <-.
    by rewrite invfM mulVKf.
  apply/(all_nthP 0)=> i _; rewrite coefZ coef_map mulrC /=.
  by rewrite Crat_div ?ratr_Crat.
by apply/subsetP=> i; rewrite inE => /mem_mask; rewrite mem_enum.
Qed.

Definition minCpoly x : {poly algC} :=
  locked (pQtoC (s2val (minCpoly_subproof x))).

Lemma minCpolyP x :
   {p | minCpoly x = pQtoC p /\ p \is monic
      & forall q, root (pQtoC q) x = (p %| q)}.
Proof. by unlock minCpoly; case: (minCpoly_subproof x) => p /=; exists p. Qed.

Lemma minCpoly_monic x : minCpoly x \is monic.
Proof. by have [p [-> mon_p] _] := minCpolyP x; rewrite map_monic. Qed.

Lemma minCpoly_eq0 x : (minCpoly x == 0) = false.
Proof. exact/negbTE/monic_neq0/minCpoly_monic. Qed.

Lemma root_minCpoly x : root (minCpoly x) x.
Proof. by have [p [-> _] ->] := minCpolyP x. Qed.

Lemma size_minCpoly x : (1 < size (minCpoly x))%N.
Proof.
apply: contraFT (minCpoly_eq0 x); rewrite -leqNgt => /size1_polyC Dp.
by have /eqP := root_minCpoly x; rewrite Dp hornerC => ->.
Qed.

Section MoreAlgCaut.

Implicit Type nu : {rmorphism algC -> algC}.

Lemma Crat_aut nu x : (nu x \in Crat) = (x \in Crat).
Proof.
apply/idP/idP=> /CratP[a] => [|->]; last by rewrite fmorph_rat ratr_Crat.
by rewrite -(fmorph_rat nu) => /fmorph_inj->; apply: ratr_Crat.
Qed.

Lemma aut_Crat nu : {in Crat, nu =1 id}.
Proof. by move=> _ /CratP[a ->]; apply: fmorph_rat. Qed.

Lemma algC_invaut_subproof nu x : {y | nu y = x}.
Proof.
have [r Dp] := closed_field_poly_normal (minCpoly x).
suffices /mapP/sig2_eqW[y _ ->]: x \in map nu r by exists y.
rewrite -root_prod_XsubC; congr (root _ x): (root_minCpoly x).
have [q [Dq _] _] := minCpolyP x; rewrite Dq -(eq_map_poly (fmorph_rat nu)).
rewrite (map_poly_comp nu) -{q}Dq Dp (monicP (minCpoly_monic x)) scale1r.
rewrite rmorph_prod big_map; apply: eq_bigr => z _.
by rewrite rmorphB /= map_polyX map_polyC.
Qed.
Definition algC_invaut nu x := sval (algC_invaut_subproof nu x).

Lemma algC_invautK nu : cancel (algC_invaut nu) nu.
Proof. by move=> x; rewrite /algC_invaut; case: algC_invaut_subproof. Qed.

Lemma algC_autK nu : cancel nu (algC_invaut nu).
Proof. exact: inj_can_sym (algC_invautK nu) (fmorph_inj nu). Qed.

Fact algC_invaut_is_rmorphism nu : rmorphism (algC_invaut nu).
Proof. exact: can2_rmorphism (algC_autK nu) (algC_invautK nu). Qed.
Canonical algC_invaut_additive nu := Additive (algC_invaut_is_rmorphism nu).
Canonical algC_invaut_rmorphism nu := RMorphism (algC_invaut_is_rmorphism nu).

Lemma isNatC_rmorph nu x : isNatC (nu x) = isNatC x.
Proof.
by do [apply/idP/idP=> Nx; have:= rmorph_NatC nu Nx] => [/fmorph_inj <- | ->].
Qed.

Lemma isIntC_rmorph nu x : isIntC (nu x) = isIntC x.
Proof. by rewrite !isIntCE -rmorphN !isNatC_rmorph. Qed.

Lemma minCpoly_aut nu x : minCpoly (nu x) = minCpoly x.
Proof.
wlog suffices dvd_nu: nu x / minCpoly x %| minCpoly (nu x).
  apply/eqP; rewrite -eqp_monic ?minCpoly_monic //; apply/andP; split=> //.
  by rewrite -{2}(algC_autK nu x) dvd_nu.
have [[q [Dq _] min_q] [q1 [Dq1 _] _]] := (minCpolyP x, minCpolyP (nu x)).
rewrite Dq Dq1 dvdp_map -min_q -(fmorph_root nu) -map_poly_comp.
by rewrite (eq_map_poly (fmorph_rat nu)) -Dq1 root_minCpoly.
Qed.

End MoreAlgCaut.
