Require Import ssreflect ssrbool ssrfun eqtype ssrnat seq div choice fintype.
Require Import tuple finfun bigop ssralg poly polydiv.
Require Import finset fingroup zmodp morphism perm quotient cyclic.
Require Import matrix mxalgebra vector falgebra fieldext separable.

(******************************************************************************)
(*                                                                            *)
(*splittingFieldFor K p E == E is the smallest field over K that splits p into*)
(*                           linear factors.                                  *)
(*       f \is a kHom K E == (f:'End(L)) is a ring morphism on E and fixes K. *)
(*       f \is a kAut K E == (f:'End(L)) is a kHom K E and f @: E == E.       *)
(*     kHomExtend E f x y == given f \is a kHom K E and root (minPoly E x) y  *)
(*                           then kHomExtend E f x y \is a kHom K <<E; x>>    *)
(*                           that extends f and maps x to y                   *)
(*                                                                            *)
(*   splittingFieldType F == the interface type of splitting field extensions *)
(*                           of F.  The field extensions must be generated by *)
(*                           all the algebraic roots of some polynomial.      *)
(*                           It is the same as being a normal field extension.*)
(* SplittingField.axiom F L == the axiom needed for a L to be splitting field.*)
(* SplittingFieldType F L a == packs the splitting field axiom a into a       *)
(*                           splitingFieldType F for L : fieldExtType F.      *)
(*[splittingFieldType F of L] == a clone of the canonical SplittingFieldType F*)
(*                               structure for L.                             *)
(*[splittingFieldType F of L for M] == I have no idea what this is for.       *)
(*                                                                            *)
(*               gal_of E == The group_type of automorphisms of E over the    *)
(*                           base field.                                      *)
(*            'Gal(E / K) == the group of automorphisms of E that fix K.      *)
(*           fixedField s == The field fixed by the set of automorphisms s.   *)
(*                           fixedField set0 = E when set0 : {set: gal_of E}  *)
(*        normalField K E == E is invariant for every 'Gal(L / K) for every L.*)
(*             galois K E == E is a normal and separable field extension of K.*)
(*         galTrace K E a == \sum_(f in 'Gal(E / K)) (f a).                   *)
(*          galNorm K E a == \prod_(f in 'Gal(E / K)) (f a).                  *)
(*                                                                            *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Reserved Notation "''Gal' ( A / B )"
  (at level 8, A at level 2, format "''Gal' ( A  /  B )").

Open Local Scope ring_scope.
Import GRing.Theory.

Section SplittingFieldFor.

Variables (F : fieldType) (L : fieldExtType F).

Definition splittingFieldFor (U : {vspace L}) (p : {poly L}) (V : {vspace L}) :=
  exists2 rs, p %= \prod_(z <- rs) ('X - z%:P) & <<U & rs>>%AS = V.

Lemma splittingFieldForS (K M E : {subfield L}) p :
  (K <= M <= E)%VS -> splittingFieldFor K p E -> splittingFieldFor M p E.
Proof.
case/andP => sKM sKE [rs Dp genL]; exists rs => //; apply/eqP.
rewrite eqEsubv -[in X in _ && (X <= _)%VS]genL adjoin_seqSl // andbT.
apply/Fadjoin_seqP; split; first done.
rewrite -genL.
apply: seqv_sub_adjoin.
Qed.

End SplittingFieldFor.

Section kHom.

Variable F : fieldType.
Variable L : fieldExtType F.

Implicit Types (U V : {vspace L}).
Implicit Types (K E : {subfield L}).
Implicit Types (f g : 'End(L)).

(* Should I make this canonical by setting fixing (f @: E)^C ? *)
Definition kHom U V :=
  [qualify a f : 'End(L) | (U <= fixedSpace f)%VS && (f \is ahom_in V)].

Lemma kHom1 U V : \1%VF \is a kHom U V.
Proof.
rewrite qualifE (id_is_ahom V) andbT.
apply/subvP => u _.
apply/fixedSpaceP.
by rewrite id_lfunE.
Qed.

Lemma kHomP K V f :
 reflect ({in K, forall x, f x = x} /\
          {in V &, forall x y, f (x * y) = f x * f y})
 (f \is a kHom K V).
Proof.
apply: (iffP andP); case.
  move/subvP => HK /is_ahom_inP [HV _].
  split; last done.
  move => x Hx.
  apply/fixedSpaceP.
  by apply: HK.
move => HK HV.
split.
  apply/subvP => v Hv.
  apply/fixedSpaceP.
  by apply HK.
apply/is_ahom_inP; split; first done.
apply: HK.
by rewrite mem1v.
Qed.

Lemma kHomFixedPoly K E f p : f \is a kHom K E -> p \is a polyOver K ->
  map_poly f p = p.
Proof.
case/kHomP => HK _ /polyOverP Hp.
by apply/polyP => i; rewrite coef_map /= HK ?Hp.
Qed.

Definition kAut U V := [qualify a f | (f \is a kHom U V) && (f @: V == V)%VS].

Fact kHomExtendF_subproof E f x y :
  linear (fun z => (map_poly f (poly_for_Fadjoin E x z)).[y]).
Proof.
move=> k a b; rewrite linearP /= raddfD hornerE; congr (_ + _).
rewrite -[rhs in _ = rhs]mulr_algl -hornerZ /=; congr _.[_].
by apply/polyP => i; rewrite !(coefZ, coef_map) /= !mulr_algl linearZ.
Qed.
Definition kHomExtend E f x y := linfun (Linear (kHomExtendF_subproof E f x y)).

Lemma kHomExtendE E f x y z :
  kHomExtend E f x y z = (map_poly f (poly_for_Fadjoin E x z)).[y].
Proof. by rewrite lfunE. Qed.

Lemma kHomSl U1 U2 V f : (U1 <= U2)%VS -> f \in kHom U2 V -> f \in kHom U1 V.
Proof.
move => HU.
case/andP => HU2 HV.
apply/andP.
by rewrite (subv_trans _ HU2).
Qed.

Lemma kHomSr K V1 V2 f : (V1 <= V2)%VS -> f \in kHom K V2 -> f \in kHom K V1.
Proof.
move/subvP => HV.
case/kHomP => HK HV2.
apply/kHomP; split => // x y Hx Hy.
by apply: HV2; apply: HV.
Qed.

Lemma kHomS K1 K2 V1 V2 f : (K1 <= K2)%VS -> (V1 <= V2)%VS ->
  f \in kHom K2 V2 -> f \in kHom K1 V1.
Proof. by move => HK HV /(kHomSl HK); apply kHomSr. Qed.

Lemma kHom_eq K E f g : (K <= E)%VS -> {in E, f =1 g} ->
  (f \is a kHom K E) = (g \is a kHom K E).
Proof.
move => HKE Hfg.
wlog suff: f g Hfg / f \is a kHom K E -> g \is a kHom K E.
  move => H.
  apply/idP/idP; first by apply: H.
  by apply: H => ? ?; symmetry; apply Hfg.
move => /kHomP [HfK HfE].
apply/kHomP; split => [a Ha | a b Ha Hb].
  rewrite /= -Hfg ?HfK //.
  by move/subvP: HKE; apply.
by rewrite -!Hfg ?HfE ?rpredM.
Qed.

Lemma kHom_inv K E f : f \in kHom K E -> forall x, x \in E -> f x^-1 = (f x)^-1.
Proof.
case/kHomP => HK HE.
move => x Hx.
case (eqVneq x 0) => [->|Hx0]; first by rewrite linear0 invr0 linear0.
move: (Hx).
rewrite -rpredV.
move/(HE _ _ Hx).
rewrite divff // HK ?mem1v // => H1.
rewrite -[(f x)^-1]mulr1 H1 mulrA mulVf ?mul1r //.
move/eqP: H1.
apply: contraL.
move/eqP ->.
by rewrite mul0r oner_neq0.
Qed.

Lemma kHom_dim K E f : f \in kHom K E -> \dim (f @: E) = \dim E.
Proof.
move => Hf.
case/kHomP: (Hf) => HK HE.
apply/limg_dim_eq/eqP.
rewrite -subv0.
apply/subvP => v.
rewrite memv_cap memv0 memv_ker.
case/andP => HvE.
apply: contraLR => Hv.
by rewrite -unitfE unitrE -(kHom_inv Hf) // -HE ?rpredV // mulfV // HK // mem1v.
Qed.

Lemma kHomRmorph_subproof K E f : f \in kHom K E ->
  rmorphism (f \o @vsval _ _ E).
Proof.
case/kHomP => HK HE.
split; first by move => a b; rewrite /= linearB.
split; first by move => a b; rewrite /= HE // subvsP.
by rewrite /= algid1 HK // mem1v.
Qed.

Lemma kHom_horner K E f p x : f \in kHom K E ->
  p \is a polyOver E -> x \in E -> f p.[x] = (map_poly f p).[f x].
Proof.
move => Hf /polyOver_subvs [{p}p -> Ex]; rewrite (horner_map _ _ (Subvs Ex)).
rewrite -[f _](horner_map (RMorphism (kHomRmorph_subproof Hf))).
by rewrite map_poly_comp.
Qed.

Lemma kHom_root K E f p x : f \in kHom K E -> 
  p \is a polyOver E -> x \in E -> root p x -> root (map_poly f p) (f x).
Proof.
by move=> Hf Ep Ex /rootP px0; rewrite /root -(kHom_horner Hf) // px0 linear0.
Qed.

Lemma kHom_rootK K E f p x : (K <= E)%VS -> f \in kHom K E ->
  p \is a polyOver K -> x \in E -> root p x -> root p (f x).
Proof.
move=> HKE Hf Kp Ex /(kHom_root Hf); rewrite (kHomFixedPoly Hf) //.
by apply; rewrite ?(polyOverSv HKE).
Qed.

Section kHomExtend.

Variables (K E : {subfield L}) (f : 'End(L)) (x y : L).
Hypothesis HKE :  (K <= E)%VS.
Hypothesis Hf : f \in kHom K E.
Hypothesis Hy : root (map_poly f (minPoly E x)) y.

Lemma kHomExtendExt z : z \in E -> kHomExtend E f x y z = f z.
Proof. move => Hz. by rewrite kHomExtendE poly_for_K // map_polyC hornerC. Qed.

Lemma kHomExtendX : kHomExtend E f x y x = y.
Proof.
case: (boolP (x \in E)) => [xinE|xnotinE]; last first.
  rewrite kHomExtendE poly_for_X //.
  by rewrite (kHomFixedPoly Hf) ?hornerX ?polyOverX.
move: Hy.
rewrite /root (minPoly_in_K _ _ xinE) (kHomExtendExt xinE).
rewrite map_poly_is_additive map_polyC /= hornerD hornerN hornerC subr_eq0.
move/eqP <-.
rewrite horner_poly size_polyX !big_ord_recl big_ord0.
rewrite !coefX expr0 expr1 addr0 mulr1 linear0 add0r.
case/kHomP: Hf => /(_ 1) ->; last by apply: mem1v.
by rewrite mul1r.
Qed.

Lemma kHomExtend_poly p :
  p \in polyOver E -> kHomExtend E f x y (p.[x]) = (map_poly f p).[y].
Proof.
move => Hp.
rewrite kHomExtendE.
move/(poly_for_modp x): (Hp) ->.
case/kHomP: Hf => HK HE.
have Hfmin : map_poly f (minPoly E x) \is monic.
  by rewrite monicE lead_coef_map_eq;
     move/eqP: (monic_minPoly E x) ->;
     rewrite /= HK ?mem1v // oner_neq0.
rewrite (divp_eq (map_poly f p) (map_poly f (minPoly E x))) !hornerE.
move/eqP: Hy ->.
rewrite mulr0 add0r.
case/polyOver_subvs: Hp => p' ->.
case/polyOver_subvs: (minPolyOver E x) => q' ->.
rewrite -map_modp -!map_poly_comp ?linear0 //=.
by rewrite (map_modp (RMorphism (kHomRmorph_subproof Hf))) !map_polyE /=.
Qed.

Lemma kHomExtendkHom : kHomExtend E f x y \is a kHom K <<E; x>>%AS .
Proof.
case/kHomP: Hf => HK HE.
move/subvP: HKE => HKE'.
apply/kHomP; split.
  move => z Hz.
  rewrite /= kHomExtendE.
  move/HKE'/poly_for_K: (Hz) ->.
  by rewrite map_polyC hornerC /= HK.
move => a b.
case/poly_Fadjoin => p Hp ->.
case/poly_Fadjoin => q Hq ->.
rewrite -hornerM !kHomExtend_poly ?rpredM // -hornerM.
congr (_.[_]).
apply/polyP => i.
rewrite coef_map !coefM /= linear_sum.
apply: eq_bigr => j _.
by rewrite !coef_map /= HE ?(polyOverP _).
Qed.

End kHomExtend.

Lemma kAutE K E f : f \is a kAut K E = (f \is a kHom K E) && (f @: E <= E)%VS.
Proof.
apply/andP/andP; case => Hhom; first by move/eqP->.
move => HfE; split => //.
by rewrite -(dimv_leqif_eq HfE) (kHom_dim Hhom).
Qed.

Lemma kAutS U1 U2 V f : (U1 <= U2)%VS -> f \in kAut U2 V -> f \in kAut U1 V.
Proof.
move => HU.
case/andP => HU2 HE.
apply/andP.
by rewrite (kHomSl _ HU2).
Qed.

Lemma kHom_kAut_sub K E : {subset kAut K E <= kHom K E}.
Proof. by move => f /andP []. Qed.

Lemma kAut_eq K E (f g : 'End(L)) : (K <= E)%VS -> {in E, f =1 g} ->
  (f \is a kAut K E) = (g \is a kAut K E).
Proof.
move => HKE Hfg.
rewrite !kAutE (kHom_eq HKE Hfg).
case:(g \is a kHom K E) => /=; last done.
wlog suff: f g Hfg / (f @: E <= E -> g @:E <= E)%VS.
  move => H.
  apply/idP/idP; first by apply: H.
  by apply: H => ? ?; symmetry; apply Hfg.
move/subvP => HfE.
apply/subvP => ? /memv_imgP [a Ha ->].
rewrite -Hfg //.
apply: HfE.
by apply: memv_img.
Qed.

Lemma kHomL_kAutL K : kHom K {:L} =i kAut K {:L}.
Proof.
move => f.
apply: (sameP idP); apply: (iffP idP); first by apply: kHom_kAut_sub.
by move => Hf; rewrite kAutE Hf subvf.
Qed.

Lemma fAutL_lrmorph (f : 'End(L)) :
  reflect (lrmorphism f) (f \is a kHom 1 {:L}).
Proof.
apply: (iffP (kHomP _ _ _)).
  case => HF HL.
  apply/is_ahomP/is_ahom_inP.
  split; first by apply: HL.
  by apply: HF; rewrite mem1v.
move => Hf.
split; last by move => x y _ _; apply: (rmorphM (RMorphism Hf)).
move => ?; case/vlineP => k ->.
rewrite linearZ /=.
by rewrite [f 1](rmorph1 (RMorphism Hf)).
Qed.

Lemma fAutL_is_kHom (f : 'AEnd(L)) : val f \is a kHom 1 {:L}.
Proof. by apply/fAutL_lrmorph; apply: lrmorphismP. Qed.

Lemma kAutL_lker0 K f : f \is a kHom K {:L} -> lker f == 0%VS.
Proof.
move/(kHomSl (sub1v _))/fAutL_lrmorph=> fM.
by apply/lker0P; exact: (fmorph_inj (RMorphism fM)).
Qed.

Lemma fAutL_lker0 (f : 'AEnd(L)) : lker f == 0%VS.
Proof. by move: (fAutL_is_kHom f); apply: kAutL_lker0. Qed.

Lemma inv_kAutL K f : f \is a kHom K {:L} -> f^-1%VF \is a kHom K {:L}.
Proof.
move=> homFf; have [/kHomP[fKid fM] kerf0] := (homFf, kAutL_lker0 homFf).
have f1K: cancel f^-1%VF f by exact: lker0_lfunVK.
apply/kHomP; split=> [x Kx | x y _ _]; apply: (lker0P kerf0).
  by rewrite f1K fKid.
by rewrite fM ?memvf ?{1}f1K.
Qed.

Lemma inv_fAutL_in (f : 'AEnd(L)) : f^-1%VF \is ahom_in {:L} .
Proof.
move/is_ahomP/fAutL_lrmorph: (valP f) => Hf.
apply/is_ahomP/fAutL_lrmorph.
by apply: inv_kAutL.
Qed.

Canonical inv_fAutL (f : 'AEnd(L)) : 'AEnd(L) := AHom (inv_fAutL_in f).
Notation "f ^-1" := (inv_fAutL f) : lrfun_scope.

Lemma comp_kHom K E f g : f \is a kHom K fullv -> g \is a kHom K E ->
  (f \o g)%VF \is a kHom K E.
Proof.
move=> /kHomP[fKid fM] /kHomP[gKid gM]; apply/kHomP; split=> [x Kx | x y Ex Ey].
  by rewrite lfunE /= gKid ?fKid.
by rewrite !lfunE /= gM // fM ?memvf.
Qed.

Lemma kHom_extends K E f p U :
    (K <= E)%VS -> f \is a kHom K E ->
    p \is a polyOver K -> splittingFieldFor E p U ->
  {g | g \is a kHom K U & {in E, f =1 g}}.
Proof.
move=> sKE homEf Kp /sig2_eqW[rs Dp <-{U}]; set r := rs.
have rs_r: all (mem rs) r by exact/allP.
elim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in E f sKE homEf *.
  by exists f; rewrite ?Fadjoin_nil.
set Ez := <<E; z>>%AS; pose fpEz := map_poly f (minPoly E z).
suffices{IHr} /sigW[y fpEz_y]: exists y, root fpEz y.
  have homEz_fz: kHomExtend E f z y \is a kHom K Ez by exact: kHomExtendkHom.
  have sKEz: (K <= Ez)%VS := subv_trans sKE (subv_adjoin E z).
  have [g homGg Dg] := IHr rs_r _ _ sKEz homEz_fz.
  exists g => [|x Ex]; first by rewrite adjoin_cons.
  by rewrite -Dg ?memv_mem_adjoin // kHomExtendExt.
have [m DfpEz]: {m | fpEz %= \prod_(w <- mask m rs) ('X - w%:P)}.
  apply: dvdp_prod_XsubC; rewrite -(eqp_dvdr _ Dp) -(kHomFixedPoly homEf Kp).
  have /polyOver_subvs[q Dq] := polyOverSv sKE Kp.
  have /polyOver_subvs[qz Dqz] := minPolyOver E z.
  rewrite /fpEz Dq Dqz -2?{1}map_poly_comp.
  rewrite (dvdp_map (RMorphism (kHomRmorph_subproof homEf))).
  rewrite -(dvdp_map [rmorphism of @vsval _ _ E]) -Dqz -Dq.
  rewrite minPoly_dvdp ?(polyOverSv sKE) //.
  by rewrite (eqp_root Dp) root_prod_XsubC.
exists (mask m rs)`_0; rewrite (eqp_root DfpEz) root_prod_XsubC mem_nth //.
rewrite -ltnS -(size_prod_XsubC _ id) -(eqp_size DfpEz).
rewrite size_poly_eq ?coef_map -?lead_coefE ?size_minPoly //.
rewrite (monicP (monic_minPoly E z)).
by have /kHomP[fK _] := homEf; rewrite fK ?mem1v ?oner_eq0.
Qed.

End kHom.
Notation "f ^-1" := (inv_fAutL f) : lrfun_scope.

Module SplittingField.

Import GRing.

Section ClassDef.

Variable F : fieldType.

Definition axiom (L : fieldExtType F) :=
  exists2 p : {poly L}, p \is a polyOver 1%VS & splittingFieldFor 1%VS p {:L}.

Record class_of (L : Type) : Type :=
  Class {base : FieldExt.class_of F L; _ : axiom (FieldExt.Pack _ base L)}.
Local Coercion base : class_of >-> FieldExt.class_of.

Structure type (phF : phant F) := Pack {sort; _ : class_of sort; _ : Type}.
Local Coercion sort : type >-> Sortclass.
Variable (phF : phant F) (T : Type) (cT : type phF).
Definition class := let: Pack _ c _ as cT' := cT return class_of cT' in c.
Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition clone c of phant_id class c := @Pack phF T c T.

Definition pack b0 (ax0 : axiom (@FieldExt.Pack F (Phant F) T b0 T)) :=
 fun bT b & phant_id (@FieldExt.class F phF bT) b =>
 fun   ax & phant_id ax0 ax => Pack (Phant F) (@Class T b ax) T.

Definition eqType := @Equality.Pack cT xclass xT.
Definition choiceType := @Choice.Pack cT xclass xT.
Definition zmodType := @Zmodule.Pack cT xclass xT.
Definition ringType := @Ring.Pack cT xclass xT.
Definition unitRingType := @UnitRing.Pack cT xclass xT.
Definition comRingType := @ComRing.Pack cT xclass xT.
Definition comUnitRingType := @ComUnitRing.Pack cT xclass xT.
Definition idomainType := @IntegralDomain.Pack cT xclass xT.
Definition fieldType := @Field.Pack cT xclass xT.
Definition lmodType := @Lmodule.Pack F phF cT xclass xT.
Definition lalgType := @Lalgebra.Pack F phF cT xclass xT.
Definition algType := @Algebra.Pack F phF cT xclass xT.
Definition unitAlgType := @UnitAlgebra.Pack F phF cT xclass xT.
Definition vectType := @Vector.Pack F phF cT xclass xT.
Definition FalgType := @Falgebra.Pack F phF cT xclass xT.
Definition fieldExtType := @FieldExt.Pack F phF cT xclass xT.

End ClassDef.

Module Exports.

Coercion sort : type >-> Sortclass.
Bind Scope ring_scope with sort.
Coercion base : class_of >-> FieldExt.class_of.
Coercion eqType : type >-> Equality.type.
Canonical eqType.
Coercion choiceType : type >-> Choice.type.
Canonical choiceType.
Coercion zmodType : type >-> Zmodule.type.
Canonical zmodType.
Coercion ringType : type >-> Ring.type.
Canonical ringType.
Coercion unitRingType : type >-> UnitRing.type.
Canonical unitRingType.
Coercion comRingType : type >-> ComRing.type.
Canonical comRingType.
Coercion comUnitRingType : type >-> ComUnitRing.type.
Canonical comUnitRingType.
Coercion idomainType : type >-> IntegralDomain.type.
Canonical idomainType.
Coercion fieldType : type >-> Field.type.
Canonical fieldType.
Coercion lmodType : type >-> Lmodule.type.
Canonical lmodType.
Coercion lalgType : type >-> Lalgebra.type.
Canonical lalgType.
Coercion algType : type >-> Algebra.type.
Canonical algType.
Coercion unitAlgType : type >-> UnitAlgebra.type.
Canonical unitAlgType.
Coercion vectType : type >-> Vector.type.
Canonical vectType.
Coercion FalgType : type >-> Falgebra.type.
Canonical FalgType.
Coercion fieldExtType : type >-> FieldExt.type.
Canonical fieldExtType.

Notation splittingFieldType F := (type (Phant F)).
Notation SplittingFieldType F L ax := (@pack _ (Phant F) L _ ax _ _ id _ id).
Notation "[ 'splittingFieldType' F 'of' L 'for' K ]" :=
  (@clone _ (Phant F) L K _ idfun)
  (at level 0, format "[ 'splittingFieldType'  F  'of'  L  'for'  K ]")
  : form_scope.
Notation "[ 'splittingFieldType' F 'of' L ]" :=
  (@clone _ (Phant F) L _ _ idfun)
  (at level 0, format "[ 'splittingFieldType'  F  'of'  L ]") : form_scope.

End Exports.
End SplittingField.
Export SplittingField.Exports.

Lemma normal_field_splitting (F : fieldType) (L : fieldExtType F) :
  (forall (K : {subfield L}) x,
    exists r, minPoly K x == \prod_(y <- r) ('X - y%:P)) ->
  SplittingField.axiom L.
Proof.
move => normalL.
pose r i := sval (sigW (normalL 1%AS (tnth (vbasis fullv) i))).
have sz_r i: (size (r i) <= \dim {:L})%N.
  rewrite -ltnS -(size_prod_XsubC _ id) /r; case: (sigW _) => _ /= /eqP <-.
  rewrite size_minPoly ltnS; move: (tnth _ _) => x.
  by rewrite elementDegreeE dimv1 divn1 dimvS // subvf.
pose mkf (z : L) := 'X - z%:P; pose mkfr i j := mkf (r i)`_j.
exists (\prod_i \prod_(j < \dim {:L} | (j < size (r i))%N) mkfr i j).
  apply: rpred_prod => i _; rewrite big_ord_narrow /=.
  rewrite -(big_mkord xpredT (mkfr i)) -(big_nth _ xpredT mkf) /r.
  by case: (sigW _) => _ /= /eqP <-; exact: minPolyOver.
rewrite pair_big_dep /= -big_filter filter_index_enum -(big_map _ xpredT mkf).
set rF := map _ _; exists rF; first exact: eqpxx.
apply/eqP; rewrite eqEsubv subvf -(span_basis (vbasisP fullv)).
apply/span_subvP=> _ /tnthP[i ->]; set x := tnth _ i.
have /(nthP 0)[j lt_j_ri <-]: x \in r i.
  rewrite -root_prod_XsubC /r -/x; case: (sigW _) => _ /= /eqP <-.
  exact: root_minPoly.
apply: seqv_sub_adjoin.
by apply/imageP; exists (i, Ordinal (leq_trans lt_j_ri (sz_r i))).
Qed.

Section SplittingFieldTheory.

Variables (F : fieldType) (L : splittingFieldType F).

Implicit Types (U V W : {vspace L}).
Implicit Types (K M E : {subfield L}).

Lemma splittingFieldP : SplittingField.axiom L.
Proof. by case: L => ? []. Qed.

Lemma splittingPoly : 
  { p : {poly L} | p \is a polyOver 1%VS & splittingFieldFor 1 p {:L}}.
Proof.
have H : exists prs : {poly L}*(seq L), 
  [&& prs.1 \is a polyOver 1%VS
  , prs.1 %= \prod_(z <- prs.2) ('X - z%:P)
  & <<1 & prs.2>>%AS == fullv].
  have [p F0p [rs splitLp gen]] := splittingFieldP.
  by exists (p,rs); rewrite F0p splitLp gen eqxx.
case/and3P: (xchooseP H) => [HP1 HP2 HP3].
exists (xchoose H).1; first done.
exists (xchoose H).2; first done.
by apply/eqP.
Qed.

Lemma enum_fAutL :
  {fAutL : seq 'AEnd(L) | forall f, f \in fAutL}.
Proof.
suff [fAutL HfAutL] :
  {fAutL : seq 'AEnd(L) | forall f, (val f \is a kHom 1 {:L}) = (f \in fAutL)}.
  exists fAutL => f.
  by rewrite -HfAutL fAutL_is_kHom.
have [p Kp /sig2_eqW[rs Dp]] := splittingPoly.
rewrite -[1%VS]/(1%AS:{vspace L}); set r := rs; set E := 1%AS => defL.
have [sKE rs_r]: (1 <= E)%VS /\ all (mem rs) r by split=> //; exact/allP.
elim: r rs_r => [_|z r IHr /=/andP[rs_z rs_r]] /= in (E) sKE defL *.
  rewrite Fadjoin_nil in defL.
  rewrite defL; exists [tuple \1%AF] => // f.
  rewrite inE; apply/idP/eqP => [/kHomP[f1 _] | ->]; last exact: kHom1.
  by apply/val_inj/lfunP=> x; rewrite id_lfunE f1 ?memvf.
set Ez := <<E; z>>%AS in defL; pose pEz := minPoly E z.
have sEEz: (E <= Ez)%VS := subv_adjoin E z; have sKEz := subv_trans sKE sEEz.
rewrite adjoin_cons in defL.
have{IHr} [homEz DhomEz] := IHr rs_r _ sKEz defL.
have Ep: p \in polyOver E := polyOverSv sKE Kp.
have [m DpEz]: {m | pEz %= \prod_(w <- mask m rs) ('X - w%:P)}.
  apply: dvdp_prod_XsubC; rewrite -(eqp_dvdr _ Dp).
  rewrite minPoly_dvdp ?(polyOverSv sKE) //.
  by rewrite (eqp_root Dp) root_prod_XsubC.
set rz := mask m rs in Dp; pose n := \dim_E Ez.
have sz_rz: size rz == n.
  rewrite /n -elementDegreeE -eqSS.
  by rewrite -size_minPoly -(size_prod_XsubC _ id) -(eqp_size DpEz).
have fEz i (y := tnth (Tuple sz_rz) i) :
    {f : 'AEnd(L) | val f \is a kHom E fullv & f z = y}.
  have homEfz: kHomExtend E \1%VF z y \in kHom E Ez.
    rewrite kHomExtendkHom ?kHom1 // map_poly_id => [|u]; last by rewrite lfunE.
    by rewrite (eqp_root DpEz) -/rz root_prod_XsubC mem_tnth.
  have splitFp: splittingFieldFor Ez p fullv.
    exists rs => //; apply/eqP; rewrite eqEsubv subvf -defL adjoin_seqSr //.
    exact/allP.
  have [f homLf Df] := kHom_extends sEEz homEfz Ep splitFp.
  case/andP: (homLf) => _ ahomf.
  exists (AHom ahomf) => //.
  rewrite -Df ?memv_adjoin ?(kHomExtendX (kHom1 E E)) //.
  rewrite map_poly_id; last by move => ? _ /=; rewrite id_lfunE.
  rewrite (eqp_root DpEz) root_prod_XsubC.
  by apply: (mem_tnth i (Tuple sz_rz)).
exists [seq (s2val (fEz i) \o f)%AF| i <- enum 'I_n, f <- homEz] => f.
apply/idP/allpairsP => [homLf | [[i g] [_ Hg ->]] /=]; last first.
  case: (fEz i) => fi /= /comp_kHom->; rewrite ?(kHomSl sEEz) //.
  by rewrite DhomEz.
have /tnthP[i Dfz]: f z \in Tuple sz_rz.
  rewrite memtE /= -root_prod_XsubC -(eqp_root DpEz).
  by rewrite (kHom_rootK _ homLf) ?memvf ?subvf ?minPolyOver ?root_minPoly.
case Dfi: (fEz i) => [fi homLfi fi_z]; have kerfi0 := kAutL_lker0 homLfi.
set fj := (fi ^-1 \o f)%AF; suffices Hfj : fj \in homEz.
  exists (i, fj) => //=; rewrite mem_enum inE Hfj; split => //.
  by apply/val_inj; rewrite {}Dfi /= (lker0_compVKf kerfi0).
rewrite -DhomEz; apply/kHomP.
have homLfj: val fj \is a kHom E fullv := comp_kHom (inv_kAutL homLfi) homLf.
split=> [_ /poly_Fadjoin[q Eq ->]|]; last by case/kHomP: homLfj.
have /fAutL_lrmorph fjM := kHomSl (sub1v _) homLfj.
rewrite -[fj _](horner_map (RMorphism fjM)) (kHomFixedPoly homLfj) //.
by rewrite /= lfunE /= Dfz -fi_z lker0_lfunK.
Qed.

Lemma splitting_field_normal K x :
  exists r, minPoly K x == \prod_(y <- r) ('X - y%:P).
Proof.
pose q1 := minPoly 1 x.
have [p F0p splitLp] := splittingFieldP.
have [autL DautL] := enum_fAutL.
suffices{K} autL_px q:
  q %| q1 -> size q > 1 -> has (fun f : 'AEnd(L) => root q (f x)) autL.
- set q := minPoly K x; have: q \is monic by exact: monic_minPoly.
  have: q %| q1 by rewrite minPolyS // sub1v.
  elim: {q}_.+1 {-2}q (ltnSn (size q)) => // d IHd q leqd q_dv_q1 mon_q.
  have [/size1_polyC Dq | q_gt1] := leqP (size q) 1.
    exists nil; rewrite big_nil Dq (inj_eq (@polyC_inj _)).
    by rewrite qualifE Dq lead_coefC in mon_q.
  have /hasP[f autLf /factor_theorem[q2 Dq]] := autL_px q q_dv_q1 q_gt1.
  have mon_q2: q2 \is monic by rewrite -(monicMr _ (monicXsubC (f x))) -Dq.
  rewrite Dq size_monicM -?size_poly_eq0 ?size_XsubC ?addn2 //= in leqd.
  have q2_dv_q1: q2 %| q1 by rewrite (dvdp_trans _ q_dv_q1) // Dq dvdp_mulr.
  rewrite Dq; have [r /eqP->] := IHd q2 leqd q2_dv_q1 mon_q2.
  by exists (f x :: r); rewrite big_cons mulrC.
elim: {q}_.+1 {-2}q (ltnSn (size q)) => // d IHd q leqd q_dv_q1 q_gt1.
without loss{d leqd IHd q_gt1} irr_q: q q_dv_q1 / irreducible_poly q.
  move=> IHq; apply: wlog_neg => not_autLx_q; apply: IHq => //.
  split=> // q2 q2_neq1 q2_dv_q; apply: contraR not_autLx_q => ltq2q.
  have{q2_neq1} q2_gt1: size q2 > 1.
    rewrite ltn_neqAle eq_sym q2_neq1 size_poly_gt0.
    apply: contraTneq q_gt1 => q2_0; rewrite -(divpK q2_dv_q) q2_0 mulr0.
    by rewrite size_poly0.
  have ltq2d: size q2 < d.
    rewrite -ltnS (leq_trans _ leqd) // ltnS ltn_neqAle dvdp_size_eqp //.
    by rewrite ltq2q dvdp_leq // -size_poly_eq0 -(subnKC q_gt1).
  apply: sub_has (IHd _ ltq2d (dvdp_trans q2_dv_q q_dv_q1) q2_gt1) => f.
  by rewrite !root_factor_theorem => /dvdp_trans->.
have{irr_q} [Lz [inLz [z qz0]]]: {Lz : fieldExtType F &
  {inLz : 'AHom(L, Lz) & {z : Lz | root (map_poly inLz q) z}}}.
- have [Lz0 _ [z qz0 defLz]] := irredp_FAdjoin irr_q.
  pose Lz := baseField_extFieldType Lz0.
  have inLzL_linear : linear (in_alg Lz0 : L -> Lz).
    move => a u v; rewrite rmorphD -{1}mulr_algl rmorphM /=.
    by rewrite mulr_algl -{1}baseField_scaleE.
  suffices ihLzZ : (linfun (Linear inLzL_linear)) \is ahom_in fullv.
    exists Lz, (AHom ihLzZ), z.
    rewrite (eq_map_poly (g:=(in_alg Lz0))) //.
    by move => y; rewrite lfunE.
  apply/is_ahomP; repeat split; last by move => a u; rewrite linearZ.
  - by move => u v; rewrite !lfunE rmorphB.
  - by move => u v; rewrite !lfunE rmorphM.
  - by rewrite !lfunE rmorph1.
pose imL := [aspace of limg inLz]; pose pz := map_poly inLz p.
have imLin u: inLz u \in imL by rewrite memv_img ?memvf.
have F0pz: pz \is a polyOver 1%VS.
  apply/polyOverP=> i; rewrite -(aimg1 inLz) coef_map /= memv_img //.
  exact: (polyOverP F0p).
have{splitLp} splitLpz: splittingFieldFor 1 pz imL.
  have [r def_p defL] := splitLp; exists (map inLz r).
    move: def_p.
    rewrite -(eqp_map [rmorphism of inLz]) rmorph_prod big_map; congr (_ %= _).
    by apply: eq_big => // y _; rewrite rmorphB /= map_polyX map_polyC.
  apply/eqP; rewrite eqEsubv; apply/andP; split.
    by apply/Fadjoin_seqP; rewrite sub1v; split=> // _ /mapP[y r_y ->].
  rewrite /= -{def_p}defL.
  elim/last_ind: r => [|r y IHr] /=; first by rewrite !Fadjoin_nil aimg1.
  rewrite map_rcons !adjoin_rcons /=.
  apply/subvP=> _ /memv_imgP[_ /poly_Fadjoin[p1 r_p1 ->] ->].
  rewrite -horner_map /= mempx_Fadjoin //=; apply/polyOverP=> i.
  by rewrite coef_map (subvP IHr) //= memv_img ?(polyOverP r_p1).
have [f homLf fxz]: exists2 f : 'End(Lz), f \is a kHom 1 imL & f (inLz x) = z.
  pose q1z := minPoly 1 (inLz x).
  have Dq1z: map_poly inLz q1 %| q1z.
    have F0q1z i: exists a, q1z`_i = a%:A by exact/vlineP/polyOverP/minPolyOver.
    have [q2 Dq2]: exists q2, q1z = map_poly inLz q2.
      exists (\poly_(i < size q1z) (sval (sig_eqW (F0q1z i)))%:A).
      rewrite -{1}[q1z]coefK; apply/polyP=> i; rewrite coef_map !{1}coef_poly.
      by case: sig_eqW => a; case: ifP; rewrite /= ?rmorph0 ?linearZ ?rmorph1. 
    rewrite Dq2 dvdp_map minPoly_dvdp //.
      apply/polyOverP=> i; have[a] := F0q1z i.
      rewrite -(rmorph1 [rmorphism of inLz]) -linearZ.
      by rewrite Dq2 coef_map => /fmorph_inj->; rewrite rpredZ ?mem1v.
    by rewrite -(fmorph_root [rmorphism of inLz]) -Dq2 root_minPoly.
  have q1z_z: root q1z z.
    rewrite !root_factor_theorem in qz0 *.
    by apply: dvdp_trans qz0 (dvdp_trans _ Dq1z); rewrite dvdp_map.
  have map1q1z_z: root (map_poly \1%VF q1z) z.
    by rewrite map_poly_id => // ? _; rewrite lfunE.
  pose f0 := kHomExtend 1 \1 (inLz x) z.
  have{map1q1z_z} hom_f0 : f0 \is a kHom 1 <<1; (inLz x)>>%AS.
    by apply: kHomExtendkHom map1q1z_z => //; apply: kHom1.
  have{splitLpz} splitLpz: splittingFieldFor <<1; inLz x>>%AS pz imL.
    have [r def_pz defLz] := splitLpz; exists r => //.
    apply/eqP; rewrite eqEsubv -{2}defLz adjoin_seqSl ?sub1v // andbT.
    apply/Fadjoin_seqP; split; last first.
      by rewrite /= -[limg _]defLz; apply: seqv_sub_adjoin.
    by apply/FadjoinP/andP; rewrite sub1v memv_img ?memvf.
  have [f homLzf Df] := kHom_extends (sub1v _) hom_f0 F0pz splitLpz.
  have [-> | x'z] := eqVneq (inLz x) z.
    by exists \1%VF; rewrite ?lfunE ?kHom1.
  exists f => //; rewrite -Df ?memv_adjoin ?(kHomExtendX (kHom1 1 1)) //.
  rewrite map_poly_id //.
  by move => ? _ /=; rewrite id_lfunE.
pose f1 := (inLz^-1 \o f \o inLz)%VF.
have /kHomP[f1id fM] := homLf.
have Df1 u: inLz (f1 u) = f (inLz u).
  rewrite !comp_lfunE limg_lfunVK //= -[limg _]/(asval imL).
  have [r def_pz defLz] := splitLpz.
  have []: all (mem r) r /\ inLz u \in imL by split; first exact/allP.
  rewrite -{1}defLz; elim/last_ind: {-1}r {u}(inLz u) => [|r1 y IHr1] u.
    by rewrite Fadjoin_nil; move=> _ F0u; rewrite f1id // (subvP (sub1v _)).
  rewrite all_rcons adjoin_rcons => /andP[rr1 ry] /poly_Fadjoin[pu r1pu ->].
  rewrite (kHom_horner homLf) -defLz; last exact: seqv_sub_adjoin; last first.
    by apply: polyOverS r1pu; apply/subvP/adjoin_seqSr/allP.
  apply: rpred_horner.
    by apply/polyOverP=> i; rewrite coef_map /= defLz IHr1 ?(polyOverP r1pu).
  rewrite seqv_sub_adjoin // -root_prod_XsubC -(eqp_root def_pz).
  rewrite (kHom_rootK _ homLf) ?sub1v //.
    by rewrite -defLz seqv_sub_adjoin.
  by rewrite (eqp_root def_pz) root_prod_XsubC.
suff f1_is_ahom : f1 \is ahom_in fullv.
  apply/hasP; exists (AHom f1_is_ahom); last first.
    by rewrite -(fmorph_root [rmorphism of inLz]) /= Df1 fxz.
  apply: DautL.
apply/is_ahom_inP; split.
  move => a b _ _.
  apply: (fmorph_inj [rmorphism of inLz]).
  by rewrite rmorphM /= !Df1 rmorphM fM ?imLin.
apply: (fmorph_inj [rmorphism of inLz]).
by rewrite /= Df1 /= f1id ?rmorph1 ?mem1v.
Qed.

Lemma kHom_extend_fAutL K E f : f \is a kHom K E ->
  {g : 'AEnd(L) | {in E, f =1 val g}}.
Proof.
move/(kHomSl (capvSl K E)) => Hf.
have [p Hp Hsfp] := splittingPoly.
move/(polyOverSv (mem1v [aspace of K :&: E])): Hp => Hp.
have /andP HE := conj (mem1v E) (subvf E).
move/(splittingFieldForS HE): Hsfp => Hsfp.
have [g0 Hg Hfg] := kHom_extends (capvSr K E) Hf Hp Hsfp.
suff Hg_aend : g0 \is ahom_in {:L} by exists (AHom Hg_aend).
by apply/is_ahomP/fAutL_lrmorph; apply: (kHomSl _ Hg); apply: mem1v.
Qed.

End SplittingFieldTheory.

(* Hide the finGroup structure on 'AEnd(L) in a module so that we can control
   when it is exported.  
   Most people will want to use the finGroup structure on 'Gal(E / K) and will
   not need this module. *)
Module fAutL_FinGroup.

Section fAutL_FinGroup.

Variables (F : fieldType) (L : splittingFieldType F).

Implicit Types (U V W : {vspace L}).
Implicit Types (K M E : {subfield L}).

Lemma index_fAutL_subproof f :
  index f (sval (enum_fAutL L)) < size (sval (enum_fAutL L)).
Proof.
rewrite index_mem.
by apply/(svalP (enum_fAutL L) f).
Qed.

Lemma cancel_fAutL_ord_subproof : 
  cancel (fun f => Ordinal (index_fAutL_subproof f))
    (nth \1%AF (sval (enum_fAutL L))).
Proof.
move => [f Hf].
rewrite nth_index //.
by apply/(svalP (enum_fAutL L)).
Qed.

Definition fAutL_countMixin :=
  Eval hnf in CanCountMixin cancel_fAutL_ord_subproof.
Canonical fAutL_countType := Eval hnf in CountType 'AEnd(L) fAutL_countMixin.
Canonical fAutL_subCountType := Eval hnf in [subCountType of 'AEnd(L)].
Definition fAutL_finMixin := Eval hnf in CanFinMixin cancel_fAutL_ord_subproof.
Canonical fAutL_finType := Eval hnf in FinType 'AEnd(L) fAutL_finMixin.
Canonical fAutL_subFinType := Eval hnf in [subFinType of 'AEnd(L)].

(* the group operation is the categorical composition operation *)
Definition comp_fAutL (f g : 'AEnd(L)) : 'AEnd(L) := (g \o f)%AF.

Lemma comp_fAutLA : associative comp_fAutL.
Proof. by move => f g h; apply: val_inj; symmetry; apply: comp_lfunA. Qed.

Lemma comp_fAutL1l : left_id \1%AF comp_fAutL.
Proof. by move=> f; apply/val_inj/comp_lfun1r. Qed.

Lemma comp_fAutLK : left_inverse \1%AF (@inv_fAutL _ L) (fun f g => g \o f)%AF.
Proof.
move=> f; apply/val_inj => /=.
rewrite lker0_compfV ?(kAutL_lker0 (K:=1%AS)) //.
by apply: fAutL_is_kHom.
Qed.

Definition fAutL_baseFinGroupMixin := FinGroup.Mixin (T:='AEnd(L))
   comp_fAutLA comp_fAutL1l comp_fAutLK.

Canonical fAutL_baseFinGroupType := Eval hnf in 
   BaseFinGroupType 'AEnd(L) fAutL_baseFinGroupMixin.
Canonical fAutL_finGroupType := Eval hnf in
   @FinGroupType fAutL_baseFinGroupType comp_fAutLK.

Definition kAAut U V := [set f : 'AEnd(L) | val f \in kAut U V ].

Definition kAAutL U := kAAut U {:L}.

Lemma kAAut_group_set K E : group_set (kAAut K E).
Proof.
apply/group_setP; split; first by rewrite inE qualifE kHom1 lim1g eqxx.
move => x y.
rewrite !inE !kAutE.
case/andP; case/kHomP => Hx1 Hx2 Hx3.
case/andP; case/kHomP => Hy1 Hy2 Hy3.
apply/andP; split; last first.
  rewrite SubK limg_comp (subv_trans _ Hy3) // limg_ker0 //.
  by apply: fAutL_lker0.
apply/kHomP; split; first by move => a Ha;rewrite SubK lfunE /= Hy1 // Hx1.
by move => ? ? _ _; rewrite /= rmorphM.
Qed.

Canonical kAAut_group K E := Eval hnf in group (kAAut_group_set K E).

Lemma kAAut_normal K E : kAAut K E \subset 'N(kAAutL E)%g.
Proof.
apply/subsetP.
move => x.
rewrite !{1}in_set.
case/andP => _ /eqP Hx.
apply/subsetP => ? /imsetP [y].
rewrite !in_set.
case/andP => /kHomP [Hy _] _ ->.
rewrite -kHomL_kAutL.
apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
move => a Ha /=.
rewrite -{2}[a](id_lfunE) -[\1%VF]/(val (1%g : 'AEnd(L))) -(mulVg x).
rewrite !SubK !lfunE /= lfunE [X in ((val x) X) = _]Hy //.
rewrite -Hx in Ha.
case/memv_imgP: Ha => [b Hb ->].
by rewrite -comp_lfunE -[(x^-1 \o x)%VF]/(ahval (x * x^-1)%g) mulgV id_lfunE.
Qed.

Lemma mem_kAut_coset K E (g : 'AEnd(L)) : val g \is a kAut K E -> 
  g \in coset (kAAutL E) g.
Proof.
move => Hg.
rewrite val_coset; first by apply: rcoset_refl.
move/subsetP: (kAAut_normal K E).
apply.
by rewrite inE.
Qed.

Lemma aut_mem_eqP E (x y : coset_of (kAAutL E)) f g : 
  f \in x -> g \in y -> reflect {in E, f =1 g} (x == y).
Proof.
move => Hf Hg.
move/subsetP/(_ _ Hf): (coset_norm x) => HfN.
move/subsetP/(_ _ Hg): (coset_norm y) => HgN.
apply: (iffP idP).
  move/eqP => Hxy.
  move: Hf Hg.
  rewrite Hxy.
  move/coset_mem <-.
  rewrite val_coset //.
  case/rcosetP => h.
  rewrite inE kAutE subvf andbT.
  case/kHomP => Hh _ -> a Ha.
  rewrite /= lfunE /= Hh //.
move/coset_mem: Hf <-.
move/coset_mem: (Hg) => <- Hfg.
apply/eqP/coset_mem.
rewrite val_coset // mem_rcoset /=.
rewrite inE kAutE subvf andbT.
apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
move => a Ha.
rewrite /= comp_lfunE /= Hfg //.
by rewrite -comp_lfunE -[(_ \o _)%VF]/(ahval (g * g^-1)%g) mulgV id_lfunE.
Qed.

End fAutL_FinGroup.
End fAutL_FinGroup.
Export fAutL_FinGroup.

Section GaloisTheory.

Variables (F : fieldType) (L : splittingFieldType F).

Implicit Types (U V W : {vspace L}).
Implicit Types (K M E : {subfield L}).

(* We wrap coset_of (kAAutL V) in a new type in order to create a suitable
   coercion class for gal_repr to coerce from. *)
Section gal_of_Definition.

Variable (V : {vspace L}).

Inductive gal_of := Gal of [subg <<kAAut 1 V>>/kAAutL V].
Definition gal x := Gal (subg _ x). 
Definition gal_val A := let: Gal x := A in x.

Canonical gal_subType :=
  Eval hnf in [newType for gal_val by gal_of_rect].
Definition gal_eqMixin := Eval hnf in [eqMixin of gal_of by <:].
Canonical gal_eqType := Eval hnf in EqType gal_of gal_eqMixin.
Definition gal_choiceMixin := [choiceMixin of gal_of by <:].
Canonical gal_choiceType := Eval hnf in ChoiceType gal_of gal_choiceMixin.
Definition gal_countMixin := [countMixin of gal_of by <:].
Canonical gal_countType := Eval hnf in CountType gal_of gal_countMixin.
Canonical gal_subCountType := Eval hnf in [subCountType of gal_of].
Definition gal_finMixin := [finMixin of gal_of by <:].
Canonical gal_finType := Eval hnf in FinType gal_of gal_finMixin.
Canonical gal_subFinType := Eval hnf in [subFinType of gal_of].

Definition gal_one := Gal 1%g.
Definition gal_inv u := Gal (gal_val u)^-1.
Definition gal_mul u v := Gal (gal_val u * gal_val v).
Lemma gal_oneP : left_id gal_one gal_mul.
Proof. move=> u; apply: val_inj; exact: mul1g. Qed.

Lemma gal_invP : left_inverse gal_one gal_inv gal_mul.
Proof. move=> u; apply: val_inj; exact: mulVg. Qed.
Lemma gal_mulP : associative gal_mul.
Proof. move=> u v w; apply: val_inj; exact: mulgA. Qed.

Definition gal_finGroupMixin :=
  FinGroup.Mixin gal_mulP gal_oneP gal_invP.
Canonical gal_finBaseGroupType :=
  Eval hnf in BaseFinGroupType gal_of gal_finGroupMixin.
Canonical gal_finGroupType := Eval hnf in FinGroupType gal_invP.

Lemma gal_is_morph : 
  {in (<<kAAut 1 V>> / kAAutL V)%g &, {morph gal : x y / (x * y)%g}}.
Proof. move => a b /= Ha Hb. by rewrite /gal subgM. Qed.
Canonical gal_morphism  := Morphism gal_is_morph.

Coercion gal_repr (x : gal_of) : 'AEnd(L) := repr (val (val x)).

(*
Lemma f_aut_repr_is_ahom x : f_aut_repr x \is ahom_in {:L}.
Proof. by apply/is_ahomP; apply: lrmorphismP. Qed.
Canonical f_aut_repr_ahom x := AHom (f_aut_repr_is_ahom x).
*)

End gal_of_Definition.

Lemma gal_eqP E (x y : gal_of E) : reflect {in E, x =1 y} (x == y).
Proof. by apply: aut_mem_eqP; apply: mem_repr_coset. Qed.

Lemma gal_id E a : (1:gal_of E)%g a = a.
Proof. by rewrite /gal_repr repr_coset1 id_lfunE. Qed.

Lemma galM E (x y : gal_of E) : {in E, (x * y)%g =1 (y \o x)%VF}.
Proof.
apply/(aut_mem_eqP (x:=val (val (x * y)%g)) (y:=val (val (x * y)%g))) => //. 
  by rewrite mem_repr_coset.
rewrite [val _]/=.
rewrite -[in X in _ \in X](coset_mem (mem_repr_coset (val (val x)))).
rewrite -[in X in _ \in X](coset_mem (mem_repr_coset (val (val y)))).
rewrite -coset_morphM ?repr_coset_norm //.
rewrite val_coset; first by apply: rcoset_refl.
by apply: groupM; apply: repr_coset_norm.
Qed.

Lemma galV E (x : gal_of E) : {in E, (x^-1)%g =1 x^-1%VF}.
Proof.
case: x => x /= a Ha.
apply: (canRL (lker0_lfunK _)); first by apply: fAutL_lker0.
by rewrite -comp_lfunE -(galM (Gal x)^-1%g (Gal x)) // mulVg gal_id.
Qed.

Lemma limg_gal E (x : gal_of E) : (x @: E)%VS = E.
Proof.
rewrite /gal_repr.
case/imsetP: (valP (val x)) => g.
rewrite /= genGid !inE => /andP [_ Hg] -> {x} /=.
move: (Hg); rewrite qualifE; case/andP => _ /eqP HE.
rewrite -[X in _ = X]HE.
apply: eq_in_limg => a Ha.
move: (eqxx (coset (kAAutL E) g)).
by move/(aut_mem_eqP (mem_repr_coset _) (mem_kAut_coset Hg)) => -> //.
Qed.

Lemma memv_gal E (x : gal_of E) a : a \in E -> x a \in E.
Proof.
move => Ha.
rewrite -[in X in _ \in X](limg_gal x).
by apply: memv_img.
Qed.

Definition galoisG U V := ((@gal V) @* (<<kAAut (U :&: V) V>> / kAAutL V))%g.

(* Standard mathematical notation for 'Gal(E / K) puts the larger field first.*)
Notation "''Gal' ( V / U )" := (galoisG U V).

Section Automorphism.

Lemma gal_cap U V : 'Gal(V / U) = 'Gal(V / U :&: V).
Proof. by rewrite /galoisG -capvA capvv. Qed.

Lemma kAut_gal K E f : f \is a kAut K E ->
  {x | x \in 'Gal(E / K) & {in E, f =1 x}}.
Proof.
case/andP => HfKE /eqP HfE.
have [g Hg] := kHom_extend_fAutL HfKE.
have HgKE : (g : 'End(L)) \is a kAut (K :&: E) E.
  rewrite kAutE -(kHom_eq (capvSr _ _) Hg) (kHomSl (capvSl _ _) HfKE).
  by rewrite -(eq_in_limg Hg) HfE subvv.
exists (gal (coset _ g)).
  rewrite mem_morphim // mem_quotient //= genGid inE //.
  by apply: (kAutS (sub1v (K :&: E))).
move => a Ha /=.
rewrite Hg //.
move: a Ha.
apply/(aut_mem_eqP (mem_kAut_coset HgKE) (mem_repr_coset _)).
rewrite subgK //= genGid mem_quotient // inE.
by apply: (kAutS (sub1v (K :&: E))).
Qed.

Lemma gal_kAut K E x :
  (x \in 'Gal(E / K)) = ((x : 'End(L)) \is a kAut (K :&: E) E).
Proof.
apply/idP/idP.
  case/imsetP => y.
  rewrite inE => /andP [_ Hy] ->.
  case/imsetP: Hy => g; rewrite genGid !inE => /andP [_ Hg] {y} ->.
  rewrite (kAut_eq (g:=val g) (capvSr K E) _) //.
  apply/(aut_mem_eqP (mem_repr_coset _) (mem_kAut_coset Hg)).
  rewrite subgK //= genGid mem_quotient // inE.
  by apply: (kAutS (sub1v (K :&: E))).
move => Hx.
apply/imsetP.
exists (val (val x)); last first.
  do 2 apply: val_inj.
  by rewrite /= sgvalK.
rewrite (subsetP (quotientI _ _ _)) // !genGid /=.
have /setIidPr -> : kAAut (K :&: E) E \subset kAAut 1 E.
  by apply/subsetP => g; rewrite !inE; apply: kAutS; apply: sub1v.
apply/imsetP.
exists (gal_repr x); first by rewrite (setIidPr _) ?inE // kAAut_normal.
by rewrite /gal_repr /= coset_reprK.
Qed.

Lemma fixed_gal K E x a : (K <= E)%VS -> x \in 'Gal(E / K) -> a \in K ->
  x a = a.
Proof.
move => HKE.
rewrite gal_kAut // (capv_idPl HKE).
case/andP => /kHomP [Hx _] _ Ha.
by rewrite Hx.
Qed.

Lemma fixedPoly_gal K E x p : (K <= E)%VS -> x \in 'Gal(E / K) ->
  p \is a polyOver K -> map_poly x p = p.
Proof.
move => HKE Hx /polyOverP Hp.
apply/polyP => i.
by rewrite coef_map /= (fixed_gal HKE) //.
Qed.

Lemma root_minPoly_gal K E x a : (K <= E)%VS -> x \in 'Gal(E / K) -> a \in E ->
  root (minPoly K a) (x a).
Proof.
move => HKE Hx Ha.
rewrite -[minPoly K a](fixedPoly_gal HKE Hx) ?minPolyOver //.
rewrite gal_kAut kAutE andbC in Hx.
case/andP: Hx => _.
move/kHom_root; apply => //; last by apply: root_minPoly.
move/subvP: HKE.
move/polyOverS; apply.
by apply: minPolyOver.
Qed.

End Automorphism.

Lemma gal_eq_Fadjoin K a x y :
  x \in 'Gal(<<K; a>>%AS / K) -> y \in 'Gal(<<K; a>>%AS / K) ->
  (x == y) = (x a == y a).
Proof.
move => Hx Hy.
apply/eqP/eqP; first by move ->.
move => Ha.
apply/eqP/gal_eqP => _ /poly_Fadjoin [p Hp ->].
by rewrite -!horner_map !(fixedPoly_gal (subv_adjoin K a)) //= Ha.
Qed.

Lemma galS K M E : (K <= M)%VS -> ('Gal(E / M) \subset 'Gal(E / K)).
Proof.
move/capvS/(_ (subvv E)) => HKM.
apply/subsetP => x.
rewrite !gal_kAut //.
by move/(kAutS HKM).
Qed.

Lemma gal_conjg K E x : ('Gal(E / K) :^ x)%g = 'Gal(E / (x @: K)%VS).
Proof.
wlog: K / (K <= E)%VS => [HAut_conjg|HKE].
  do 2 (rewrite gal_cap; symmetry).
  suff -> : (x @: K :&: E = x @: (K :&: E))%VS.
    by apply: HAut_conjg; rewrite capvSr.
  rewrite -[X in (_ :&: X)%VS = _](limg_gal x).
  apply:subv_anti.
  rewrite limg_cap andbT.
  apply/subvP => a.
  rewrite memv_cap => /andP [/memv_imgP [b Hb ->] /memv_imgP [c Hc]].
  move/(lker0P (fAutL_lker0 _)) => Hbc.
  by rewrite memv_img // memv_cap Hb Hbc.
apply/eqP.
have HxKE : (x @: K <= E)%VS.
  apply/subvP => _ /memv_imgP [a Ha ->].
  apply: memv_gal.
  by move/subvP: HKE; apply.
wlog suff Hsuff : x K HKE HxKE /
  (('Gal(E / K) :^ x)%g \subset ('Gal(E / (x @: K)%VS))).
  rewrite eqEsubset Hsuff // -sub_conjgV -[X in _ \subset ('Gal(E / X))]lim1g.
  rewrite -(lker0_compVf (fAutL_lker0 x)) limg_comp.
  have -> : (x^-1 @: (x @: K) = x^-1%g @: (x @: K))%VS.
    apply: eq_in_limg => a.
    move/(subvP HxKE) => Ha.
    by rewrite galV.
  apply: Hsuff => //.
  rewrite -limg_comp.
  apply: (subv_trans _ HKE).
  apply/subvP => _ /memv_imgP [a Ha ->].
  rewrite -galM ?mulgV ?gal_id //.
  by apply: (subvP HKE).
apply/subsetP => y.
rewrite mem_conjg !gal_kAut //= (capv_idPl HKE) (capv_idPl HxKE).
have /(kAut_eq HKE) -> : {in E, (y ^ (x^-1))%g =1 (x^-1%g \o y \o x)%AF}.
  rewrite conjgE invgK => z Hz.
  have Hxz : x z \in E by apply: memv_gal.
  by rewrite !(galM,comp_lfunE) //.
rewrite !kAutE.
case/andP => HyKE.
rewrite !limg_comp -[X in (_ <= X)%VS](limg_gal x^-1%g).
rewrite limg_ker0; last by apply: fAutL_lker0.
rewrite limg_gal => HyE.
rewrite HyE andbT.
apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
move => _ /memv_imgP [a Ha ->].
case/kHomP: HyKE => /(_ _ Ha) HyVa _.
rewrite -[in X in _ = X]HyVa !comp_lfunE /= -[X in _ = X]comp_lfunE.
rewrite -(galM (x^-1)%g x) ?mulVg ?gal_id ?id_lfunE //.
move/subvP: HyE; apply.
rewrite memv_img // memv_gal //.
by move/subvP: HKE; apply.
Qed.

Definition fixedField V (s : {set gal_of V}) :=
  (V :&: \bigcap_(x in s) (fixedSpace x))%VS.

Lemma fixedFieldP E (s : {set gal_of E}) a :
 reflect (a \in E /\ (forall x, x \in s -> x a = a))
         (a \in fixedField s).
Proof.
rewrite /fixedField.
apply/(iffP memv_capP); case => HaE H; (split; first done).
  move => x Hx.
  by move/subv_bigcapP/(_ _ Hx)/fixedSpaceP: H.
apply/subv_bigcapP => i Hi.
by apply/fixedSpaceP; apply: H.
Qed.

Fact fixedField_is_aspace_subproof E (s : {set gal_of E}) :
  let FF := fixedField s in
  (has_algid FF && (FF * FF <= FF)%VS).
Proof.
rewrite /fixedField -big_filter.
move : (filter _ _) => /= {s} r.
have -> : (\bigcap_(i <- r) fixedSpace i
        = \bigcap_(i <- [seq gal_repr i | i <- r]) fixedSpace i)%VS.
  by rewrite big_map.
move : {r} (map _ r) => r.
elim : r E => [|r rs IH] E; first by rewrite big_nil capvf; case: E.
rewrite big_cons capvA.
by apply: IH.
Qed.
Canonical fixedField_aspace E (s : {set gal_of E}) : {subfield L}
   := ASpace (fixedField_is_aspace_subproof s).

Lemma fixedField_bound E (s : {set gal_of E}) : (fixedField s <= E)%VS.
Proof. by apply: capvSl. Qed.

Lemma fixedFieldS E (s1 s2 : {set gal_of E}) :
   (s1 \subset s2) -> (fixedField s2 <= fixedField s1)%VS.
Proof.
move => /subsetP Hs.
apply/subvP => a /fixedFieldP [HaE Ha].
apply/fixedFieldP; split; first done.
move => x Hx.
by rewrite Ha // Hs.
Qed.

Lemma galois_connection_subv K E : (K <= E)%VS ->
  (K <= fixedField ('Gal(E / K)))%VS.
Proof.
move => HKE.
apply/subvP => a HaK.
apply/fixedFieldP; split; first by move/subvP: HKE; apply.
move => x Hx.
by apply: (fixed_gal HKE).
Qed.

Lemma galois_connection_subset E (s : {set gal_of E}):
  s \subset 'Gal(E / fixedField s).
Proof.
apply/subsetP => x Hxs.
rewrite gal_kAut (capv_idPl (fixedField_bound _)) kAutE.
apply/andP; split; last first.
  by rewrite limg_gal subvv.
apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
by move => a /fixedFieldP [_]; apply.
Qed.

Lemma galois_connection K E (s : {set gal_of E}):
  (K <= E)%VS -> (s \subset 'Gal(E / K)) = (K <= fixedField s)%VS.
Proof.
move => HKE.
apply/idP/idP.
  by move/fixedFieldS; apply: subv_trans; apply galois_connection_subv.
by move/(galS E); apply: subset_trans; apply: galois_connection_subset.
Qed.

Definition galTrace U V a := \sum_(x in 'Gal(V / U)) (x a).

Definition galNorm U V a := \prod_(x in 'Gal(V / U)) (x a).

Section TraceAndNorm.

Variables (K E : {subfield L}).

Lemma galTrace_is_additive : additive (galTrace K E).
Proof.
move => a b /=.
rewrite -sumrB.
apply: eq_bigr => i _.
by rewrite rmorphB.
Qed.

Canonical galTrace_additive := Eval hnf in Additive galTrace_is_additive.

Lemma galTrace_fixedField a : a \in E ->
  galTrace K E a \in fixedField 'Gal(E / K).
Proof.
move => Ha.
apply/fixedFieldP.
split.
  apply: memv_suml => i.
  rewrite gal_kAut.
  case/andP => _ /eqP HE.
  by rewrite -[in X in _ \in X]HE memv_img.
move => x Hx.
rewrite rmorph_sum /galTrace -{2}['Gal(E / K)](rcoset_id Hx).
rewrite (reindex_inj (mulIg (x^-1)%g)).
symmetry.
apply: eq_big => i; first by rewrite /= mem_rcoset.
by rewrite /= -comp_lfunE -galM // mulgKV.
Qed.

Lemma galTrace_gal a x : a \in E -> x \in 'Gal(E / K) ->
  galTrace K E (x a) = galTrace K E a.
Proof.
move => Ha Hx.
rewrite /galTrace -{2}['Gal(E / K)](lcoset_id Hx).
rewrite (reindex_inj (mulgI (x^-1)%g)).
apply: eq_big => i;first by rewrite /= mem_lcoset.
by rewrite -comp_lfunE -galM // mulKVg.
Qed.

Lemma galNorm1 : galNorm K E 1 = 1.
Proof. by apply big1 => i _; rewrite rmorph1. Qed.

Lemma galNormM : {morph (galNorm K E) : x y / x * y}.
Proof.
move => a b /=.
rewrite -big_split.
apply: eq_bigr => i _.
by rewrite rmorphM.
Qed.

Lemma galNormV a : galNorm K E (a^-1) = (galNorm K E a)^-1.
Proof.
rewrite -prodf_inv.
apply: eq_bigr => i _.
by rewrite fmorphV //.
Qed.

Lemma galNorm0 : galNorm K E 0 = 0.
Proof. by rewrite /galNorm (bigD1 1%g) ?group1 // rmorph0 /= mul0r. Qed.

Lemma galNorm_eq0 a : (galNorm K E a == 0) = (a == 0).
Proof.
apply/idP/eqP; last by move ->; rewrite galNorm0.
case/prodf_eq0 => i Hi.
rewrite fmorph_eq0.
by move/eqP.
Qed.

Lemma galNorm_fixedField a : a \in E ->
  galNorm K E a \in fixedField 'Gal(E / K).
Proof.
move => Ha.
apply/fixedFieldP.
split.
  apply: rpred_prod => i.
  rewrite gal_kAut.
  case/andP => _ /eqP HE /=.
  by rewrite -[in X in _ \in X]HE memv_img.
move => x Hx.
rewrite rmorph_prod /galNorm -{2}['Gal(E / K)](rcoset_id Hx).
rewrite (reindex_inj (mulIg (x^-1)%g)).
symmetry.
apply: eq_big => i; first by rewrite /= mem_rcoset.
by rewrite /= -comp_lfunE -(galM (i * x^-1)%g) // mulgKV.
Qed.

Lemma galNorm_gal a x : a \in E -> x \in 'Gal(E / K) -> 
  galNorm K E (x a) = galNorm K E a.
Proof.
move => Ha Hx.
rewrite /galNorm -{2}['Gal(E / K)](lcoset_id Hx).
rewrite (reindex_inj (mulgI (x^-1)%g)).
apply: eq_big => i;first by rewrite /= mem_lcoset.
by rewrite -comp_lfunE -galM // mulKVg.
Qed.

End TraceAndNorm.

Definition normalField U V := [forall x in kAAutL U, x @: V == V]%VS.

Lemma normalField_kAut K M E x : (K <= M <= E)%VS -> normalField K M ->
  x \is a kAut K E -> x \is a kAut K M.
Proof.
case/andP => HKM HME Hnorm Hx.
have [y Hy Hxy] := kAut_gal Hx.
have HMxy : {in M, x =1 y}.
  by move => a Ha /=; rewrite Hxy //; apply (subvP HME).
have HyK : (y : 'End(L)) \is a kHom K fullv.
  apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
  move => b; apply: fixed_gal => //.
  by apply: (subv_trans (y:=M)).
have HxKL : (y : 'AEnd(L)) \in kAAutL K by rewrite inE -kHomL_kAutL.
rewrite (kAut_eq _ HMxy) // kAutE.
have /eqP -> := (implyP (forallP Hnorm y) HxKL).
rewrite subvv andbT.
by apply: (kHomSr (subvf _)).
Qed.

Lemma normalFieldP K E :
 reflect (forall a, a \in E -> exists2 r, all (mem E) r
                                 & minPoly K a = \prod_(b <- r) ('X - b%:P))
         (normalField K E).
Proof.
apply: (iffP forallP); last first.
  move => Hnorm x.
  apply/implyP.
  rewrite inE kAutE.
  case/andP => Hx _.
  suff: val x \is a kAut K E by case/andP.
  rewrite kAutE (kHomSr (subvf E)) //=.
  apply/subvP => a.
  case/memv_imgP => {a} a Ha ->.
  case: (Hnorm _ Ha) => r.
  move/allP => Hr Har.
  apply: Hr.
  rewrite -root_prod_XsubC.
  move/(f_equal (map_poly (fun_of_lfun x))): (Har).
  rewrite (kHomFixedPoly Hx) ?minPolyOver //= Har => ->.
  by rewrite rmorph_root // -Har root_minPoly.
move => Hnorm a HaE.
case: (splitting_field_normal K a) => r.
move/eqP => Hr.
exists r => //.
apply/allP => b.
rewrite -root_prod_XsubC -Hr => Hroot.
set y := kHomExtend K \1%VF a b.
have Hy : y \is a kHom K <<K; a>>%AS.
  apply: kHomExtendkHom.
  - by apply subvv.
  - by apply kHom1.
  - by rewrite map_poly_id // => ? ?; rewrite id_lfunE.
case: (kHom_extend_fAutL Hy) => g Hg.
have <- : g a = b.
  rewrite -Hg ?memv_adjoin // (kHomExtendX (kHom1 K _)) // map_poly_id //.
  by move => ? _ /=; rewrite id_lfunE.
have HgK : (g \in kAAutL K).
  rewrite inE kAutE subvf andbT.
  apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
  move/subvP: (subv_adjoin K a) => HKa x Hx /=; rewrite -Hg; last first.
    by apply: HKa.
  by move/kHomP: Hy => [Hy _]; apply Hy.
move/implyP/(_ HgK)/eqP: (Hnorm g) <-.
by apply: memv_img.
Qed.

Lemma normalField1f : normalField 1 {:L}.
Proof.
apply/normalFieldP => a _.
case: (splitting_field_normal 1 a) => r /eqP ->.
exists r => //.
apply/allP => x _ /=.
by rewrite memvf.
Qed.

Lemma normalFieldS K M E : (K <= M)%VS -> normalField K E -> normalField M E.
Proof.
move => HKM /normalFieldP Hnorm.
apply/normalFieldP => a Ha.
have [r /allP Hr Har] := Hnorm _ Ha.
have := minPolyS a HKM.
rewrite Har.
case/dvdp_prod_XsubC => m Hm.
exists (mask m r); first by apply/allP => x Hx; apply: Hr; apply: (mem_mask Hx).
by apply/eqP; rewrite -eqp_monic ?monic_prod_XsubC // monic_minPoly.
Qed.

Lemma splitting_normalField E K :
  reflect (exists2 p, p \is a polyOver K & splittingFieldFor K p E)
          ((K <= E)%VS && normalField K E).
Proof.
  apply: (iffP andP); last first.
  case => p HpK [rs Hp HE]; split; first by rewrite -HE subv_adjoin_seq.
  apply/forallP => x.
  rewrite inE kAutE.
  apply/implyP => /andP [Hx _].
  rewrite -dimv_leqif_eq ?limg_dim_eq //.
    have /eqP -> := fAutL_lker0 x.
    by rewrite capv0.
  rewrite -HE aimg_adjoin_seq.
  case/andP: (Hx) => /fixedSpace_limg -> _.
  apply/adjoin_seqSr.
  move => _ /mapP [y Hy ->].
  move: Hy.
  rewrite -!root_prod_XsubC -!(eqp_root Hp).
  by apply: (kHom_rootK _ Hx) => //; rewrite ?subvf ?memvf.
case => HKE /normalFieldP => Hnorm.
have {Hnorm} Hnorm a : { r : seq L |
  a \in E -> (all (mem E) r /\ minPoly K a = \prod_(b <- r) ('X - b%:P))}.
  case: (boolP (a \in E)) => [HaE|_]; last by exists [::].
  have Hr : exists r : seq L, 
    (all (mem E) r) && (minPoly K a == \prod_(b <- r) ('X - b%:P)).
    by have [r Hr Hmin] := Hnorm _ HaE; exists r; rewrite Hr Hmin eqxx.
  have /andP [HrE /eqP Hmin] := xchooseP Hr.
  by exists (xchoose Hr).
exists (\prod_(r <- vbasis E) (minPoly K r)).
  by apply: rpred_prod => i _; apply: minPolyOver.
exists (flatten [seq (sval (Hnorm r)) | r <- vbasis E]).
  have := (basis_mem (vbasisP E)).
  elim: (vbasis E : seq L) => [|a s IH HE]; first by rewrite !big_nil eqpxx.
  rewrite big_cons /= big_cat /=.
  have HaE : a \in E by apply HE; rewrite inE eqxx.
  have [_ <-] := svalP (Hnorm a) HaE.
  apply: eqp_mull; apply IH => b Hb.
  by apply: HE; rewrite inE Hb orbT.
apply: subv_anti; apply/andP; split; last first.
  rewrite -[X in (X <= _)%VS]subfield_closed.
  rewrite -[X in <<X>>%AS](addv_idPr HKE).
  rewrite -[X in (K + X)%VS](span_basis (vbasisP E)).
  rewrite adjoin_seqSr // => a Ha.
  have HaE := (basis_mem (vbasisP E) Ha).
  elim: (vbasis E : seq L) Ha => [//|b s IH].
  rewrite inE /= mem_cat.
  move/orP => [/eqP <-|/IH ->]; last by rewrite orbT.
  rewrite -root_prod_XsubC.
  have [_ <-] := svalP (Hnorm a) HaE.
  by rewrite root_minPoly.
apply/Fadjoin_seqP; split; first done.
move: (fun a => basis_mem (x:=a) (vbasisP E)).
elim: (vbasis E : seq L) => [//|a s IH Has b].
rewrite /= mem_cat; move/orP => [Hb|]; last first.
  by apply: IH => c Hc; rewrite Has // inE Hc orbT.
have HaE : a \in E by apply Has; rewrite inE eqxx.
have [/allP HE _]:= (svalP (Hnorm a) HaE).
by apply: HE.
Qed.

Lemma kHom_gal K M E f : (K <= M <= E)%VS -> normalField K E ->
  f \is a kHom K M -> {x | x \in 'Gal(E / K) & {in M, f =1 x}}.
Proof.
case/andP => HKM HME Hnorm HfKM.
have [g Hfg] := kHom_extend_fAutL HfKM.
  suff HgKE : (g : 'End(L)) \is a kAut (K :&: E) E.
  have [x] := (kAut_gal HgKE).
  rewrite -gal_cap => Hx Hgx.
  exists x; first done.
  move => a Ha /=; rewrite Hfg // Hgx //.
  by apply: (subvP HME).
have HgKE : (g : 'End(L)) \is a kHom K {:L}.
  apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
  move => a Ha /=.
  case/kHomP: HfKM => HfK _.
  rewrite -Hfg ?HfK //.
  by apply: (subvP HKM).
rewrite qualifE (kHomS (capvSl K E) (subvf _)) //.
apply: (implyP (forallP Hnorm g)).
by rewrite inE kAutE subvf andbT.
Qed.

Lemma normalField_root_minPoly K E a b : (K <= E)%VS -> normalField K E ->
  a \in E -> root (minPoly K a) b ->
  exists2 x, x \in 'Gal(E / K) & x a = b.
Proof.
move => HKE Hnormal Ha Hb.
pose f := (kHomExtend K \1 a b).
have HfK : f \is a kHom K <<K; a>>%AS.
  apply: kHomExtendkHom; rewrite ?kHom1 ?subvv // map_poly_id // => ? _.
  by rewrite id_lfunE.
have HKEa : (K <= <<K; a>>%AS <= E)%VS.
  by rewrite subv_adjoin; apply/FadjoinP; rewrite HKE Ha.
have [x Hx Hfx] := kHom_gal HKEa Hnormal HfK.
exists x; first done.
rewrite -Hfx ?memv_adjoin // (kHomExtendX (kHom1 K K)) // map_poly_id //.
by move => ? _ /=; rewrite id_lfunE.
Qed.

Lemma normalField_factors K E : (K <= E)%VS ->
 reflect (forall a, a \in E -> 
   exists2 r : seq (gal_of E),
     r \subset 'Gal(E / K) &
     minPoly K a = \prod_(x <- r) ('X - (x a)%:P))
   (normalField K E).
Proof.
move => HKE.
apply: (iffP idP); last first.
  move => Hfactor.
  apply/normalFieldP => a Ha.
  case: (Hfactor a Ha) => r /subsetP Hr ->.
  exists [seq x a | x : gal_of E <- r]; last by rewrite big_map.
  apply/allP => _ /mapP [b /(Hr _) Hb ->].
  by apply: memv_gal.
move => Hnorm a Ha.
case/normalFieldP/(_ a Ha): (Hnorm) => r Hr Hmin.
pose f b := [pick x in 'Gal(E / K) | x a == b].
exists (pmap f r).
  apply/subsetP => x.
  rewrite mem_pmap /f.
  case/mapP => b _.
  by case: (pickP _) => // c /andP [Hc _] [->].
rewrite Hmin.
have : all (root (minPoly K a)) r.
  by apply/allP => b; rewrite Hmin root_prod_XsubC.
elim: r {Hmin} Hr => [|b s IH /andP [Hb Hs] /andP [Hrootb Hroots]].
  by rewrite !big_nil.
rewrite /= [f b]/f.
case: (pickP _) => /=; last first.
  move/pred0P.
  apply: contraTeq => _.
  have [x Hx /eqP Hxa] := normalField_root_minPoly HKE Hnorm Ha Hrootb.
  apply/existsP; exists x.
  by apply/andP.
move => x /andP [Hx /eqP Hxa].
by rewrite !big_cons IH ?Hxa.
Qed.

Definition galois U V := [&& (U <= V)%VS, separable U V & normalField U V].

Lemma galoisS K M E : (K <= M <= E)%VS -> galois K E -> galois M E.
Proof.
move => /andP [HKM HME] /and3P [_ Hsep Hnorm].
by rewrite /galois HME (separableSl HKM) // (normalFieldS HKM).
Qed.

Lemma galois_dim K E : galois K E -> \dim_K E = #|'Gal(E / K)|.
Proof.
case/and3P => HKE.
move/(separableSeparableGenerator)/(_ HKE) => -> Hnorm.
set (a:= separableGenerator K E).
case/normalFieldP/(_ _ (memv_adjoin K a)): (Hnorm) => rs /allP /= Hrs Hmin.
rewrite (dim_sup_field (subv_adjoin K a)) mulnK ?adim_gt0 //.
apply: succn_inj.
rewrite -elementDegreeE -size_minPoly Hmin size_prod_XsubC.
congr (_.+1)%N.
move: (separableGeneratorSep E K).
rewrite /separableElement Hmin separable_prod_XsubC.
move/card_seq_sub <-.
have Hex : forall r : seq_sub rs, exists x,
  (x \in 'Gal(<<K; a>>%AS / K)) && (x a == val r).
  move => r.
  have : root (minPoly K a) (val r).
    by rewrite Hmin root_prod_XsubC; apply: valP.
  case/(normalField_root_minPoly (subv_adjoin _ _) Hnorm (memv_adjoin _ _)).
  move => x HxK /eqP Hxa.
  by exists x; rewrite HxK Hxa.
set (f r := xchoose (Hex r)).
have /card_imset <- : injective f.
  move => x y /eqP.
  case/andP: (xchooseP (Hex x)) => HxK /eqP Hxa.
  case/andP: (xchooseP (Hex y)) => HyK /eqP Hya.
  rewrite gal_eq_Fadjoin // Hxa Hya.
  by move/eqP/val_inj.
rewrite [_ @: _](_ : _ = 'Gal(<<K; a>>%AS / K)) //.
apply/eqP; rewrite eqEsubset; apply/andP; split.
  apply/subsetP => _ /imsetP [r Hr ->].
  by case/andP: (xchooseP (Hex r)).
apply/subsetP => x Hx.
have Hxa : x a \in rs.
  by rewrite -root_prod_XsubC -Hmin root_minPoly_gal ?memv_adjoin ?subv_adjoin.
have -> : x = f (SeqSub Hxa); last by apply: mem_imset.
apply/eqP; case/andP: (xchooseP (Hex (SeqSub Hxa))) => ? ?.
by rewrite gal_eq_Fadjoin // eq_sym.
Qed.

Lemma galois_factors K E : 
 reflect ((K <= E)%VS /\ (forall a, a \in E -> 
   exists r : seq (gal_of E), [/\
     r \subset 'Gal(E / K)%g,
     uniq [seq x a | x : gal_of E <- r] &
     minPoly K a = \prod_(b <- [seq x a | x : gal_of E <- r])
                         ('X - b%:P)]))
   (galois K E).
Proof.
apply: (iffP idP).
case/and3P => HKE Hsep /(normalField_factors HKE) Hnorm; split; first done.
  move => a HaE.
  case/Hnorm: (HaE) => r Hr Hmin.
  exists r; split => //; last by rewrite big_map.
  rewrite -separable_prod_XsubC big_map -Hmin.
  by move/separableP/(_ _ HaE): Hsep.
case => HKE Hfixed.
apply/and3P; split => //.
  apply/separableP => a /Hfixed [rs [_ Huniq Hmin]].
  by rewrite /separableElement Hmin separable_prod_XsubC.
apply/(normalField_factors HKE) => a.
case/Hfixed => r [Hrs _ Hmin].
exists r => //.
by rewrite Hmin big_map.
Qed.

Lemma splitting_galoisField K E :
  reflect (exists p, [/\ p \is a polyOver K,
                         splittingFieldFor K p E &
                         separablePolynomial p])
          (galois K E).
Proof.
apply: (iffP and3P).
  case => HKE /separableSeparableGenerator/(_ HKE) ->.
  set a:= separableGenerator K E.
  move/normalFieldP => Hnorm.
  exists (minPoly K a); split.
  - by apply: minPolyOver.
  - have [r /= /allP Hr Har] := (Hnorm _ (memv_adjoin _ _)).
    exists r; first by rewrite Har eqpxx.
    apply: subv_anti; apply/andP; split.
      by apply/Fadjoin_seqP; split => //; apply: subv_adjoin.
    apply/FadjoinP; split; first apply: subv_adjoin_seq.
    apply: seqv_sub_adjoin.
    by rewrite -root_prod_XsubC -Har root_minPoly.
  - by apply separableGeneratorSep.
case => p [Hp Hsplit Hsep]; split.
- have [? _ <-] := Hsplit.
  by apply: subv_adjoin_seq.
- have [rs Hrs <-] := Hsplit.
  apply: separable_Fadjoin_seq.
  apply/allP => x Hx.
  apply/separableElementP.
  exists p.
  rewrite Hp Hsep; repeat split => //.
  by rewrite (eqp_root Hrs) root_prod_XsubC.
- have : (exists2 p, p \is a polyOver K & splittingFieldFor K p E).
    by exists p.
  by case/splitting_normalField/andP.
Qed.

Lemma galois_fixedField K E :
  reflect (fixedField 'Gal(E / K)%g = K) (galois K E).
Proof.
apply (iffP idP).
  case/and3P => HKE /separableP Hsep Hnorm.
  apply:subv_anti.
  rewrite galois_connection_subv ?andbT => //.
  apply/subvP => a /fixedFieldP [HaE Ha].
  case/normalFieldP/(_ _ HaE): (Hnorm) => rs /allP HrsE Hmin.
  move/(_ _ HaE): Hsep.
  rewrite elemDeg1 -eqSS -size_minPoly Hmin size_prod_XsubC eqSS.
  rewrite /separableElement Hmin separable_prod_XsubC.
  move/(count_uniq_mem a).
  have -> : a \in rs by rewrite -root_prod_XsubC -Hmin root_minPoly.
  move => /= <-; rewrite eq_sym -all_count.
  apply/allP => b Hb.
  have : root (minPoly K a) b by rewrite Hmin root_prod_XsubC.
  case/(normalField_root_minPoly HKE Hnorm HaE) => x Hx <-.
  by rewrite /= Ha.
move => Hfixed.
have HKE : (K <= E)%VS by rewrite -Hfixed capvSl.
apply/galois_factors; split; first done.
move => a HaE.
pose roots := seq_sub [seq x a | x : gal_of E <- enum 'Gal(E / K)].
have Hroot_aut (b : roots) : exists x, (x \in 'Gal(E / K)) && (x a == val b).
  case/mapP: (valP b) => [x Hx Hxb].
  by exists x; rewrite Hxb eqxx andbT -mem_enum.
pose root_repr b := xchoose (Hroot_aut b).
have : forall b, root_repr b a = val b.
  by move => b; case/andP: (xchooseP (Hroot_aut b)) => _ /eqP ->.
have : forall b, root_repr b \in 'Gal(E / K).
  by move => b;  case/andP: (xchooseP (Hroot_aut b)).
move: root_repr => root_repr Hroot_repr_aut Hroot_repr.
have Hroot_map_uniq : uniq
    [seq x a | x : gal_of E <- map root_repr (enum predT)].
  rewrite -map_comp map_inj_uniq ?enum_uniq //.
  by move => b c //=; rewrite !Hroot_repr; apply: val_inj.
exists (map root_repr (enum predT)); split => //.
  by apply/subsetP => _ /mapP [b Hb ->].
apply/eqP; rewrite -eqp_monic ?monic_minPoly ?monic_prod_XsubC //.
apply/andP; split; last first.
  apply uniq_roots_dvdp; last first.
    by rewrite -[map _ _]map_id -[map _ ]/(map idfun) map_uniq_roots.
  rewrite -map_comp; apply/allP => _ /mapP [b Hb ->] /=.
  by rewrite root_minPoly_gal.
apply minPoly_dvdp; last first.
  rewrite root_prod_XsubC.
  apply/mapP.
  have Haroot : a \in [seq x a | x : gal_of E <- enum 'Gal(E / K)].
    apply/mapP; exists 1%g; last by rewrite gal_id.
    by rewrite mem_enum group1.
  exists (root_repr (SeqSub Haroot)); last by rewrite Hroot_repr.
  by apply: map_f; rewrite mem_enum.
rewrite -map_comp big_map.
apply/polyOverP => i /=.
rewrite -[in X in _ \in X]Hfixed.
apply/fixedFieldP; split.
  apply: polyOverP i.
  apply: rpred_prod => b Hb.
  by rewrite rpredB ?polyOverX // polyOverC memv_gal.
move => x Hx.
rewrite -coef_map rmorph_prod. congr ((polyseq _) `_ _).
symmetry.
have Hreindex (b : roots) : x (val b) \in
     [seq x a | x : gal_of E <- enum 'Gal(E / K)].
  rewrite -Hroot_repr -comp_lfunE -galM //; apply: map_f.
  by rewrite mem_enum groupM.
pose h (b : roots) := SeqSub (Hreindex b) : roots.
rewrite -filter_index_enum filter_predT (reindex_inj (h:=h)) /=.
  apply: eq_bigr => {i} i _.
  rewrite rmorphB /= map_polyX map_polyC /=; congr (_ - _%:P).
  by rewrite !Hroot_repr.
move => b c; move/(f_equal val) => /=.
by move/fmorph_inj/val_inj.
Qed.

Lemma mem_galTrace K E a : galois K E -> a \in E -> galTrace K E a \in K.
Proof.
move/galois_fixedField => HK.
rewrite -{2}HK.
by apply: galTrace_fixedField.
Qed.

Lemma mem_galNorm K E a : galois K E -> a \in E -> galNorm K E a \in K.
Proof.
move/galois_fixedField => HK.
rewrite -{2}HK.
by apply: galNorm_fixedField.
Qed.

Lemma gal_independent E (P : pred (gal_of E))
  (c_ : gal_of E -> L) :
  (forall a, a \in E -> \sum_(x | P x) (c_ x) * (x a) = 0) ->
  (forall x, P x -> c_ x = 0).
Proof.
move => Hsum; move: {2}(#|P|) (erefl #|P|) => n.
elim: n c_ P Hsum => [|n IHn] c_ P Hsum.
  by move/card0_eq => HP0 x; rewrite -[P x]/(x \in P) HP0.
move => Hcard x Hx.
suff Hcy : forall y, P y && (y != x) -> c_ y = 0.
  move: (Hsum _ (mem1v E)).
  rewrite (bigD1 _ Hx) big1 /=; first by rewrite rmorph1 mulr1 addr0.
  by move => y Hy; rewrite (Hcy _ Hy) mul0r.
move => y Hyx; case/andP:(Hyx) => HyP /gal_eqP/eqlfun_inP/subvPn [a HaE].
rewrite memv_ker !lfun_simp => Hyxa.
pose d_ y := c_ y * (y a - x a).
apply: (mulIf Hyxa); rewrite mul0r.
apply: (IHn d_ (fun i => P i && (i != x))) => //; last first.
  by move: Hcard; rewrite (cardD1x Hx) add1n; case.
move => b HbE.
have HabE :  a * b \in E by rewrite memv_mul.
rewrite -[X in _ = X]subr0 -[X in _ - X](mulr0 (x a)).
rewrite -[X in _ * X](Hsum _ HbE) -[X in X - _](Hsum _ HabE).
symmetry; rewrite mulr_sumr -sumrB (bigD1 _ Hx) rmorphM /=.
rewrite !mulrA -[X in X * _]mulrC subrr add0r; apply eq_bigr => i Hi.
by rewrite rmorphM /= /d_ mulrBr mulrBl !mulrA -[X in _ - X * _]mulrC.
Qed.

Lemma gal_independent_contra E (P : pred (gal_of E))
  (c_ : gal_of E -> L) x : P x -> c_ x != 0 ->
  exists2 a, a \in E & \sum_(x | P x) (c_ x) * (x a) != 0.
Proof.
move => HPx Hcx.
pose f : 'End(L) := (\sum_(y | P y) (amull (c_ y) \o y)%VF).
suff /lfunPn [a] : (f \o projv E)%VF != 0.
  rewrite zero_lfunE comp_lfunE sum_lfunE => Ha.
  exists (projv E a); first by apply:memv_proj.
  move: Ha; apply: contra; move/eqP => Ha; apply/eqP.
  apply:{Ha} (eq_trans _ Ha); apply: eq_bigr => i _.
  by rewrite comp_lfunE lfunE.
have /existsP : exists x, P x && (c_ x != 0) by exists x; rewrite HPx.
apply: contraL => /eqP/lfunP Hf {x HPx Hcx}.
rewrite negb_exists_in; apply/forallP => x; apply/implyP => HPx; rewrite negbK.
apply/eqP; apply: (gal_independent (P:=P)) => // a Ha; rewrite -(projv_id Ha).
move: (Hf a); rewrite zero_lfunE comp_lfunE sum_lfunE /=; apply: eq_trans.
apply: eq_bigr => i _.
by rewrite comp_lfunE lfunE.
Qed.

Lemma hilbert's_theorem_90 K E x a :
 <[x]>%g = 'Gal(E / K) -> a \in E ->
 reflect (exists2 b, b \in E /\ b != 0 & a = b / (x b))
         (galNorm K E a == 1).
Proof.
move => Hx HaE.
have HxEK : x \in 'Gal(E / K)%g by rewrite -Hx cycle_id.
apply: (iffP eqP); last first.
  case => b [HbE Hb0] ->.
  by rewrite galNormM galNormV galNorm_gal // mulfV // galNorm_eq0.
move => Hnorm.
have Hlog y : {i : 'I_#[x] | y \in <[x]> -> x ^+ i = y}%g.
  case: (boolP (y \in <[x]>%g)).
    by case/cyclePmin => [i Hix Hi]; exists (Ordinal Hix).
  by rewrite -(prednK (order_gt0 x)); exists ord0.
pose log y := sval (Hlog y).
have Hlog_small m : m < #[x]%g -> log (x ^+ m)%g = m :> nat.
  move => Hm.
  move: (svalP (Hlog (x ^+ m)%g) (groupX m (cycle_id _))).
  by move => /eqP; rewrite eq_expg_mod_order !modn_small //; move/eqP.
have Hlog1 : log 1%g = 0%N :> nat by rewrite -(expg0 x) Hlog_small.
pose d_ n := \prod_(i < n) (x ^+ i)%g a.
pose c_ y := d_ (log y).
have Hc0 : c_ 1%g != 0 by rewrite /c_ /d_ Hlog1 big_ord0 oner_neq0.
have : [pred i in 'Gal(E / K)] 1%g by apply: group1.
case/(gal_independent_contra)/(_ Hc0) => d HdE /=.
set b := \sum_(i in _) _ => Hb0.
exists b; first split => //.
  apply: rpred_sum => i Hi.
  apply: rpredM; last by apply: memv_gal.
  apply: rpred_prod => j _. by apply: memv_gal.
apply: (canRL (mulfK _)); first by rewrite fmorph_eq0.
have Hlog_bij : {on [pred i in 'Gal(E / K)],
                    bijective (fun i : 'I_#[x]%g => (x ^+ i)%g)}.
  exists (fun x => sval (Hlog x)) => j Hj.
    by apply: ord_inj; apply: Hlog_small; apply: ltn_ord.
  apply: (svalP (Hlog j)).
  by rewrite inE -Hx in Hj.
move: Hnorm; rewrite /b /galNorm !(reindex _ Hlog_bij) /=.
have Hxj: [pred j : 'I_#[x]%g | (x ^+ j)%g \in 'Gal(E / K)] =1 [pred j | true].
  by move => j; rewrite !inE groupX.
rewrite !(eq_bigl _ _ Hxj) /= => Hnorm.
rewrite rmorph_sum mulr_sumr /=.
have Had i : a * x (d_ i) = d_ i.+1.
  rewrite /d_ rmorph_prod /=.
  rewrite big_ord_recl expg0 gal_id; congr (_ * _).
  by apply: eq_bigr => j _; rewrite expgSr galM // comp_lfunE.
rewrite -(prednK (order_gt0 x)) big_ord_recr /= big_ord_recl.
rewrite addrC expg0 gal_id; congr (_ + _).
  rewrite rmorphM /= mulrA Had /c_ Hlog1 /d_ big_ord0.
  rewrite -comp_lfunE -galM // -expgSr (prednK (order_gt0 x)).
  rewrite expg_order gal_id.
  by rewrite Hlog_small (prednK (order_gt0 x)) // Hnorm.
apply: eq_bigr => i _.
rewrite rmorphM /= -comp_lfunE -galM // -expgSr mulrA.
rewrite /c_ Had !Hlog_small //.
  by move: (ltn_ord i); rewrite -ltnS (prednK (order_gt0 x)).
by move/ltnW: (ltn_ord i); rewrite -ltnS (prednK (order_gt0 x)).
Qed.

Section Matrix.

Variable (E : {subfield L}) (s : {set gal_of E}).

Let K := fixedField s.

Lemma gal_matrix :
  {w : #|s|.-tuple L | {subset w <= E} /\ 0 \notin w &
    [/\ \matrix_(i < #|s|, j < #|s|) enum_val i (tnth w j) \in unitmx,
        directv (\sum_i K * <[tnth w i]>) &
        group_set s -> (\sum_i K * <[tnth w i]>)%VS = E] }.
Proof.
have [w [HwE H0w]] : {w : #|s|.-tuple L | {subset w <= E} /\ 0 \notin w &
    \matrix_(i < #|s|, j < #|s|) (nth 1%g (enum s) i) (tnth w j) \in unitmx}.
  rewrite cardE.
  elim: (enum s) (enum_uniq (pred_of_set s)) => [_|x xs IH Huniq].
    exists [tuple] => [//|].
    by rewrite unitmxE det_mx00 unitr1.
  move: (Huniq); rewrite cons_uniq => /andP [Hx].
  move/(IH) => {IH} [w [Hw H0w]].
  set M := \matrix_(i, j) _ => HM /=.
  pose a := \row_i x (tnth w i) *m (invmx M).
  pose c_ y := nth (-1) [tuple a 0 i | i < (size xs)] (index y xs).
  pose P := [pred y in x :: xs].
  have HPy : P x by rewrite !inE eqxx.
  have Pcx1 : c_ x = -1.
    by rewrite /c_ nth_default // size_tuple leqNgt index_mem.
  have Pcx0 : c_ x != 0 by rewrite Pcx1 oppr_eq0 oner_neq0.
  have w0ex : exists a : L, (a \in E) && (\sum_(x0 | P x0) c_ x0 * x0 a != 0).
    have [w0 Hw0E Hw0] := gal_independent_contra HPy Pcx0.
    by exists w0; rewrite Hw0E Hw0.
  move: {w0ex} (xchoose w0ex) (xchooseP w0ex) => w0 /andP [Hw0E].
  set S := BigOp.bigop _ _ _ _ _ => HS.
  exists [tuple of cons w0 w].
    split.
    - move => i.
      rewrite inE.
      case/orP => [/eqP -> //|].
      by apply: Hw.
    - rewrite inE negb_or H0w andbT.
      apply: contra HS; rewrite /S.
      move/eqP <-.
      rewrite big1 // => i _.
      by rewrite rmorph0 mulr0.
  rewrite unitmxE -[\det _]mul1r.
  pose B := block_mx 1 (-a) 0 1%:M.
  have <- : \det B = 1 by rewrite det_ublock !det1 mulr1.
  set M' := \matrix_(_,_) _.
  rewrite -det_mulmx -[M'](@submxK _ 1 _ 1 _) mulmx_block.
  rewrite !mul0mx !mul1mx !add0r.
  set DR := drsubmx _.
  have -> : DR = M.
    apply/matrixP => i j.
    by rewrite !mxE !(tnth_nth 0).
  rewrite (_ : ursubmx (_) + _ = 0); last first.
    apply/matrixP => ? j.
    rewrite ord1 mxE mulNmx mulmxKV // !(row_mxEr, mxE).
    by rewrite !(tnth_nth 0) /= subrr.
  rewrite det_lblock unitrM andbC -unitmxE HM /=.
  rewrite (_ : ulsubmx _ = (x w0)%:M); last first.
    apply/matrixP => i j.
    by rewrite !ord1 !(row_mxEl, mxE) !(tnth_nth 0).
  rewrite unitfE (_ : _ + _ = -(S%:M)).
    by rewrite -scaleN1r detZ det_scalar1 expr1 mulN1r oppr_eq0.
  apply/matrixP => i j.
  rewrite !ord1 !mxE !eqxx /S -big_uniq // big_cons Pcx1 /=.
  rewrite -mulNrn !mulr1n mulN1r opprD opprK -sumrN; congr (_ + _).
  rewrite [X in _ = X](big_tnth 0); apply eq_bigr => k _.
  rewrite /c_ index_uniq; last first.
  - by case/andP: Huniq; rewrite in_tupleE.
  - by rewrite in_tupleE; apply: ltn_ord.
  - rewrite nth_mktuple.
    rewrite -mulNr mxE; congr (_ * _).
    by rewrite !mxE (tnth_nth 0) (tnth_nth 1%g).
set M := \matrix_(i,j) _ => HM.
move: (HM); rewrite -unitmx_tr => HMT.
exists w => [//|]; split.
- rewrite (_ : \matrix_(i, j) _ = 
               \matrix_(i, j) (nth 1%g (enum s) i) (tnth w j)) //.
  apply/matrixP => i j.
  by rewrite !mxE -enum_val_nth.
- apply/directv_sum_independent => kw_ HkwKw Hkw j _.
  have Hk i : exists k, (k \in K) && (k * tnth w i == kw_ i).
    case/memv_cosetP : (HkwKw i isT) => kwi HkwiK Hkwi.
    by exists kwi; rewrite HkwiK Hkwi eqxx.
  pose kv := \row_i (xchoose (Hk i)).
  suff /matrixP/(_ ord0 j) : kv = 0.
    rewrite !mxE => Hkj.
    have /andP [_ /eqP <-] := xchooseP (Hk j).
    by rewrite Hkj mul0r.
  rewrite {j} -(mul0mx _ (invmx M^T)).
  apply: (canRL (mulmxK HMT)).
  apply/matrixP => ? i.
  rewrite ord1 !mxE -[X in _ = X](rmorph0 [rmorphism of nth 1%g (enum s) i]).
  rewrite -[in X in _ = X]Hkw rmorph_sum; apply: eq_bigr => j _.
  rewrite !mxE /=.
  have /andP [/fixedFieldP [_ Hkj] /eqP] := xchooseP (Hk j).
  move/(f_equal (nth 1%g (enum s) i)) <-.
  by rewrite rmorphM /= Hkj // -mem_enum mem_nth // -cardE ltn_ord.
- move => Hs.
  apply: subv_anti; apply/andP; split.
    apply/subv_sumP => i _.
    apply: (subv_trans _ (asubv _)).
    apply: prodvS; first by apply: capvSl.
    apply: HwE.
    by apply: mem_tnth.
  apply/subvP => w0 Hw0.
  apply/memv_sumP.
  pose wv := (\row_(i < #|s|) enum_val i w0).
  pose v := wv *m invmx (M^T).
  have HvE i : v 0 i \in E.
    rewrite mxE; apply: rpred_sum => j _.
    rewrite !mxE; apply: rpredM; first by apply: memv_gal.
    have HME (a b : 'I_#|s|) : (nth 1%g (enum s) a (tnth w b)) \in E.
      by apply: memv_gal; apply: HwE; apply: mem_tnth.
    suff HmatrixE n (N : 'M_n) : (forall i j, N i j \in E) -> \det N \in E.
      rewrite /invmx HMT !mxE.
      by rewrite rpredM // ?rpredV ?rpredM ?rpredX ?rpredN ?rpred1 //;
        apply: HmatrixE => a b; rewrite !mxE; apply: HME.
    move => HN.
    apply: rpred_sum => k _.
    by rewrite rpredM ?rpredX ?rpredN ?rpred1 //; apply: rpred_prod => l _.
  exists (fun i => v 0 i * tnth w i) => [i _|]; last first.
    pose j := (enum_rank_in (group1 (group Hs)) 1%g).
    transitivity (wv 0 j).
      by rewrite mxE enum_rankK_in ?gal_id // (group1 (group Hs)).
    rewrite -[wv](mulmxKV HMT) -/v.
    move: {HvE} v => v.
    rewrite !mxE; apply eq_bigr => i _; rewrite !mxE.
    by rewrite -enum_val_nth enum_rankK_in ?gal_id // (group1 (group Hs)).
  apply: memv_prod; last by rewrite memv_line.
  apply/fixedFieldP; split => [//|x Hxs].
  transitivity (map_mx x v 0 i); first by rewrite [X in _ = X]mxE.
  move: 0 i; apply/matrixP.
  apply: (canRL (mulmxK HMT)).
  apply: (map_mx_inj (f:= [rmorphism of x^-1%g])).
  apply/matrixP => ? i; rewrite ord1.
  rewrite !mxE rmorph_sum /= -comp_lfunE -galM //.
  pose h (i : 'I_#|s|) :=
    enum_rank_in (group1 (group Hs)) (enum_val i * x^-1)%g.
  have Hh : enum_val (h i) = (enum_val i * x^-1)%g.
    rewrite enum_rankK_in //.
    by rewrite -[s]/(group Hs : {set gal_of E}) groupM ?groupV ?enum_valP.
  transitivity ((v *m M^T) 0 (h i)); last by rewrite mulmxKV // mxE Hh.
  rewrite mxE; apply: eq_bigr => j _.
  rewrite rmorphM mxE /= -comp_lfunE -galM // mulgV gal_id; congr (_ * _).
  by rewrite !mxE -!enum_val_nth Hh galM ?HwE ?mem_tnth // comp_lfunE.
Qed.

End Matrix.

Lemma dim_fixedField E (g : {group gal_of E}) : #|g| = \dim_(fixedField g) E.
Proof.
have [w [_ Hw0] [_ Hdirect /(_ (groupP g)) HE]] := gal_matrix g.
rewrite directvE /= in Hdirect.
rewrite -[X in dimv X]HE.
move/eqP: Hdirect ->.
rewrite [(\sum_ _ _)%N](_ : _ = \sum_(i < #|g|) \dim (fixedField g))%N.
  by rewrite sum_nat_const mulnK ?adim_gt0 // cardT -cardE card_ord.
apply: eq_bigr => i _.
rewrite dim_cosetv //.
apply: contra Hw0 => /eqP <-.
by apply: mem_tnth.
Qed.

Lemma gal_fixedField E (g : {group gal_of E}): 'Gal(E / fixedField g) = g.
Proof.
symmetry; apply/eqP; rewrite eqEcard; apply/andP; split.
  by apply: galois_connection_subset.
rewrite [X in _ <= X](_ : _ = \dim_(fixedField g) E); last first.
  by apply: dim_fixedField.
rewrite galois_dim ?leqnn //.
apply/galois_fixedField.
apply: subv_anti => /=.
rewrite galois_connection_subv ?capvSl // fixedFieldS //.
by apply: galois_connection_subset.
Qed.

Lemma fixedField_galois E (s : {set gal_of E}): galois (fixedField s) E.
Proof.
apply: (galoisS (K:=[aspace of (fixedField <<s>>%g)])).
  by rewrite capvSl andbT fixedFieldS // subset_gen.
apply/galois_fixedField => /=.
by rewrite gal_fixedField.
Qed.

Section FundamentalTheoremOfGaloisTheory.

Variables E K : {subfield L}.
Hypothesis Hgalois : galois K E.

Section IntermediateField.

Variable M : {subfield L}.
Hypothesis HKME : (K <= M <= E)%VS.
Hypothesis Hnorm : normalField K M.

Lemma normalField_galois : galois K M.
Proof.
case/andP: HKME => HKM HME.
case/and3P: Hgalois => HKE Hsep HnormKE. 
by rewrite /galois HKM (separableSr HME).
Qed.

Definition normalField_cast (x : gal_of E) : gal_of M :=
  gal (coset (kAAutL M) x).

Lemma normalField_cast_eq x : x \in 'Gal(E / K) ->
  {in M, normalField_cast x =1 x}.
Proof.
case/andP: HKME => HKM HME Hx a Ha /=.
apply: (aut_mem_eqP _ _ (eqxx (normalField_cast x))) => //.
  by apply: mem_repr_coset.
have HxKM : (x : 'End(L)) \is a kAut K M.
  apply: (normalField_kAut HKME) => //.
  by rewrite -(capv_idPl (subv_trans HKM HME)) -gal_kAut.
suff -> : (val (val (normalField_cast x))) = (coset (kAAutL M) x).
  by apply: (mem_kAut_coset (K:=K)).
rewrite /normalField_cast /= subgK // mem_quotient //= genGid inE.
by apply: (kAutS (sub1v K)).
Qed.

Lemma normalField_castM :
  {in 'Gal(E / K) &, {morph normalField_cast : x y / (x * y)%g}}.
Proof.
move => x y Hx Hy.
apply/eqP/gal_eqP => a Ha.
have HaE : a \in E by case/andP: HKME => _ /subvP; apply.
have /andP [_ /eqP HxM] : (x : 'End(L)) \is a kAut K M.
  apply: (normalField_kAut HKME) => //.
  case/andP: HKME => HKM HME.
  by rewrite -(capv_idPl (subv_trans HKM HME)) -gal_kAut.
rewrite galM // comp_lfunE.
rewrite {1}normalField_cast_eq ?groupM //.
rewrite galM // comp_lfunE.
rewrite [X in (normalField_cast y X)]normalField_cast_eq //.
by rewrite normalField_cast_eq // -HxM memv_img.
Qed.
Canonical normalField_cast_morphism := Morphism normalField_castM.

Lemma normalField_ker : ('ker normalField_cast)%g = 'Gal(E / M).
Proof.
case/andP: HKME => HKM HME.
apply/eqP; rewrite eqEsubset; apply/andP; split; apply/subsetP; last first.
  move => x Hx.
  apply/kerP; first by apply: (subsetP (galS E HKM)).
  apply/eqP/gal_eqP => a Ha.
  rewrite normalField_cast_eq //; last by apply: (subsetP (galS E HKM)).
  by rewrite gal_id (fixed_gal HME).
move => x Hx.
rewrite gal_kAut (capv_idPl HME) kAutE limg_gal subvv andbT.
apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
move => a Ha /=.
rewrite -normalField_cast_eq //; last by apply: (dom_ker Hx).
by rewrite (mker Hx) gal_id.
Qed.

Lemma normalField_normal : ('Gal(E / M) <| 'Gal(E / K))%g.
Proof.
rewrite -normalField_ker.
apply: ker_normal.
Qed.

Lemma normalField_img : (normalField_cast @* 'Gal(E / K))%g = 'Gal(M / K).
Proof.
case/andP: HKME => HKM HME.
apply/eqP; rewrite eqEsubset; apply/andP; split; apply/subsetP.
  move => _ /imsetP [x Hx ->].
  rewrite setIid in Hx.
  have HxM : (x : 'End(L)) \is a kAut (K :&: M) M.
    rewrite (capv_idPl HKM).
    apply: (normalField_kAut HKME) => //.
    by rewrite -(capv_idPl (subv_trans HKM HME)) -gal_kAut.
  apply: mem_morphim; rewrite mem_quotient //= genGid // inE //.
  by apply: (kAutS (sub1v (K :&: M))).
move => x Hx.
apply/imsetP; rewrite setIid.
have /and3P [_ _ HKE] := Hgalois.
have HxE : (x : 'End(L)) \is a kHom K M.
  rewrite gal_kAut (capv_idPl HKM) kAutE in Hx.
  by case/andP: Hx.
have [y Hy Hxy] := (kHom_gal HKME HKE HxE).
exists y => //.
apply/eqP/gal_eqP => a Ha.
by rewrite normalField_cast_eq // Hxy.
Qed.

Lemma normalField_isom :
 { f : {morphism ('Gal(E / K) / 'Gal(E / M)) >-> gal_of M} |
   isom ('Gal(E / K) / 'Gal (E / M)) 'Gal(M / K) f &
   (forall A, f @* (A / 'Gal(E / M)) = normalField_cast @* A) /\
   {in 'Gal(E / K), forall x, {in M, f (coset _ x) =1 x} } }%g.
Proof.
case: (first_isom [morphism of normalField_cast]).
rewrite normalField_ker => f Hf Hfcast.
exists f.
  apply/isomP; split; first done.
  by rewrite Hfcast normalField_img.
split => [//|x Hx a Ha].
suff -> : f (coset 'Gal(E / M) x) = normalField_cast x.
  by apply: normalField_cast_eq.
apply/set1P.
move: (Hfcast [set x]).
rewrite morphim_set1 // => <-.
apply: mem_morphim; first by apply: mem_quotient.
rewrite quotient_set1; first by apply: set11.
apply: subsetP x Hx.
by case/andP: normalField_normal.
Qed.

Lemma normalField_isog : ('Gal(E / K) / 'Gal(E / M) \isog 'Gal(M / K))%g.
Proof.
rewrite -normalField_ker -normalField_img.
apply: first_isog.
Qed.

End IntermediateField.

Section IntermediateGroup.

Variable g : {group gal_of E}.
Hypothesis Hg : g \subset 'Gal(E / K)%g.
Hypothesis Hnorm : 'Gal(E / K)%g \subset 'N(g)%g.

Lemma normal_fixedField_galois : galois K (fixedField g).
Proof.
case/and3P: Hgalois => HKE Hsep HnormEK.
rewrite /galois.
move: (Hg); rewrite (galois_connection _ HKE) => ->.
rewrite (separableSr _ Hsep) ?capvSl //.
apply/forallP => x; apply/implyP => Hx.
rewrite eqEdim limg_dim_eq ?(eqP (fAutL_lker0 _)) ?capv0 // leqnn andbT.
apply/subvP => _ /memv_imgP [a /fixedFieldP [HaE Ha] ->].
have HxKE : (x : 'End(L)) \is a kAut K E.
  rewrite kAutE.
  have /eqP -> := (implyP (forallP HnormEK x) Hx).
  rewrite subvv andbT.
  apply/kHomP; split; last by move => ? ? _ _; rewrite /= rmorphM.
  move: Hx; rewrite inE kAutE subvf andbT.
  by case/kHomP.
have [x' Hx' -> //] := kAut_gal HxKE.
apply/fixedFieldP; split => [|y Hy].
  by rewrite memv_gal // Aut_aut.
rewrite -comp_lfunE -galM //.
apply: (canRL_in (limg_lfunVK (f:=x'))).
  by rewrite lker0_limgf ?memvf // fAutL_lker0.
rewrite -galV; last first.
  by rewrite memv_gal // groupM ?Aut_aut.
rewrite -comp_lfunE -galM //.
apply: Ha.
rewrite -(class_sub_norm (G:=[group of 'Gal(E / K)])) // in Hy.
apply: (subsetP Hy).
by rewrite -[in X in (X * _)%g](invgK x') -mulgA -conjgE memJ_class // groupV.
Qed.

End IntermediateGroup.

End FundamentalTheoremOfGaloisTheory.

End GaloisTheory.

Notation "''Gal' ( V / U )" := (galoisG U V).
